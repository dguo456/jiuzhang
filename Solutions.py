##################################### Prefix Sum + Monotonic Stack ##############################################
# 84. Largest Rectangle in Histogram
# 239. Sliding Window Maximum
# 316. Remove Duplicate Letters
# 321. Create Maximum Number
# 402. Remove K Digits
# 456. 132 Pattern
# 496. Next Greater Element I
# 503. Next Greater Element II
# 556. Next Greater Element III
# 739. Daily Temperatures
# 856. Score of Parentheses
# 862. Shortest Subarray with Sum at Least K
# 901. Online Stock Span
# 907. Sum of Subarray Minimums
# 2104. Sum of Subarray Ranges
# 2281. Sum of Total Strength of Wizards
# 828. Count Unique Characters of All Substrings of a Given String
# 2262. Total Appeal of A String
# 1762. Buildings With an Ocean View
# 1944. Number of Visible People in a Queue
# 1130. Minimum Cost Tree From Leaf Values
# 1475. Final Prices With a Special Discount in a Shop
# 560. Subarray Sum Equals K
# 523. Continuous Subarray Sum
# 974. Subarray Sums Divisible by K
#################################################################################################################

############################################ Backtracking ########################################################
# 79. Word Search
# 212. Word Search II
# 489. Robot Room Cleaner
#################################################################################################################

################################################ Trie #########################################################
# 208. Implement Trie (Prefix Tree)
# 1804. Implement Trie II (Prefix Tree)
# 211. Design Add and Search Words Data Structure
#################################################################################################################

################################################ Tree #########################################################
# 101. Symmetric Tree
# 104. Maximum Depth of Binary Tree
# 111. Minimum Depth of Binary Tree
# 112. Path Sum
# 113. Path Sum II
# 437. Path Sum III
# 666. Path Sum IV
# 250. Count Univalue Subtrees
# 105. Construct Binary Tree from Preorder and Inorder Traversal
# 106. Construct Binary Tree from Inorder and Postorder Traversal
# 116. Populating Next Right Pointers in Each Node
# 117. Populating Next Right Pointers in Each Node II
# 199. Binary Tree Right Side View
# 545. Boundary of Binary Tree
# 297. Serialize and Deserialize Binary Tree
# 257. Binary Tree Paths
# 236. Lowest Common Ancestor of a Binary Tree
# 1644. Lowest Common Ancestor of a Binary Tree II
# 1650. Lowest Common Ancestor of a Binary Tree III
# 1676. Lowest Common Ancestor of a Binary Tree IV
# 889. Construct Binary Tree from Preorder and Postorder Traversal
#################################################################################################################

# 31. Next Permutation
# 1842. Next Palindrome Using Same Digits
# 339. Nested List Weight Sum
# 364. Nested List Weight Sum II
# 565. Array Nesting
# 173. Binary Search Tree Iterator
# 1586. Binary Search Tree Iterator II
# 251. Flatten 2D Vector
# 341. Flatten Nested List Iterator
# 281. Zigzag Iterator

# AMAZON
############################################# Top K #################################################
# 215. Kth Largest Element in an Array
# 347. Top K Frequent Elements
# 692. Top K Frequent Words
# 973. K Closest Points to Origin

############################################ Anagram #################################################
# 49. Group Anagrams
# 438. Find All Anagrams in a String
# 242. Valid Anagram

######################################################################################################
# 937. Reorder Data in Log Files
# 1268. Search Suggestions System
# 146. LRU Cache
# 460. LFU Cache
# 588. Design In-Memory File System
# 635. Design Log Storage System
# 1151. Minimum Swaps to Group All 1's Together
# 2134. Minimum Swaps to Group All 1's Together II
# 472. Concatenated Words
# 139. Word Break
# 140. Word Break II
# 1492. The kth Factor of n
############################################区间问题###############################################

# 56. Merge Intervals
# 57. Insert Interval
# 435. Non-overlapping Intervals
# 252. Meeting Rooms
# 253. Meeting Rooms II
# 729. My Calendar I
# 731. My Calendar II
# 759. Employee Free Time
# 1229. Meeting Scheduler
# 986. Interval List Intersections
# 1288. Remove Covered Intervals

###################################################################################################
# 287. Find the Duplicate Number
# 448. Find All Numbers Disappeared in an Array
# 127. Word Ladder
# 126. Word Ladder II
# 370. Range Addition
# 598. Range Addition II
# 206 / 92. Reverse Linked List I&II
# 2130. Maximum Twin Sum of a Linked List
# 1730. Shortest Path to Get Food
# 88. Merge Sorted Array
# 1940. Longest Common Subsequence Between Sorted Arrays
# 21. Merge Two Sorted Lists
# 23. Merge k Sorted Lists
# 994. Rotting Oranges
# 207. Course Schedule
# 210. Course Schedule II
# 630. Course Schedule III
# 269. Alien Dictionary
# 310. Minimum Height Trees
# 380. Insert Delete GetRandom O(1)
# 381. Insert Delete GetRandom O(1) - Duplicates allowed
# 121. Best Time to Buy and Sell Stock

# 322. Coin Change
# 518. Coin Change 2
# 266. Palindrome Permutation
# 267. Palindrome Permutation II
# 441. Arranging Coins
# 53. Maximum Subarray
# 2272. Substring With Largest Variance (53 的变形)
# 152. Maximum Product Subarray
# 238. Product of Array Except Self
# 713. Subarray Product Less Than K
# 398. Random Pick Index
# 528. Random Pick with Weight
# 710. Random Pick with Blacklist
# 320. Generalized Abbreviation
# 36. Valid Sudoku
# 37. Sudoku Solver
# 105. Construct Binary Tree from Preorder and Inorder Traversal
# 106. Construct Binary Tree from Inorder and Postorder Traversal
# 2. Add Two Numbers
# 445. Add Two Numbers II
# 42. Trapping Rain Water
# 138. Copy List with Random Pointer
# 133. Clone Graph
# 1490. Clone N-ary Tree
# 1485. Clone Binary Tree With Random Pointer
# 1136. Parallel Courses (similar 207)
# 1494. Parallel Courses II
# 2050. Parallel Courses III
# 1197. Minimum Knight Moves
# 1188. Design Bounded Blocking Queue
# 529. Minesweeper
# 494. Target Sum
# 542. 01 Matrix
# 12. Integer to Roman
# 273. Integer to English Words

# 62. Unique Paths
# 63. Unique Paths II
# 980. Unique Paths III
# 64. Minimum Path Sum
# 1921. Eliminate Maximum Number of Monsters
# 1937. Maximum Number of Points with Cost
# 1981. Minimize the Difference Between Target and Chosen Elements
# 209. Minimum Size Subarray Sum
# 581. Shortest Unsorted Continuous Subarray
# 76. Minimum Window Substring
# 30. Substring with Concatenation of All Words
# 727. Minimum Window Subsequence
# 674. Longest Continuous Increasing Subsequence
# 300. Longest Increasing Subsequence
# 673. Number of Longest Increasing Subsequence
# 354. Russian Doll Envelopes
# 71. Simplify Path

# 325. Maximum Size Subarray Sum Equals k
# 1284. Minimum Number of Flips to Convert Binary Matrix to Zero Matrix
# 124. Binary Tree Maximum Path Sum
# 718. Maximum Length of Repeated Subarray
# 632. Smallest Range Covering Elements from K Lists
# 224. Basic Calculator
# 227. Basic Calculator II
# 772. Basic Calculator III
# 1597. Build Binary Expression Tree From Infix Expression
# 1612. Check If Two Expression Trees are Equivalent
# 1628. Design an Expression Tree With Evaluate Function
# 394. Decode String
# 443. String Compression
# 636. Exclusive Time of Functions
# 1400. Construct K Palindrome Strings
# 290. Word Pattern
# 291. Word Pattern II
# 41. First Missing Positive
# 442. Find All Duplicates in an Array
# 451. Sort Characters By Frequency
# 1152. Analyze User Website Visit Pattern
# 848. Shifting Letters
# 348. Design Tic-Tac-Toe
# 1275. Find Winner on a Tic Tac Toe Game
# 1062. Longest Repeating Substring
# 1044. Longest Duplicate Substring
# 703. Kth Largest Element in a Stream
# 295. Find Median from Data Stream
# 480. Sliding Window Median
# 1047. Remove All Adjacent Duplicates In String
# 1209. Remove All Adjacent Duplicates in String II
# 14. Longest Common Prefix
# 17. Letter Combinations of a Phone Number

# 5. Longest Palindromic Substring
# 1312. Minimum Insertion Steps to Make a String Palindrome
# 2193. Minimum Number of Moves to Make Palindrome
# 1864. Minimum Number of Swaps to Make the Binary String Alternating

# 498. Diagonal Traverse
# 1424. Diagonal Traverse II
# 1329. Sort the Matrix Diagonally
# 274. H-Index
# 468. Validate IP Address
# 93. Restore IP Addresses

# 2055. Plates Between Candles
# 1291. Sequential Digits
# 135. Candy
# 1438. Longest Continuous Subarray With Absolute Diff Less Than or Equal to Limit

##################################################################################################################################################################
import sys
import heapq
import math
import random
from typing import List, Optional, Callable
from collections import Counter, deque, defaultdict, OrderedDict
from itertools import accumulate, combinations, permutations, product

from bisect import bisect, bisect_left, bisect_right, insort

"""
README:
Perhaps most of the people here are practicing coding skills to land a job. It is fairly important to talk about your process of thought to the interviewer. 
You can't just jump in and give the best and most optimal solution though, because that seems like you have already seen the problems and memorized it thoroughly. 
Best approach is to give a brute force solution first, if interviewer asks for further optimization, then only you talk about using deque and other better solution.

Always start with brute-force method has a good advantage. Most of the time, in a 45 mins technical interview, the interviewer only prepares 1 - 2 coding questions 
and if you finish too early, they will probably start asking about other trivia questions or knowledge-based questions, which will put you in a disadvantageous position 
if you are a person who is not very good at talking. So starting with brute force (even though the question is listed as hard problem, but it isn't that hard to solve), 
then get to optimal part, and bam! You nail a 45 mins technical interview with flying colors!
"""

############################################ monotonic stack ######################################################

# 84. Largest Rectangle in Histogram
"""
Given an array of integers heights representing the histogram's bar height where the width of each bar is 1, return the area of the largest rectangle in the histogram.
Input: heights = [2,1,5,6,2,3]
Output: 10
"""
class Solution:
    # Approach 1:   Brute Force     TLE    O(n ** 2)
    def largestRectangleArea(self, heights: List[int]) -> int:
        max_area = 0
        for i in range(len(heights)):
            min_height = float('inf')
            for j in range(i, len(heights)):
                min_height = min(min_height, heights[j])
                max_area = max(max_area, min_height * (j - i + 1))
        return max_area
    
    
    # Approach 2:   Monotonic Stack     O(n) / O(n)
    def largestRectangleArea(self, heights: List[int]) -> int:
        stack, res = [], 0
        for i, h in enumerate(heights + [0]):
            while stack and heights[stack[-1]] >= h:        # 单调递增栈
                H = heights[stack.pop()]
                W = i if not stack else i - stack[-1] - 1
                res = max(res, H * W)
            stack.append(i)
        return res





# 239. Sliding Window Maximum
"""
You are given an array of integers nums, there is a sliding window of size k which is moving from the very left of the array to the very right. 
You can only see the k numbers in the window. Each time the sliding window moves right by one position. Return the max sliding window.
Input: nums = [1,3,-1,-3,5,3,6,7], k = 3
Output: [3,3,5,5,6,7]
Explanation: 
Window position                Max
---------------               -----
[1  3  -1] -3  5  3  6  7       3
 1 [3  -1  -3] 5  3  6  7       3
 1  3 [-1  -3  5] 3  6  7       5
 1  3  -1 [-3  5  3] 6  7       5
 1  3  -1  -3 [5  3  6] 7       6
 1  3  -1  -3  5 [3  6  7]      7
"""
# Deque队列是由栈或者queue队列生成的 (发音是 “deck”, ”double-ended queue”的简称)。Deque 支持线程安全，内存高效添加(append)和弹出(pop)，从两端都可以，两个方向的大概开销都是 O(1) 复杂度。
# append(x) - 添加 x 到右端。  popleft() - 移去并且返回一个元素, deque 最左侧的那一个。 如果没有元素的话，就引发 IndexError。
# Monoqueue (Monotonic Queue, 简称 MQ, 是单调栈的一种) has three basic options:
#     push: push an element into the queue; O (1) (amortized)
#     pop: pop an element out of the queue; O(1) (pop = remove, it can't report this element)
#     max: report the max element in queue; O(1)
# It takes only O(n) time to process a N-size sliding window minimum/maximum problem.
# Note: different from a priority queue (which takes O(nlogk) to solve this problem), it doesn't pop the max element: It pops the first element (in original order) in queue.

# The idea is to use deque to hold the index of maximum element and restrict deque size to k, since the pops from / pushes to either side with the same O(1) performance.
# You want to ensure the deque window only has decreasing elements. That way, the leftmost element is always the largest.
# Also, it's more handy to store in the deque indexes instead of elements since both are used during an array parsing.

class Solution:
    # Approach 1:       双端队列Deque       O(n) / O(k)
    def maxSlidingWindow(self, nums: List[int], k: int) -> List[int]:
        deq, n, ans = deque([0]), len(nums), []

        for i in range (n):
            while deq and deq[0] <= i - k:
                deq.popleft()   # remove indexes of elements not from sliding window
            while deq and nums[i] >= nums[deq[-1]]:
                deq.pop()       # remove all indexes smaller than current element nums[i]
            deq.append(i)
            ans.append(nums[deq[0]])
            
        return ans[k-1:]





# 316. Remove Duplicate Letters
"""
Given a string s, remove duplicate letters so that every letter appears once and only once. You must make sure your result is the smallest 
in lexicographical order among all possible results.
Input: s = "bcabc"
Output: "abc"
"""
class Solution:
    # Approach 1: Greedy - Solving Letter by Letter     O(N) / O(N)
    def removeDuplicateLetters(self, s: str) -> str:
        c = Counter(s)
        pos = 0
        for i in range(len(s)):
            if s[i] < s[pos]: pos = i
            c[s[i]] -=1
            if c[s[i]] == 0: break
        
        return s[pos] + self.removeDuplicateLetters(s[pos:].replace(s[pos], "")) if s else ''
    
    
    # Approach 2: Greedy - Solving with Stack           O(N) / O(1)
    def removeDuplicateLetters(self, s: str) -> str:
        stack = []
        seen = set()
        last_occurrence = {c: i for i, c in enumerate(s)}

        for i, c in enumerate(s):
            if c not in seen:
                while stack and c < stack[-1] and i < last_occurrence[stack[-1]]:
                    seen.discard(stack.pop())
                seen.add(c)
                stack.append(c)
                
        return ''.join(stack)





# 402. Remove K Digits
"""
Given string num representing a non-negative integer num, and an integer k, return the smallest possible integer after removing k digits from num.
Input: num = "1432219", k = 3           Output: "1219"
Input: num = "10200", k = 1             Output: "200"
Input: num = "10", k = 2                Output: "0"
"""
class Solution:
    # 需要注意比较大小的时候其实是字符串在比大小
    def removeKdigits(self, num: str, k: int) -> str:
        stack = []
        for digit in num:
            while k and stack and stack[-1] > digit:
                stack.pop()
                k -= 1
            stack.append(digit)
            
        final_stack = stack[: -k] if k else stack
        return "".join(final_stack).lstrip('0') or '0'

    for _ in range(10): pass         # 为了好看





# 321. Create Maximum Number
"""
You are given two integer arrays nums1 and nums2 of lengths m and n respectively. nums1 and nums2 represent the digits of two numbers. You are also given an integer k.
Create the maximum number of length k <= m + n from digits of the two numbers. The relative order of the digits from the same array must be preserved.
Return an array of the k digits representing the answer.
Input: nums1 = [3,4,6,5], nums2 = [9,1,2,5,8,3], k = 5
Output: [9,8,6,5,3]
"""
class Solution:
    def maxNumber(self, nums1: List[int], nums2: List[int], k: int) -> List[int]:
        
        def prep(nums, k):
            drop = len(nums) - k
            stack = []
            for num in nums:
                while drop and stack and stack[-1] < num:
                    stack.pop()
                    drop -= 1
                stack.append(num)
            return stack[:k]
        
        def merge(a, b):
            return [max(a, b).pop(0) for _ in a + b]        # run k times of selecting the largest num by poping it out in lexi order
        
        return max(merge(prep(nums1, i), prep(nums2, k - i)) for i in range(k + 1) if i <= len(nums1) and k - i <= len(nums2))





# 456. 132 Pattern
"""
Given an array of n integers nums, a 132 pattern is a subsequence of three integers nums[i], nums[j] and nums[k] such that i < j < k and nums[i] < nums[k] < nums[j].
Return true if there is a 132 pattern in nums, otherwise, return false.
Input: nums = [-1,3,2,0]
Output: true        [-1, 3, 2], [-1, 3, 0] and [-1, 2, 0].
"""
class Solution:
    # Approach 1:       brute force     会超时
    # 枚举 132 中的 3，只需要从左到右枚举3的下标，由于1是最小值，需要维护一个left_min，而2是次小值，需要维护一个i+1到末尾的有序数组
    def find132pattern(self, nums: List[int]) -> bool:
        n = len(nums)
        if n < 3:
            return False
        
        left_min = nums[0]
        right_part = sorted(nums[2:])

        for i in range(1, n - 1):
            if left_min < nums[i]:
                index = bisect_right(right_part, left_min)      # 这里使用bisect_right是因为要找到比 left_min 的值大的数的 index
                if index < len(right_part) and right_part[index] < nums[i]:
                    return True
            left_min = min(left_min, nums[i])   # 维护一个left_min数组
            right_part.remove(nums[i + 1])      # 维护一个有序数组
            
        return False


    # Approach 2:       单调栈      枚举1，单调栈用来维护所有可以作为 2 的候选元素，栈的头元素始终代表 3
    # pop出去的都是可以作为 2 的候选，且只需要 1 小于 2 候选的最大值即可，pop的同时更新 max_k，因为只要 在 2 候选中存在其中一个 max_k 比 1 大就返回True了
    def find132pattern(self, nums: List[int]) -> bool:
        n = len(nums)
        mono_stack = [nums[n-1]]
        max_k = float('-inf')
        
        for i in range(n - 2, -1, -1):
            if nums[i] < max_k:
                return True
            while mono_stack and nums[i] > mono_stack[-1]:
                max_k = mono_stack.pop()
            if nums[i] > max_k:
                mono_stack.append(nums[i])
        return False

    # Approach 3:   枚举 2 ，难度较大，需要在单调栈上进行二分法，时间复杂度 O(nlogn)，在以上三种方法中（2-4),只有方法二的时间复杂度为 O(n)，
    # 另外两种时间复杂度均为 O(nlogn) 的方法中，一比三好理解很多（所以这里没有写方法三的答案，主要参考的是一种思想），因为可以发现方法一和二的不足：
    #   方法一需要提前知道整个数组，否则无法使用有序集合维护右边的元素
    #   方法二是从后向前遍历，本质上也同样需要提前知道整个数组
    # 而方法三是从前向后遍历的，并且维护的数据结构不依赖于后续位置的元素，因此如果数组是以【数据流】的形式给出的，那么方法三是唯一可以使用的





# 496. Next Greater Element I
"""
Input: nums1 = [4,1,2], nums2 = [1,3,4,2]
Output: [-1,3,-1]
Explanation: The next greater element for each value of nums1 is as follows:
- 4 is underlined in nums2 = [1,3,4,2]. There is no next greater element, so the answer is -1.
- 1 is underlined in nums2 = [1,3,4,2]. The next greater element is 3.
- 2 is underlined in nums2 = [1,3,4,2]. There is no next greater element, so the answer is -1.
"""
class Solution:
    
    # Approach 1: Using Stack, from left to right
    def nextGreaterElement(self, nums1: List[int], nums2: List[int]) -> List[int]:
        stack = []
        next_number = defaultdict(lambda: -1)
        
        for num in nums2:
            while stack and num > stack[-1]:
                next_number[stack.pop()] = num
            stack.append(num)
            
        return map(lambda x: next_number[x], nums1)
            
            
    # Approach 2: Using Stack, from right to left
    def nextGreaterElement(self, nums1: List[int], nums2: List[int]) -> List[int]:
        res=[]
        stack=[]
        
        for val in reversed(nums2):
            while stack and val >= stack[-1]:
                stack.pop()
            if not stack:
                res.append(-1)
            else:
                res.append(stack[-1])
            stack.append(val)
        
        res.reverse()
        ans=[]
        
        for val in nums1:
            idx = nums2.index(val)
            ans.append(res[idx])
            
        return ans





# 503. Next Greater Element II
"""
Given a circular integer array nums (i.e., the next element of nums[nums.length - 1] is nums[0]), return the next greater number for every element in nums.
Input: nums = [1,2,1]
Output: [2,-1,2]
Explanation: The first 1's next greater number is 2; 
The number 2 can't find next greater number. 
The second 1's next greater number needs to search circularly, which is also 2.
"""
class Solution:
    # Approach 1. Double the List
    def nextGreaterElements(self, nums: List[int]) -> List[int]:
        dct = {}
        stack = []
        
        arr = nums * 2

        for i, v in enumerate(arr):
            while stack and stack[-1][1] < v:
                idx, _ = stack.pop()
                dct[idx] = v
            stack.append((i, v))
            
        return [dct.get(i, -1) for i in range(len(nums))]
    
    
    # Approach 2. No need to Double the List
    def nextGreaterElements(self, nums: List[int]) -> List[int]:
        dct = {}
        stack = []
        
        for j in range(len(nums) * 2):
            i = j % len(nums)
            v = nums[i]
            
            while stack and stack[-1][1] < v:
                idx, _ = stack.pop()
                dct[idx] = v
            stack.append((i, v))
            
        return [dct.get(i, -1) for i in range(len(nums))]





# 556. Next Greater Element III
"""
Given a positive integer n, find the smallest integer which has exactly the same digits existing in the integer n and is greater in value than n. 
If no such positive integer exists, return -1.  1 <= n <= 2 ** 31 - 1
Note that the returned integer should fit in 32-bit integer, if there is a valid answer but it does not fit in 32-bit integer, return -1.
Input: n = 12
Output: 21
"""
class Solution:
    # same as next permutation
    def nextGreaterElement(self, n: int) -> int:
        num = [char for char in str(n)]

        i = len(num) - 2
        
        while i >= 0 and num[i + 1] <= num[i]:
            i -= 1
            
        if i < 0:
            return -1
        
        j = len(num) - 1
        while j >= 0 and num[j] <= num[i]:
            j -= 1
            
        num[i], num[j] = num[j], num[i]
        num[i+1:] = num[i+1:][::-1]
        int_n = int("".join(num))
        return int_n if int_n < 2 ** 31 else -1

    for _ in range(10): pass         # 为了好看





# 739. Daily Temperatures
"""
Given an array of integers temperatures represents the daily temperatures, return an array answer such that answer[i] is the number of days 
you have to wait after the ith day to get a warmer temperature. If there is no future day for which this is possible, keep answer[i] == 0 instead.
Input: temperatures = [73,74,75,71,69,72,76,73]
Output: [1,1,4,2,1,1,0,0]
"""
class Solution:
    def dailyTemperatures(self, temperatures: List[int]) -> List[int]:
        ans = [0] * len(temperatures)
        stack = []
        
        for curr_day, curr_temp in enumerate(temperatures):
            while stack and curr_temp > temperatures[stack[-1]]:
                prev_day = stack.pop()
                ans[prev_day] = curr_day - prev_day
            stack.append(curr_day)
            
        return ans





# 856. Score of Parentheses
"""
Given a balanced parentheses string s, return the score of the string. The score of a balanced parentheses string is based on the following rule:
    1. "()" has score 1.
    2. AB has score A + B, where A and B are balanced parentheses strings.
    3. (A) has score 2 * A, where A is a balanced parentheses string.
Input: s = "(()(()))"
Output: 6       2 * (1 + 2 * 1)         "(()(()))" == "(()) + ((()))" == 2 * 1 + 2 * 2 * 1      这道题的关键就是找出有几个（）以及深度，深一层就多一个 x2
"""
class Solution:
    # Approach 1: Divide and Conquer    Split the string into S = A + B where A and B are balanced parentheses strings, 
    # and A is the smallest possible non-empty prefix of S.      O(N**2) / O(N)
    def scoreOfParentheses(self, s: str) -> int:
        def split_into_primitive(i, j):
            ans = balanced = 0
            for k in range(i, j):       #Split string into primitives
                balanced += 1 if s[k] == '(' else -1
                if balanced == 0:
                    if k - i == 1:      # if string length is 2, then the score of this string is 1
                        ans += 1
                    else:               # Otherwise, double the score of substring (S[i+1], S[i+2], ..., S[k-1])
                        ans += 2 * split_into_primitive(i + 1, k)
                    i = k + 1
            return ans
        
        return split_into_primitive(0, len(s))
        
    
    # Approach 2: Stack     maintain the score at the current depth         O(N) / O(N)
    def scoreOfParentheses(self, s: str) -> int:
        stack = [0]
        for x in s:
            if x == '(':
                stack.append(0)     # increase depth and set score at new depth to 0
            else:
                v = stack.pop()
                stack[-1] += max(2 * v, 1)  # add twice the score of the previous deeper part - except (), which has a score of 1
        return stack.pop()

    for _ in range(10): pass         # 为了好看


    # Approach 3: Count Cores       core is a substring (), with score 1, the "cores" () are the only structure that provides value, the outer parentheses 
    # just add some multiplier to the cores. E.g. For the example of (()(())), with the stack method, we are calculating the inner structure ()(()) first 
    # and then multiply the score by 2. With the 3rd method, by knowing the depth of the core, we are actually performing this calculation (()) + ((())).   O(N) / O(1)
    def scoreOfParentheses(self, s: str) -> int:
        ans = depth = 0
        for i, v in enumerate(s):
            if v == '(':
                depth += 1
            else:
                depth -= 1
                if s[i - 1] == '(':
                    ans += 1 << depth
        return ans





# 862. Shortest Subarray with Sum at Least K
"""
Given an integer array nums and an integer k, return the length of the shortest non-empty subarray of nums with a sum of at least k. If there is no such subarray, return -1.
Input: nums = [3, -2, 5], k = 4
Output: 1
"""
class Solution:
    # There will be problem of using sliding window from 209's solution because the negative values
    # The Deque solution is a modification of the Sliding window solution. We will modify the way we are updating 'start'.
    # The deque stores the possible values of the start pointer. Unlike the sliding window, values of the start variable will not necessarily be contiguous.
    #   - Why do we have a prefix array and not just the initial array like in sliding window ???
    # Because in the sliding window when we move start (typically when we increment it) we can just substract nums[start-1] from the current sum and we get the sum of 
    # the new subarray. Here the value of the start is jumping and one way to compute the sum of the current subarray in a constant time is to have the prefix array.
    #   - Why using Deque and not simply an array :
    # We can use an array, however we will find ourselves doing only three operations:
    # 1- remove_front : when we satisfy our condition and we want to move the start pointer
    # 2- append_back : for any index that may be a future start pointer
    # 3- remove_back : When we are no longer satisfying the increasing order of the array
    # Deque enables doing these 3 operations in a constant time.
    def shortestSubarray(self, A: List[int], K: int) -> int:
        n = len(A)
        prefix_sum = [0] * (n + 1)  # 这里需要第一个为占位符0，否则在后面的计算中会出错，采用list的形式也是为了之后方便index操作
        
        for i in range(1, n + 1):
            prefix_sum[i] = prefix_sum[i - 1] + A[i - 1]    # 前缀和主要用于处理数组区间的问题
        
        deque = deque([])
        res = float("inf")

        for i in range(n + 1):
            while deque and prefix_sum[i] - prefix_sum[deque[0]] >= K:
                res = min(res, i - deque[0])
                deque.popleft() # 相当于模拟滑动窗口中 left 往回收缩的过程
            while deque and prefix_sum[i] <= prefix_sum[deque[-1]]:
                deque.pop()     # 其实是在把负数项剔除掉，如何判断是负数，前缀和，如果发现前缀和数组的第 i 项比 i-1 项的值小，那么就是加了负数，需要踢掉
            deque.append(i)
            
        return res if res != float("inf") else -1


    # Approach 2        Heap
    def shortestSubarray(self, A: List[int], K: int) -> int:
        n = len(A)
        res = float("inf")
        prefix_sum = 0
        heap = []
        for i in range(n):
            prefix_sum += A[i]
            if prefix_sum >= K:
                res = min(res, i+1)
                
            while heap and prefix_sum - heap[0][0] >= K:
                res = min(res, i-heap[0][1])
                heapq.heappop(heap)
            heapq.heappush(heap, (prefix_sum, i))
            
        return res if res != float("inf") else -1





# 901. Online Stock Span
"""
Design an algorithm that collects daily price quotes for some stock and returns the span of that stock's price for the current day.
The span of the stock's price today is defined as the maximum number of consecutive days (starting from today and going backward) for which the stock price 
was less than or equal to today's price. For example, if the price of a stock over the next 7 days were [100,80,60,70,60,75,85], then the stock spans would be [1,1,1,2,1,4,6].
"""
class StockSpanner:     # 和 739 基本一样
    def __init__(self):
        self.stack = []

    def next(self, price: int) -> int:
        res = 1
        while self.stack and self.stack[-1][0] <= price:
            res += self.stack.pop()[1]
        self.stack.append([price, res])
        return res

    for _ in range(10): pass         # 为了好看
# Your StockSpanner object will be instantiated and called as such:
# obj = StockSpanner()
# param_1 = obj.next(price)





# 907. Sum of Subarray Minimums
"""
Given an array of integers arr, find the sum of min(b), where b ranges over every (contiguous) subarray of arr. Since the answer may be large, return the answer modulo 109 + 7.
Input: arr = [3,1,2,4]
Output: 17
Explanation: 
Subarrays are [3], [1], [2], [4], [3,1], [1,2], [2,4], [3,1,2], [1,2,4], [3,1,2,4]. 
Minimums are 3, 1, 2, 4, 1, 1, 2, 1, 1, 1.
Sum is 17.
"""
class Solution:
    # 注意这里是subarray，不是排列组合，有顺序的要求    monotonic queue
    # 根据 value 大小找到相邻的 index 的问题，直接就上 stack ！！！
    # 规律总结：Any DP problem where A[i] = min(A[j:k]) + C where j < k <= i
    def sumSubarrayMins(self, arr: List[int]) -> int:
        MOD = 10 ** 9 + 7
        result = 0
        
        arr = [float('-inf')] + arr + [float('-inf')]
        stack = []
        for i, num in enumerate(arr):    # [-inf, 3,1,2,4, -inf]
            while stack and num < arr[stack[-1]]:
                idx = stack.pop()
                left = idx - stack[-1]
                right = i - idx
                result += left * right * arr[idx]
            stack.append(i)
            
        return result % MOD


    # Approach 2.   中文版标准答案
    def sumSubarrayMins(self, A):
        MOD = 10**9 + 7
        N = len(A)

        # prev has i* - 1 in increasing order of A[i* - 1]
        # where i* is the answer to query j
        stack = []
        prev = [None] * N
        for i in range(N):
            while stack and A[i] <= A[stack[-1]]:
                stack.pop()
            prev[i] = stack[-1] if stack else -1
            stack.append(i)

        # next has k* + 1 in increasing order of A[k* + 1]
        # where k* is the answer to query j
        stack = []
        next_ = [None] * N
        for k in range(N-1, -1, -1):
            while stack and A[k] < A[stack[-1]]:
                stack.pop()
            next_[k] = stack[-1] if stack else N
            stack.append(k)

        # Use prev/next array to count answer
        return sum((i - prev[i]) * (next_[i] - i) * A[i] for i in range(N)) % MOD





# 2104. Sum of Subarray Ranges
"""
You are given an integer array nums. The range of a subarray of nums is the difference between the largest and smallest element in the subarray.
Return the sum of all subarray ranges of nums.
A subarray is a contiguous non-empty sequence of elements within an array.
Input: nums = [1,2,3]
Output: 4
Explanation: The 6 subarrays of nums are the following:
[1], range = largest - smallest = 1 - 1 = 0 
[2], range = 2 - 2 = 0
[3], range = 3 - 3 = 0
[1,2], range = 2 - 1 = 1
[2,3], range = 3 - 2 = 1
[1,2,3], range = 3 - 1 = 2
So the sum of all ranges is 0 + 0 + 0 + 1 + 1 + 2 = 4.
"""
class Solution:
    # Approach 1.   Monotomic Stack
    def subArrayRanges(self, nums: List[int]) -> int:
        n = len(nums)
        minLeft, maxLeft = [0] * n, [0] * n
        minStack, maxStack = [], []
        for i, num in enumerate(nums):
            while minStack and nums[minStack[-1]] > num:
                minStack.pop()
            minLeft[i] = minStack[-1] if minStack else -1
            minStack.append(i)

            # 如果 nums[maxStack[-1]] == num, 那么根据定义，nums[maxStack[-1]] 逻辑上小于 num，因为 maxStack[-1] < i
            while maxStack and nums[maxStack[-1]] <= num:
                maxStack.pop()
            maxLeft[i] = maxStack[-1] if maxStack else -1
            maxStack.append(i)

        minRight, maxRight = [0] * n, [0] * n
        minStack, maxStack = [], []
        for i in range(n - 1, -1, -1):
            num = nums[i]

            # 如果 nums[minStack[-1]] == num, 那么根据定义，nums[minStack[-1]] 逻辑上大于 num，因为 minStack[-1] > i
            while minStack and nums[minStack[-1]] >= num:
                minStack.pop()
            minRight[i] = minStack[-1] if minStack else n
            minStack.append(i)

            while maxStack and nums[maxStack[-1]] < num:
                maxStack.pop()
            maxRight[i] = maxStack[-1] if maxStack else n
            maxStack.append(i)

        sumMax, sumMin = 0, 0
        for i, num in enumerate(nums):
            sumMax += (maxRight[i] - i) * (i - maxLeft[i]) * num
            sumMin += (minRight[i] - i) * (i - minLeft[i]) * num
        return sumMax - sumMin
    
    
    # Approach 2.   Iterative
    def subArrayRanges(self, nums: List[int]) -> int:
        if not nums or len(nums) == 0:
            return 0
        
        n = len(nums)
        total = 0
        for i in range(n):
            minVal, maxVal = sys.inf, -sys.inf
            for j in range(i, n):
                minVal = min(minVal, nums[j])
                maxVal = max(maxVal, nums[j])
                total += maxVal - minVal
                
        return total





# 2281. Sum of Total Strength of Wizards
"""
You are given a 0-indexed integer array strength, where strength[i] denotes the strength of the ith wizard. For a contiguous group of wizards 
(i.e. the wizards' strengths form a subarray of strength), the total strength is defined as the product of the following two values:
    - The strength of the weakest wizard in the group.
    - The total of all the individual strengths of the wizards in the group.
Return the sum of the total strengths of all contiguous groups of wizards. Since the answer may be very large, return it modulo 109 + 7.
A subarray is a contiguous non-empty sequence of elements within an array.

Input: strength = [5,4,6]
Output: 213
Explanation: The following are all the contiguous groups of wizards: 
- [5] from [5,4,6] has a total strength of min([5]) * sum([5]) = 5 * 5 = 25
- [4] from [5,4,6] has a total strength of min([4]) * sum([4]) = 4 * 4 = 16
- [6] from [5,4,6] has a total strength of min([6]) * sum([6]) = 6 * 6 = 36
- [5,4] from [5,4,6] has a total strength of min([5,4]) * sum([5,4]) = 4 * 9 = 36
- [4,6] from [5,4,6] has a total strength of min([4,6]) * sum([4,6]) = 4 * 10 = 40
- [5,4,6] from [5,4,6] has a total strength of min([5,4,6]) * sum([5,4,6]) = 4 * 15 = 60
The sum of all the total strengths is 25 + 16 + 36 + 36 + 40 + 60 = 213.
"""
# Key words:    1. Subarray + sum -> prefix sum     2. Subarray + minimum -> mono stack
class Solution:
    def totalStrength(self, strength: List[int]) -> int:
        mod = 10 ** 9 + 7
        n = len(strength)
        
        # next small to the right
        len_to_right = [n] * n
        mono_stack = []
        for i in range(n):
            while mono_stack and strength[mono_stack[-1]] > strength[i]:
                len_to_right[mono_stack.pop()] = i
            mono_stack.append(i)
        
        # next small to the left
        len_to_left = [-1] * n
        mono_stack = []
        for i in range(n - 1, -1, -1):
            while mono_stack and strength[mono_stack[-1]] >= strength[i]:
                len_to_left[mono_stack.pop()] = i
            mono_stack.append(i)
            
        # for each strength[i] as the minimum, calculate the prefixSum of the prefixSum
        res = 0
        prefix_sum_twice = list(accumulate(accumulate(strength), initial = 0))
        for i in range(n):
            l, r = len_to_left[i], len_to_right[i]
            l_sum = prefix_sum_twice[i] - prefix_sum_twice[max(l, 0)]
            r_sum = prefix_sum_twice[r] - prefix_sum_twice[i]
            l_len, r_len = i - l, r - i
            res += strength[i] * (r_sum * l_len - l_sum * r_len)
        
        return res % mod





# 828. Count Unique Characters of All Substrings of a Given String
"""
Let's define a function countUniqueChars(s) that returns the number of unique characters on s.
For example, calling countUniqueChars(s) if s = "LEETCODE" then "L", "T", "C", "O", "D" are the unique characters since they appear only once in s, therefore countUniqueChars(s) = 5.
Given a string s, return the sum of countUniqueChars(t) where t is a substring of s. The test cases are generated such that the answer fits in a 32-bit integer.
Notice that some substrings can be repeated so in this case you have to count the repeated ones too.
Input: s = "ABC"
Output: 10
Explanation: All possible substrings are: "A","B","C","AB","BC" and "ABC".
Every substring is composed with only unique letters. Sum of lengths of all substring is 1 + 1 + 1 + 2 + 2 + 3 = 10
"""
class Solution:
    # 枚举当前点的左右边界问题
    def uniqueLetterString(self, s: str) -> int:
        if not s or len(s) == 0:
            return 0

        char_dict = defaultdict(list)
        for index, char in enumerate(s):
            char_dict[char].append(index)
            
        result = 0
        for c in char_dict:
            index_list = char_dict[c]
            for i in range(len(index_list)):
                l = index_list[i] - (index_list[i-1] if i-1 >= 0 else -1)
                r = (index_list[i+1] if i + 1 < len(index_list) else len(s)) - index_list[i]
                result += l * r
        
        return result





# 2262. Total Appeal of A String
"""
The appeal of a string is the number of distinct characters found in the string.
For example, the appeal of "abbca" is 3 because it has 3 distinct characters: 'a', 'b', and 'c'.
Given a string s, return the total appeal of all of its substrings. A substring is a contiguous sequence of characters within a string.
Input: s = "abbca"
Output: 28
Explanation: The following are the substrings of "abbca":
- Substrings of length 1: "a", "b", "b", "c", "a" have an appeal of 1, 1, 1, 1, and 1 respectively. The sum is 5.
- Substrings of length 2: "ab", "bb", "bc", "ca" have an appeal of 2, 1, 2, and 2 respectively. The sum is 7.
- Substrings of length 3: "abb", "bbc", "bca" have an appeal of 2, 2, and 3 respectively. The sum is 7.
- Substrings of length 4: "abbc", "bbca" have an appeal of 3 and 3 respectively. The sum is 6.
- Substrings of length 5: "abbca" has an appeal of 3. The sum is 3.
The total sum is 5 + 7 + 7 + 6 + 3 = 28.
"""
class Solution:
    # Approach 1:   统计每一个字符对总结果的贡献度，对每一个字符，贡献度 = 可能的起点 * 可能的终点
    def appealSum(self, s: str) -> int:
        start_pos = defaultdict(lambda: -1)
        result = 0
        for index, char in enumerate(s):
            result += (index - start_pos[char]) * (len(s) - index)
            start_pos[char] = index
        return result


    # Approach 2: assume we have string xxxaxxxxb..., with s[i] = a and s[j] = b. s[i] is th last character a before that b.
    # We want to count, how many substring ending at s[j] contains character a. They are xxxaxxxxb, xxaxxxxb, xaxxxxb, axxxxb ....,
    # i + 1 substring ending with character a at s[i], so we do res += i + 1.
    def appealSum(self, s: str) -> int:
        last = {}
        res = 0
        for i, c in enumerate(s):
            last[c] = i + 1
            res += sum(last.values())
        return res


    # Approach 3    如果 map 里存在当前字符，则加上（减去上一次出现位置的 index），如果不存在则正常加
    def appealSum(self, s: str) -> int:
        lastSeenMap = {s[0]: 0}
        prev, curr, res = 1, 0, 1
        
        for i in range(1, len(s)):
            if s[i] in lastSeenMap:
                curr = prev + (i - lastSeenMap[s[i]])
            else:
                curr = prev + (i + 1)
            res += curr
            prev = curr
            lastSeenMap[s[i]] = i
        return res





# 1762. Buildings With an Ocean View
"""
There are n buildings in a line. You are given an integer array heights of size n that represents the heights of the buildings in the line.
The ocean is to the right of the buildings. A building has an ocean view if the building can see the ocean without obstructions. Formally, a building has an ocean view 
if all the buildings to its right have a smaller height. Return a list of indices (0-indexed) of buildings that have an ocean view, sorted in increasing order.
Input: heights = [4,2,3,1]
Output: [0,2,3]
Explanation: Building 1 (0-indexed) does not have an ocean view because building 2 is taller.
"""
class Solution:
    # Approach 1: Linear Iteration
    def findBuildings(self, heights: List[int]) -> List[int]:
        if not heights or len(heights) == 0:
            return []
        
        results = []
        results.append(len(heights) - 1)
        
        tallest = heights[-1]
        for i in range(len(heights) - 2, -1, -1):
            if heights[i] > tallest:
                results.append(i)
                tallest = max(tallest, heights[i])
        return reversed(results)
    
    
    # Approach 2: Monotonic Stack
    def findBuildings(self, heights: List[int]) -> List[int]:
        if not heights or len(heights) == 0:
            return []
        
        results = []
        monotonic_stack = []
        for curr in range(len(heights) - 1, -1, -1):
            while monotonic_stack and heights[monotonic_stack[-1]] < heights[curr]:
                monotonic_stack.pop()
            if not monotonic_stack:     # 这里做判断
                results.append(curr)
            monotonic_stack.append(curr)
        return reversed(results)





# 1944. Number of Visible People in a Queue
"""
Input: heights = [10,6,8,5,11,9]
Output: [3,1,2,1,1,0]
Person 0 can see person 1, 2, and 4.    Person 1 can see person 2.  Person 2 can see person 3 and 4.
Person 3 can see person 4.  Person 4 can see person 5.  Person 5 can see no one since nobody is to the right of them.
"""
class Solution:     # 单调递减栈
    def canSeePersonsCount(self, heights: List[int]) -> List[int]:
        results = [0] * len(heights)
        mono_stack = []
        for i, v in enumerate(heights):
            while mono_stack and heights[mono_stack[-1]] <= v:
                results[mono_stack.pop()] += 1  # 意味着 pop 出来的遇到了一个更高的，再往后就看不到其他人了，就截止了
            if mono_stack:
                results[mono_stack[-1]] += 1    # 只要比自己矮的都能看到，就一直加
            mono_stack.append(i)
        return results





# 1130. Minimum Cost Tree From Leaf Values
"""
Given an array arr of positive integers, consider all binary trees such that:
    1. Each node has either 0 or 2 children
    2. The values of arr correspond to the values of each leaf in an in-order traversal of the tree.
    3. The value of each non-leaf node is equal to the product of the largest leaf value in its left and right subtree, respectively.
Among all possible binary trees considered, return the smallest possible sum of the values of each non-leaf node.
Input: arr = [6,2,4]
Output: 32
"""
class Solution:
    # find the next greater element in the array, on the left and one right. Refer to the problem 503. Next Greater Element II
    def mctFromLeafValues(self, arr: List[int]) -> int:
        res = 0
        stack = [float('inf')]
        for a in arr:
            while stack and stack[-1] <= a:
                res += stack.pop() * min(stack[-1], a)
            stack.append(a)
        while len(stack) > 2:
            res += stack.pop() * stack[-1]
        return res

    for _ in range(10): pass         # 为了好看





# 1475. Final Prices With a Special Discount in a Shop
"""
Given the array prices where prices[i] is the price of the ith item in a shop. There is a special discount for items in the shop, if you buy the ith item, 
then you will receive a discount equivalent to prices[j] where j is the minimum index such that j > i and prices[j] <= prices[i], otherwise, you will not receive any discount at all.
Return an array where the ith element is the final price you will pay for the ith item of the shop considering the special discount.
Input: prices = [8,4,6,2,3]
Output: [4,2,4,2,3]
"""
class Solution:
    def finalPrices(self, prices: List[int]) -> List[int]:
        if not prices or len(prices) == 0:
            return []
        
        stack = []
        for i, v in enumerate(prices):
            while stack and prices[stack[-1]] >= v:
                prices[stack.pop()] -= v
            stack.append(i)
        return prices





# 560. Subarray Sum Equals K
"""
Given an array of integers nums and an integer k, return the total number of subarrays whose sum equals to k.
Input: nums = [1,1,1], k = 2
Output: 2
"""
class Solution:         #   (Prefix_sum + Hashmap)      O(N) / O(N)
    def subarraySum(self, nums: List[int], k: int) -> int:
        count, prefix_sum = 0, 0
        d = {}
        d[0] = 1        # 占位符,第一个数之前的sum是0
        
        for i in range(len(nums)):
            prefix_sum += nums[i]
            if (prefix_sum - k) in d:
                count += d[prefix_sum - k]
            d[prefix_sum] = d.get(prefix_sum, 0) + 1
        return count





# 523. Continuous Subarray Sum
"""
Given an integer array nums and an integer k, return true if nums has a continuous subarray of size at least two whose elements sum up to a multiple of k, or false otherwise.
An integer x is a multiple of k if there exists an integer n such that x = n * k. 0 is always a multiple of k.
Input: nums = [23,2,4,6,7], k = 6
Output: true
"""
class Solution:
    # 解法：if sum(nums[i:j]) % k == 0 for some i < j, then sum(nums[:j]) % k == sum(nums[:i]) % k
    def checkSubarraySum(self, nums: List[int], k: int) -> bool:
        d = {0: -1}
        total = 0
        for i, n in enumerate(nums):
            if k != 0:
                total = (total + n) % k
            else:
                total += n
            if total not in d:
                d[total] = i
            else:
                if i - d[total] >= 2:
                    return True
        return False





# 974. Subarray Sums Divisible by K
"""
Given an integer array nums and an integer k, return the number of non-empty subarrays that have a sum divisible by k.
Input: nums = [4,5,0,-2,-3,1], k = 5
Output: 7   Explanation: There are 7 subarrays with a sum divisible by k = 5:   [4, 5, 0, -2, -3, 1], [5], [5, 0], [5, 0, -2, -3], [0], [0, -2, -3], [-2, -3]
"""
class Solution:
    def subarraysDivByK(self, nums: List[int], k: int) -> int:
        res = 0
        prefix_sum = 0
        count = {0: 1}
        for num in nums:
            prefix_sum = (prefix_sum + num) % k
            res += count[prefix_sum] if prefix_sum in count else 0
            count[prefix_sum] = count.get(prefix_sum, 0) + 1
        return res

    for _ in range(10): pass         # 为了好看





############################################ Backtracking ########################################################

# 79. Word Search   (backtracking 模板)
"""
Given an m x n grid of characters board and a string word, return true if word exists in the grid.
The word can be constructed from letters of sequentially adjacent cells, where adjacent cells are horizontally or vertically neighboring. 
The same letter cell may not be used more than once.
Input: board = [["A","B","C","E"],["S","F","C","S"],["A","D","E","E"]], word = "ABCCED"
Output: true
"""
class Solution(object):
    def exist(self, board, word):
        self.ROWS = len(board)
        self.COLS = len(board[0])
        self.board = board

        for row in range(self.ROWS):
            for col in range(self.COLS):
                if self.backtrack(row, col, word):
                    return True
        return False

    def backtrack(self, row, col, suffix):
        # Step 1). check if we reach the bottom case of the recursion
        if len(suffix) == 0:
            return True

        # Step 2). check if the current state is invalid
        if row < 0 or row == self.ROWS or col < 0 or col == self.COLS or self.board[row][col] != suffix[0]:
            return False

        # Step 3). If the current step is valid, we mark the current cell as visited and start backtracking using DFS
        self.board[row][col] = '#'
        for rowOffset, colOffset in [(0, 1), (-1, 0), (0, -1), (1, 0)]:
            if self.backtrack(row + rowOffset, col + colOffset, suffix[1:]):
                return True
        # Step 4). revert the cell back to its original state
        self.board[row][col] = suffix[0]

        return False





# 212. Word Search II
"""
Given an m x n board of characters and a list of strings words, return all words on the board.
Each word must be constructed from letters of sequentially adjacent cells, where adjacent cells are horizontally or vertically neighboring. 
The same letter cell may not be used more than once in a word.
Input: board = [["o","a","a","n"],["e","t","a","e"],["i","h","k","r"],["i","f","l","v"]], words = ["oath","pea","eat","rain"]
Output: ["eat","oath"]
"""
class Solution:
    # Approach 1: Backtracking with Trie
    # Hashset vs Trie: Not only can Trie tell the membership of a word, but also it can instantly find the words that share a given prefix.
    # Optimization Tricks: Backtrack along the nodes in Trie. / Gradually prune the nodes in Trie during the backtracking.
    #                      Keep words in the Trie. / Remove the matched words from the Trie. (https://leetcode.com/problems/word-search-ii/solution/)
    def findWords(self, board: List[List[str]], words: List[str]) -> List[str]:
        WORD_KEY = '$'
        
        trie = {}
        for word in words:
            node = trie
            for letter in word:
                node = node.setdefault(letter, {})
            node[WORD_KEY] = word
        rowNum, colNum = len(board), len(board[0])
        matchedWords = []
        
        def backtracking(row, col, parent):
            letter = board[row][col]
            currNode = parent[letter]

            # we removed the matched word to avoid duplicates, as well as avoiding using set() for results.
            word_match = currNode.pop(WORD_KEY, False)
            if word_match:
                matchedWords.append(word_match)
            
            board[row][col] = '#'       # mark the cell as visited 
            for (rowOffset, colOffset) in [(-1, 0), (0, 1), (1, 0), (0, -1)]:
                newRow, newCol = row + rowOffset, col + colOffset     
                if newRow < 0 or newRow >= rowNum or newCol < 0 or newCol >= colNum:
                    continue
                if board[newRow][newCol] not in currNode:
                    continue
                backtracking(newRow, newCol, currNode)
            board[row][col] = letter
        
            # Optimization: incrementally remove the matched leaf node in Trie.
            if not currNode:
                parent.pop(letter)

        for row in range(rowNum):
            for col in range(colNum):
                if board[row][col] in trie:
                    backtracking(row, col, trie)
        
        return matchedWords





# 489. Robot Room Cleaner
"""
You are controlling a robot that is located somewhere in a room. The room is modeled as an m x n binary grid where 0 represents a wall and 1 represents an empty slot.
The robot starts at an unknown location in the room that is guaranteed to be empty, and you do not have access to the grid, but you can move the robot using the given API Robot.
You are tasked to use the robot to clean the entire room (i.e., clean every empty cell in the room). The robot with the four given APIs can move forward, turn left, or turn right. 
When the robot tries to move into a wall cell, its bumper sensor detects the obstacle, and it stays on the current cell.
Design an algorithm to clean the entire room using the following APIs:  move() , turnLeft() , turnRight() , clean()
you must control the robot using only the four mentioned APIs without knowing the room layout and the initial robot's position.
"""
# going clockwise : 0: 'up', 1: 'right', 2: 'down', 3: 'left'
# the order is important since the idea is always to turn right             Time complexity : O(N−M)    N is number of cells, M is number of obstacles.
DIRECTIONS = [(-1, 0), (0, 1), (1, 0), (0, -1)]

class Solution:
    def cleanRoom(self, robot):
        self.visited = set()
        self.explore(robot, (0, 0), 0)
        
    def explore(self, robot, cell, d):
        self.visited.add(cell)
        robot.clean()
        
        for i in range(4):
            new_d = (d + i) % 4     # 每曾递归的开始需要确定一个初始默认的前进方向
            new_cell = (cell[0] + DIRECTIONS[new_d][0], cell[1] + DIRECTIONS[new_d][1])
            
            if new_cell not in self.visited and robot.move():
                self.explore(robot, new_cell, new_d)
                self.backtrack_one(robot)
            robot.turnRight()       # 走到这一步证明前方有路障，需要右转继续往下递归 
            
    def backtrack_one(self, robot):
        robot.turnRight()
        robot.turnRight()
        robot.move()
        robot.turnRight()
        robot.turnRight()





# 208. Implement Trie (Prefix Tree)
"""
A trie (pronounced as "try") or prefix tree is a tree data structure used to efficiently store and retrieve keys in a dataset of strings. 
There are various applications of this data structure, such as autocomplete, spellchecker, IP routing (Longest prefix matching).

There are several other data structures, like balanced trees and hash tables, which give us the possibility to search for a word in a dataset of strings. 
Then why do we need trie? Although hash table has O(1) time complexity for looking for a key, it is not efficient in the following operations:
    - Finding all keys with a common prefix.
    - Enumerating a dataset of strings in lexicographical order.
Another reason why trie outperforms hash table, is that as hash table increases in size, there are lots of hash collisions and the search time complexity 
could deteriorate to O(n), where n is the number of keys inserted. Trie could use less space compared to Hash Table when storing many keys with the same prefix. 
In this case using trie has only O(m) time complexity, where m is the key length. Searching for a key in a balanced tree costs O(mlogn) time complexity.
"""
class TrieNode:
    def __init__(self):
        self.children = {}
        self.isWord = False
        self.word = None


class Trie:
    def __init__(self):
        self.root = TrieNode()

    def insert(self, word: str) -> None:
        node = self.root
        for ch in word:
            if ch not in node.children:
                node.children[ch] = TrieNode()
            node = node.children[ch]
        node.isWord = True
        node.word = word

    def search(self, word: str) -> bool:
        node = self.root
        for ch in word:
            if ch not in node.children:
                return False
            node = node.children[ch]
        return node and node.isWord

    def startsWith(self, prefix: str) -> bool:
        node = self.root
        for ch in prefix:
            if ch not in node.children:
                return False
            node = node.children[ch]
        return True

    for _ in range(10): pass         # 为了好看





# 1804. Implement Trie II (Prefix Tree)
"""
Input
["Trie", "insert", "insert", "countWordsEqualTo", "countWordsStartingWith", "erase", "countWordsEqualTo", "countWordsStartingWith", "erase", "countWordsStartingWith"]
[[], ["apple"], ["apple"], ["apple"], ["app"], ["apple"], ["apple"], ["app"], ["apple"], ["app"]]
Output
[null, null, null, 2, 2, null, 1, 1, null, 0]
"""
# A slightly modification based on basic Trie implementation. 
# count: count only the exact word          count_start_with: count all words has the same prefix
class TrieNode:
    def __init__(self):
        self.children = {}
        self.count = 0
        self.count_start_with = 0
        

class Trie:
    def __init__(self):
        self.root = TrieNode()

    def insert(self, word: str) -> None:
        node = self.root
        for ch in word:
            if ch not in node.children:
                node.children[ch] = TrieNode()
            node = node.children[ch]
            node.count_start_with += 1
        node.count += 1

    def countWordsEqualTo(self, word: str) -> int:
        node = self.root
        for ch in word:
            if ch not in node.children:
                return 0
            node = node.children[ch]
        return node.count

    def countWordsStartingWith(self, prefix: str) -> int:
        node = self.root
        for ch in prefix:
            if ch not in node.children:
                return 0
            node = node.children[ch]
        return node.count_start_with

    def erase(self, word: str) -> None:
        node = self.root
        for ch in word:
            node = node.children[ch]
            node.count_start_with -= 1
        node.count -= 1

    for _ in range(10): pass         # 为了好看





# 211. Design Add and Search Words Data Structure
"""
Design a data structure that supports adding new words and finding if a string matches any previously added string.
Implement the WordDictionary class:
    WordDictionary() Initializes the object.
    void addWord(word) Adds word to the data structure, it can be matched later.
    bool search(word) Returns true if there is any string that matches word or false otherwise. word may contain dots '.' where dots can be matched with any letter.
Input
["WordDictionary","addWord","addWord","addWord","search","search","search","search"]
[[],["bad"],["dad"],["mad"],["pad"],["bad"],[".ad"],["b.."]]
Output
[null,null,null,null,false,true,true,true]
"""
# Approach 1.       Hashmap     只做参考
class WordDictionary:
    def __init__(self):
        self.hashmap = defaultdict(set)

    def addWord(self, word: str) -> None:
        self.hashmap[len(word)].add(word)

    def search(self, word: str) -> bool:
        m = len(word)
        for word_in_map in self.hashmap[m]:
            i = 0
            while i < m and (word_in_map[i] == word[i] or word[i] == '.'):
                i += 1
            if i == m:
                return True
        return False


# Approach 2.       Trie





######################################################## Tree ###################################################################

# Definition for a binary tree node.
class TreeNode:
    def __init__(self, val=0, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right

# 101. Symmetric Tree
"""
Given the root of a binary tree, check whether it is a mirror of itself (i.e., symmetric around its center).
Input: root = [1,2,2,3,4,4,3]
Output: true
"""
class Solution:
    # Approach 1    Recursion
    def isSymmetric(self, root: Optional[TreeNode]) -> bool:
        if root is None:
            return True
        return self.helper(root.left, root.right)
    
    def helper(self, left, right):
        if not left and not right:
            return True
        if not left or not right:
            return False
        
        if left.val == right.val:
            outPair = self.helper(left.left, right.right)
            inPair = self.helper(left.right, right.left)
            return outPair and inPair
        return False
    
    # Approach 2    Iterative (using stack to mimic)
    def isSymmetric(self, root: Optional[TreeNode]) -> bool:
        if root is None:
            return True
        stack = [(root.left, root.right)]
        while stack:
            left, right = stack.pop()
            if left is None and right is None:
                continue
            if left is None or right is None:
                return False
            if left.val == right.val:
                stack.append((left.left, right.right))
                stack.append((left.right, right.left))
            else:
                return False
        return True

    for _ in range(10): pass         # 为了好看





# 104. Maximum Depth of Binary Tree
"""
Given the root of a binary tree, return its maximum depth.
Input: root = [3,9,20,null,null,15,7]
Output: 3
"""
class Solution:
    # Approach 1        Recursive
    def maxDepth(self, root: Optional[TreeNode]) -> int:
        if not root:
            return 0
        
        left_depth = self.maxDepth(root.left)
        right_depth = self.maxDepth(root.right)
        
        return max(left_depth, right_depth) + 1

    # Approach 2        Iterative
    def maxDepth(self, root: Optional[TreeNode]) -> int:
        stack = []
        if root is not None:
            stack.append((root, 1))
            
        depth = 0
        while stack:
            node, curr_depth = stack.pop()
            if node is not None:
                depth = max(curr_depth, depth)
                stack.append((node.right, curr_depth + 1))
                stack.append((node.left, curr_depth + 1))
        return depth

    for _ in range(10): pass         # 为了好看





# 111. Minimum Depth of Binary Tree
"""
Given a binary tree, find its minimum depth.
Input: root = [2,null,3,null,4,null,5,null,6]
Output: 5
"""
class Solution:
    def minDepth(self, root: Optional[TreeNode]) -> int:
        if not root:
            return 0
        if not root.left and not root.right:
            return 1
        if root.left and not root.right:
            return 1 + self.minDepth(root.left)
        if root.right and not root.left:
            return 1 + self.minDepth(root.right)
        return 1 + min(self.minDepth(root.left), self.minDepth(root.right))
    
    
    def minDepth(self, root: Optional[TreeNode]) -> int:
        if not root:
            return 0
        if not root.left or not root.right:
            return 1 + max(self.minDepth(root.left), self.minDepth(root.right))
        return 1 + min(self.minDepth(root.left), self.minDepth(root.right))
    
    
    def minDepth(self, root: Optional[TreeNode]) -> int:
        if not root:
            return 0
        queue = deque([(root, 1)])
        while queue:
            node, level = queue.popleft()
            if node:
                if not node.left and not node.right:
                    return level    # 相当于找最短路径问题，一旦遇到叶子节点马上返回其深度
                else:
                    queue.append((node.left, level+1))
                    queue.append((node.right, level+1))

        for _ in range(10): pass         # 为了好看





# 112. Path Sum
"""
Given the root of a binary tree and an integer targetSum, return true if the tree has a root-to-leaf path such that adding up all the values along the path equals targetSum.
"""
class Solution:
    # Approach 1: Recursion
    def hasPathSum(self, root: Optional[TreeNode], targetSum: int) -> bool:
        if not root:
            return False
        
        targetSum -= root.val
        if root.left is None and root.right is None:
            return targetSum == 0
        
        return self.hasPathSum(root.left, targetSum) or self.hasPathSum(root.right, targetSum)
    
    
    # Approach 2: Iterations
    def hasPathSum(self, root: Optional[TreeNode], targetSum: int) -> bool:
        if not root:
            return False

        queue = deque([(root, targetSum - root.val)])   # 一般stack用在DFS，queue用在BFS, 如果用stack模拟递归，就先判断  if root.right
        while queue:
            node, curr_sum = queue.popleft()
            if node.left is None and node.right is None and curr_sum == 0:
                return True
            if node.left:
                queue.append((node.left, curr_sum - node.left.val))
            if node.right:      
                queue.append((node.right, curr_sum - node.right.val))
        return False

    for _ in range(10): pass         # 为了好看





# 113. Path Sum II
"""
Given the root of a binary tree and an integer targetSum, return all root-to-leaf paths where the sum of the node values in the path equals targetSum. 
Each path should be returned as a list of the node values, not node references.
"""
class Solution:
    # Approach 1:       Traversal  以 target 作为递归条件
    def pathSum(self, root: Optional[TreeNode], targetSum: int) -> List[List[int]]:
        results = []
        self.dfs(root, targetSum, [], results)
        return results
    
    def dfs(self, root, target, path, results):
        if root is None:
            return
            
        path.append(root.val)   # 这里必须先要 append，再做判断，否则最后一个node不会被append进 path 里

        # 1. 在target上做减法可以使用全局变量root.val，不用分别对左子树右子树分开操作，对比 Method2
        if root.left is None and root.right is None and target == root.val:
            results.append(path[:])
            
        if root.left:
            self.dfs(root.left, target - root.val, path, results)
        if root.right:
            self.dfs(root.right, target - root.val, path, results)
        path.pop()


    # Approach 2:       Traversal 2     以 path 作为递归条件
    def pathSum(self, root: Optional[TreeNode], targetSum: int) -> List[List[int]]:
        if not root:
            return []
        result = []
        self.traversal(root, targetSum, [root.val], result)
        return result

    def traversal(self, root, target, path, result):
        if root is None:
            return
        if root.left is None and root.right is None and sum(path) == target:
            result.append(path)

        # 因为这里分成左右子树分别遍历，所以不能path+[root.val]，所以就得在主函数中append进root.val，对比permutation
        if root.left:
            self.traversal(root.left, target, path + [root.left.val], result)
        if root.right:
            self.traversal(root.right, target, path + [root.right.val], result)





# 437. Path Sum III
"""
Given the root of a binary tree and an integer targetSum, return the number of paths where the sum of the values along the path equals targetSum.
The path does not need to start or end at the root or a leaf, but it must go downwards (i.e., traveling only from parent nodes to child nodes).
"""
class Solution:
    # Approach 1:       Brute Force: O(nlogn) ~ O(n^2)
    # (1st layer DFS) Use recursive traverse to go through each node (can be any order: pre, in, post).
    # (2nd layer DFS) For each node, walk through all paths. If a path sum equals to the target: self.numOfPaths += 1
    # Assume we have n TreeNodes in total, the tree height will vary from O(n) (single sided tree) to O(logn)(balanced tree).
    # 1st layer DFS will always take O(n), 2nd layer DFS will take range from O(n) (single sided tree) to O(logn)(balanced tree)
    # The length of path is proportional to the tree height. the total time complexity is O(nlogn) to O(n^2).
    def pathSum(self, root: Optional[TreeNode], targetSum: int) -> int:
        if not root:
            return 0
        
        self.numOfPaths = 0
        self.dfs(root, targetSum)      # 1st layer DFS to go through each node
        return self.numOfPaths
    
    # define: traverse through the tree, at each treenode, call another DFS to test if a path sum include the answer
    def dfs(self, node, target):
        if node is None:
            return 

        self.test(node, target) # you can move the line to any order, here is pre-order
        self.dfs(node.left, target)
        self.dfs(node.right, target)
    
    def test(self, node, target):
        if node is None:
            return
        if node.val == target:
            self.numOfPaths += 1
            
        self.test(node.left, target - node.val)
        self.test(node.right, target - node.val)


    # Approach 2:       Memorization of path sum: O(n)
    # In solution 1, we did a lot of repeated calculation. For example 1->3->5, we calculated: 1, 1+3, 1+3+5, 3, 3+5, 5.
    # we can create a cache dict which saves all the path sum (from ROOT to current node) and their frequency.
    # Again, we traverse the tree, at each node, we can get the currPathSum (from ROOT to current node). If within this path, there is a valid solution, 
    # then there must be a oldPathSum such that currPathSum - oldPathSum = target. We just need to add the frequency of the oldPathSum to the result.
    # During the DFS break down, we need to -1 in cache[currPathSum], because this path is not available in later traverse.
    def pathSum(self, root: Optional[TreeNode], targetSum: int) -> int:
        self.result = 0
        cache = {0: 1}
        self.dfs(root, targetSum, 0, cache)
        return self.result
    
    def dfs(self, root, target, currPathSum, cache):
        if root is None:
            return  
        # calculate currPathSum and required oldPathSum
        currPathSum += root.val
        oldPathSum = currPathSum - target
        # update result and cache
        self.result += cache.get(oldPathSum, 0)
        cache[currPathSum] = cache.get(currPathSum, 0) + 1
        
        self.dfs(root.left, target, currPathSum, cache)
        self.dfs(root.right, target, currPathSum, cache)
        # when move to a different branch, the currPathSum is no longer available, hence remove one. 
        cache[currPathSum] -= 1





# 666. Path Sum IV
"""
If the depth of a tree is smaller than 5, then this tree can be represented by an array of three-digit integers. For each integer in this array:
    The hundreds digit represents the depth d of this node where 1 <= d <= 4.
    The tens digit represents the position p of this node in the level it belongs to where 1 <= p <= 8. The position is the same as that in a full binary tree.
    The units digit represents the value v of this node where 0 <= v <= 9.
Given an array of ascending three-digit integers nums representing a binary tree with a depth smaller than 5, return the sum of all paths from the root towards the leaves.
Input: nums = [113,215,221]
Output: 12
Explanation: The tree that the list represents is shown.
The path sum is (3 + 5) + (3 + 1) = 12.
"""
class Solution(object):
    # we can use num / 10 = 10 * depth + pos. The left child: 10 * (depth + 1) + 2 * pos - 1, and the right child would be one greater.
    def pathSum(self, nums):
        self.ans = 0
        values = {x // 10: x % 10 for x in nums}
        def dfs(node, running_sum = 0):
            if node not in values: return
            running_sum += values[node]
            depth, pos = divmod(node, 10)
            left = (depth + 1) * 10 + 2 * pos - 1
            right = left + 1

            if left not in values and right not in values:
                self.ans += running_sum
            else:
                dfs(left, running_sum)
                dfs(right, running_sum)

        dfs(nums[0] // 10)
        return self.ans





# 250. Count Univalue Subtrees
"""
Given the root of a binary tree, return the number of uni-value subtrees. A uni-value subtree means all nodes of the subtree have the same value.
Input: root = [5,1,5,5,5,null,5]
Output: 4
"""
class Solution:
    def countUnivalSubtrees(self, root: Optional[TreeNode]) -> int:
        if root is None: return 0
        self.count = 0
        self.is_uni(root)
        return self.count

    def is_uni(self, node):
        if node.left is None and node.right is None:
            self.count += 1
            return True

        is_uni = True
        if node.left is not None:
            is_uni = self.is_uni(node.left) and is_uni and node.left.val == node.val
        if node.right is not None:
            is_uni = self.is_uni(node.right) and is_uni and node.right.val == node.val

        self.count += is_uni    # self.count = self.count + 1 if is_uni else self.count
        return is_uni





# 105. Construct Binary Tree from Preorder and Inorder Traversal
"""
Input: preorder = [3,9,20,15,7], inorder = [9,3,15,20,7]
Output: [3,9,20,null,null,15,7]
"""
class Solution:
    def buildTree(self, preorder: List[int], inorder: List[int]) -> Optional[TreeNode]:
        if not preorder or len(preorder) == 0:
            return None
        
        root = TreeNode(preorder[0])
        root_index = inorder.index(preorder[0])
        
        root.left = self.buildTree(preorder[1: root_index+1], inorder[: root_index])
        root.right = self.buildTree(preorder[root_index+1:], inorder[root_index + 1:])
        return root

    for _ in range(10): pass         # 为了好看





# 106. Construct Binary Tree from Inorder and Postorder Traversal
"""
Input: inorder = [9,3,15,20,7], postorder = [9,15,7,20,3]
Output: [3,9,20,null,null,15,7]
"""
class Solution:
    def buildTree(self, inorder: List[int], postorder: List[int]) -> Optional[TreeNode]:
        if not inorder or len(inorder) == 0:
            return None
        
        root = TreeNode(postorder[-1])
        root_index = inorder.index(postorder[-1])
        
        root.left = self.buildTree(inorder[: root_index], postorder[: root_index])
        root.right = self.buildTree(inorder[root_index+1:], postorder[root_index: -1])
        return root
    
    for _ in range(10): pass         # 为了好看





# 116. Populating Next Right Pointers in Each Node
"""
You are given a perfect binary tree where all leaves are on the same level, and every parent has two children. The binary tree has the following definition:
Populate each next pointer to point to its next right node. If there is no next right node, the next pointer should be set to NULL. Initially, all next pointers are set to NULL.
Input: root = [1,2,3,4,5,6,7]
Output: [1,#,2,3,#,4,5,6,7,#]
"""
class Solution:
    # Approach 1: Level Order Traversal             O(N) / O(N)
    def connect(self, root: 'Node') -> 'Node':
        if not root:
            return root
        queue = deque([root])
        
        while queue:
            size = len(queue)
            for i in range(size):
                node = queue.popleft()
                
                if i < size - 1:    # 精髓！利用了当前level的size！
                    node.next = queue[0]
                if node.left:
                    queue.append(node.left)
                if node.right:
                    queue.append(node.right)
        return root
    
    
    # Approach 2: Using previously established next pointers        O(N) / O(1)
    def connect(self, root: 'Node') -> 'Node':
        if not root:
            return root
        
        leftmost = root
        while leftmost.left:
            head = leftmost         # Iterate the "linked list" starting from the head
            while head:
                head.left.next = head.right     # CONNECTION 1
                if head.next:
                    head.right.next = head.next.left        # CONNECTION 2
                head = head.next        # Progress along the list (nodes on the current level)
            leftmost = leftmost.left    # Move onto the next level

        return root


    # Approach 3:   Recursive       好好品
    def connect(self, root: 'Node', n = None) -> 'Node':
        if not root: return
        root.next = n
        self.connect(root.left, root.right)
        self.connect(root.right, n.left if n else None)
        return root

    for _ in range(10): pass         # 为了好看





# 117. Populating Next Right Pointers in Each Node II
"""
Given a non-perfect binary tree, Populate each next pointer to point to its next right node. If there is no next right node, the next pointer should be set to NULL.
Input: root = [1,2,3,4,5,null,7]
Output: [1,#,2,3,#,4,5,7,#]
"""
class Solution:
    def connect(self, root: 'Node') -> 'Node':
        if not root:
            return root
        queue = deque([root])
        
        while queue:
            size = len(queue)
            for i in range(size):
                node = queue.popleft()
                if i < size - 1:
                    node.next = queue[0]
                if node.left:
                    queue.append(node.left)
                if node.right:
                    queue.append(node.right)
        return root
    

# Approach 2: Using previously established next pointers
class Solution:
    def connect(self, root: Optional['Node']) -> Optional['Node']:
        if not root:
            return root

        leftmost = root
        while leftmost:
            prev, curr = None, leftmost
            leftmost = None
            while curr:
                prev, leftmost = self.processChild(curr.left, prev, leftmost)
                prev, leftmost = self.processChild(curr.right, prev, leftmost)
                curr = curr.next
        return root

    def processChild(self, childNode, prev, leftmost):
        if childNode:
            if prev:
                prev.next = childNode
            else:    
                leftmost = childNode
            prev = childNode 
        return prev, leftmost





# 199. Binary Tree Right Side View
"""
Given the root of a binary tree, imagine yourself standing on the right side of it, return the values of the nodes you can see ordered from top to bottom.
Input: root = [1,2,3,null,5,null,4]
Output: [1,3,4]
"""
class Solution:
    # Approach 1:       BFS
    def rightSideView(self, root: Optional[TreeNode]) -> List[int]:
        if root is None:
            return []
        
        queue = deque([root])
        results = []
        
        while queue:
            level_length = len(queue)
            for i in range(level_length):
                node = queue.popleft()
                if i == level_length - 1:       # 就记住这一行就可以了
                    results.append(node.val)
                if node.left:
                    queue.append(node.left)
                if node.right:
                    queue.append(node.right)
                    
        return results
    
    
    # Approach 2:       DFS
    def rightSideView(self, root: Optional[TreeNode]) -> List[int]:
        if root is None:
            return []
        results = []
        self.dfs(root, 0, results)
        return results
    
    def dfs(self, root, level, results):
        if level == len(results):
            results.append(root.val)
        
        if root.right:      # 这里是先右再左
            self.dfs(root.right, level + 1, results)
        if root.left:
            self.dfs(root.left, level + 1, results)





# 545. Boundary of Binary Tree
"""
The boundary of a binary tree is the concatenation of the root, the left boundary, the leaves ordered from left-to-right, and the reverse order of the right boundary.
Input: root = [1,2,3,4,5,6,null,null,null,7,8,9,10]
Output: [1,2,4,7,8,9,10,6,3]
"""
class Solution:
    def boundaryOfBinaryTree(self, root: Optional[TreeNode]) -> List[int]:
        if root is None:
            return []
        if not root.left and not root.right:        # 整棵树就只有树桩 [1]
            return [root.val]
            
        left_boundary = self.find_left_boundary(root.left)
        leaves = self.find_leaves(root)
        right_boundary = self.find_right_boundary(root.right)
        
        if left_boundary and leaves and left_boundary[-1] == leaves[0]:
            leaves = leaves[1:]
        if leaves and right_boundary and right_boundary[-1] == leaves[-1]:
            leaves = leaves[:-1]
        return [root.val] + left_boundary + leaves + list(reversed(right_boundary))

    def find_leaves(self, root):
        stack = [root]
        leaves = []
        while stack:
            node = stack.pop()
            if not node.left and not node.right:
                leaves.append(node.val)
            if node.right:      # 这里一定注意！！！先右节点入栈！！！
                stack.append(node.right)
            if node.left:
                stack.append(node.left)
        return leaves
        
    def find_left_boundary(self, root):
        left_boundary = []
        while root is not None:
            left_boundary.append(root.val)
            if root.left:
                root = root.left
            elif root.right:        # 这里一定要elif，没发往左走再往右找
                root = root.right
            else:
                break       # 到叶子就break
        return left_boundary
        
    def find_right_boundary(self, root):
        right_boundary = []
        while root is not None:
            right_boundary.append(root.val)
            if root.right:
                root = root.right
            elif root.left:     # 这里一定要elif，没发往右走再往左找
                root = root.left
            else:
                break       # 到叶子就break
        return right_boundary


    # Approach 2
    def boundaryOfBinaryTree(self, root):
        def dfs_leftmost(node):
            if not node or not node.left and not node.right:
                return
            boundary.append(node.val)
            if node.left:
                dfs_leftmost(node.left)
            else:
                dfs_leftmost(node.right)

        def dfs_leaves(node):
            if not node:
                return
            dfs_leaves(node.left)
            if node != root and not node.left and not node.right:
                boundary.append(node.val)
            dfs_leaves(node.right)

        def dfs_rightmost(node):
            if not node or not node.left and not node.right:
                return
            if node.right:
                dfs_rightmost(node.right)
            else:
                dfs_rightmost(node.left)
            boundary.append(node.val)

        if not root:
            return []
        boundary = [root.val]
        dfs_leftmost(root.left)
        dfs_leaves(root)
        dfs_rightmost(root.right)
        return boundary





# 297. Serialize and Deserialize Binary Tree   (same with 449. Serialize and Deserialize BST)
"""
Input: root = [1,2,3,null,null,4,5]
Output: [1,2,3,null,null,4,5]
"""
class Codec:
    def serialize(self, root):
        if not root:
            return ""
        queue = deque([root])
        order = ""
        
        while queue:
            node = queue.popleft()
            if not node:
                order += 'None,'
                continue
            else:
                order += str(node.val) + ','
                queue.append(node.left)
                queue.append(node.right)

        return order[:-1]       # 去掉最后一个逗号

    def deserialize(self, data):
        if not data:
            return None
        bt_list = data.split(',')
        root = TreeNode(bt_list[0])
        queue = deque([root])
        isLeftChild = True
        index = 0
        
        for node_val in bt_list[1:]:
            if node_val != 'None':
                node = TreeNode(int(node_val))
                if isLeftChild:
                    queue[index].left = node
                else:
                    queue[index].right = node
                queue.append(node)
                
            if not isLeftChild:
                index += 1
            isLeftChild = not isLeftChild
            
        return root





# 257. Binary Tree Paths
"""
Given the root of a binary tree, return all root-to-leaf paths in any order.
"""
class Solution:
    # Approach 1.   Recursion   top-down
    def binaryTreePaths(self, root: Optional[TreeNode]) -> List[str]:
        if not root:
            return []
        
        paths = []
        self.dfs(root, [str(root.val)], paths)
        return paths
    
    def dfs(self, root, path, paths):
        if not root:
            return []
        
        if not root.left and not root.right:
            paths.append("->".join(path))
            return
            
        if root.left:
            self.dfs(root.left, path + [str(root.left.val)], paths)
        if root.right:
            self.dfs(root.right, path + [str(root.right.val)], paths)


    # Approach 1.5
    def binaryTreePaths(self, root: Optional[TreeNode]) -> List[str]:
        if not root:
            return []
        paths = []
        self.dfs(root, '', paths)
        return paths
        
    def dfs(self, root, path, paths):
        if root:
            path += str(root.val)
            if not root.left and not root.right:
                paths.append(path)
            else:
                path += '->'
                self.dfs(root.left, path, paths)
                self.dfs(root.right, path, paths)
            
    
    # Approach 2.       Recursion   bottom-up
    def binaryTreePaths(self, root: Optional[TreeNode]) -> List[str]:
        if not root:
            return []
        
        if not root.left and not root.right:
            return [str(root.val)]
        
        leftPath = self.binaryTreePaths(root.left)
        rightPath = self.binaryTreePaths(root.right)
        
        paths = []
        for path in leftPath + rightPath:
            paths.append(str(root.val) + "->" + path)
            
        return paths


    # Approach 3.       BFS    
    def binaryTreePaths(self, root: Optional[TreeNode]) -> List[str]:
        if not root:
            return []
        
        queue = deque([(root, "")])
        paths = []
        
        while queue:
            node, path = queue.popleft()
            if path:
                path += "->" + str(node.val)
            else:
                path += str(node.val)
            
            if node.left is None and node.right is None:
                paths.append(path)
            
            if node.left:
                queue.append((node.left, path))
            if node.right:
                queue.append((node.right, path))

        return paths

    for _ in range(10): pass         # 为了好看





# 236. Lowest Common Ancestor of a Binary Tree
"""
Input: root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 1
Output: 3
"""
class Solution:
    def lowestCommonAncestor(self, root: 'TreeNode', p: 'TreeNode', q: 'TreeNode') -> 'TreeNode':
        if not root:
            return None
        
        left = self.lowestCommonAncestor(root.left, p, q)
        right = self.lowestCommonAncestor(root.right, p, q)
        
        if root == p or root == q:
            return root
        if left and right:
            return root
        if left:
            return left
        if right:
            return right
        return None

    for _ in range(10): pass         # 为了好看





# 1644. Lowest Common Ancestor of a Binary Tree II
"""
If either node p or q does not exist in the tree, return null
Input: root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 10
Output: null    Explanation: Node 10 does not exist in the tree, so return null.
"""
class Solution:
    def lowestCommonAncestor(self, root: 'TreeNode', p: 'TreeNode', q: 'TreeNode') -> 'TreeNode':
        if not root:
            return None
        
        a, b, LCA = self.helper(root, p, q)
        if a and b:
            return LCA
        else:
            return None
        
    def helper(self, root, A, B):
        if not root:
            return False, False, None
        
        left_a, left_b, left = self.helper(root.left, A, B)
        right_a, right_b, right = self.helper(root.right, A, B)
        
        a = left_a or right_a or A == root
        b = left_b or right_b or B == root
        
        if root == A or root == B:
            return a, b, root
        if left and right:
            return a, b, root
        if left:
            return a, b, left
        if right:
            return a, b, right

        return a, b, None





# 1650. Lowest Common Ancestor of a Binary Tree III
"""
Each node will have a reference to its parent node
"""
class Solution:
    def lowestCommonAncestor(self, p: 'Node', q: 'Node') -> 'Node':
        path = set()
        while p:
            path.add(p)
            p = p.parent 
        while q not in path:
            q = q.parent
        return q

    for _ in range(10): pass         # 为了好看





# 1676. Lowest Common Ancestor of a Binary Tree IV
"""
return the lowest common ancestor (LCA) of all the nodes in nodes. All the nodes will exist in the tree, and all values of the tree's nodes are unique.
Input: root = [3,5,1,6,2,0,8,null,null,7,4], nodes = [7,6,2,4]
Output: 5       Explanation: The lowest common ancestor of the nodes 7, 6, 2, and 4 is node 5.
"""
class Solution:
    def lowestCommonAncestor(self, root: 'TreeNode', nodes: 'List[TreeNode]') -> 'TreeNode':
        if not root:
            return None
        return self.dfs(root, nodes)
    
    def dfs(self, root, nodes):
        if not root or root in nodes:       # 此处是重点
            return root
        
        left = self.dfs(root.left, nodes)
        right = self.dfs(root.right, nodes)
        
        if left and right:
            return root
        else:
            return left or right





# 654. Maximum Binary Tree
"""
You are given an integer array nums with no duplicates. A maximum binary tree can be built recursively from nums using the following algorithm:
    Create a root node whose value is the maximum value in nums.
    Recursively build the left subtree on the subarray prefix to the left of the maximum value.
    Recursively build the right subtree on the subarray suffix to the right of the maximum value.
Return the maximum binary tree built from nums.
Input: nums = [3,2,1,6,0,5]
Output: [6,3,5,null,2,0,null,null,1]
"""
class Solution:
    # We want to optimize from O(n^2), O(nlogn) doesn't seem like very promising, so we try O(n). Basically, if we need O(n) solution, 
    # we can only have constant operation during the traverse of the list. Therefore, we need something the keep track of the traversing memory
    # We need to remember the max node rather than trying to find them each time. So we need something that has an order and hierarchy. 
    # So we can use stack here, We keep track of a stack, and make sure the numbers in stack is in decreasing order.
    def constructMaximumBinaryTree(self, nums: List[int]) -> Optional[TreeNode]:
        if not nums:
            return None
        
        stack = []
        last = None
        for num in nums:
            while stack and stack[-1].val < num:
                last = stack.pop()
            node = TreeNode(num)
            if stack:
                stack[-1].right = node
            if last:
                node.left = last
            stack.append(node)
            last = None
        return stack[0]

    for _ in range(10): pass         # 为了好看





# 889. Construct Binary Tree from Preorder and Postorder Traversal
"""
Given two integer arrays, preorder and postorder where preorder is the preorder traversal of a binary tree of distinct values and 
postorder is the postorder traversal of the same tree, reconstruct and return the binary tree. If there exist multiple answers, you can return any of them.
Input: preorder = [1,2,4,5,3,6,7], postorder = [4,5,2,6,7,3,1]
Output: [1,2,3,4,5,6,7]
"""
class Solution:
    # Appraoch 1    Recursive       Create a node TreeNode(pre[preIndex]) as the root. Becasue root node will be lastly iterated in post order,
    # if root.val == post[posIndex], it means we have constructed the whole tree, If we haven't completed constructed the whole tree,
    # So we recursively constructFromPrePost for left sub tree and right sub tree.
    # And finally, we'll reach the posIndex that root.val == post[posIndex]. We increment posIndex and return our root node.
    preIndex, posIndex = 0, 0
    def constructFromPrePost(self, pre, post):
        root = TreeNode(pre[self.preIndex])
        self.preIndex += 1
        if (root.val != post[self.posIndex]):
            root.left = self.constructFromPrePost(pre, post)
        if (root.val != post[self.posIndex]):
            root.right = self.constructFromPrePost(pre, post)
        self.posIndex += 1
        return root


    # Approach 2    Iterative       preorder generate TreeNodes, push them to stack and postorder pop them out. 
    #               Iterate on pre array and construct node one by one. stack save the current path of tree.
    #               node = new TreeNode(pre[i]), if left child is None, add node to the left. otherwise add it to the right.
    #               If we meet a same value in the pre and post, it means we complete the construction for current subtree. We pop it from stack.
    def constructFromPrePost(self, pre, post):
        stack = [TreeNode(pre[0])]
        j = 0
        for v in pre[1:]:
            node = TreeNode(v)
            while stack[-1].val == post[j]:
                stack.pop()
                j += 1
            if not stack[-1].left:
                stack[-1].left = node
            else:
                stack[-1].right = node
            stack.append(node)
        return stack[0]






# 31. Next Permutation
"""
For example, for arr = [1,2,3], the following are considered permutations of arr: [1,2,3], [1,3,2], [3,1,2], [2,3,1].
"""
class Solution:
    
    def nextPermutation(self, nums):
        """
        :type nums: List[int]
        :rtype: void Do not return anything, modify nums in-place instead.
        """
        if not nums or len(nums) < 2:
            return nums
        
        i = len(nums) - 2
        while i >= 0 and nums[i + 1] <= nums[i]:
            i -= 1
        
        if i < 0:
            nums.reverse()
            return
        
        else:    
            j = len(nums) - 1
            while j >= 0 and nums[j] <= nums[i]:
                j -= 1

            nums[i], nums[j] = nums[j], nums[i]
            nums[i+1:] = nums[i+1:][::-1]




# 1842. Next Palindrome Using Same Digits
"""
Return the smallest palindrome larger than num that can be created by rearranging its digits. If no such palindrome exists, return an empty string "".
Input: num = "1221"
Output: "2112"

Input: num = "32123"
Output: ""
"""
class Solution:
    
    # 1. find the next permutation that is greater than the first half of the palindrome, 
    #    say greaterHalf
    # 2. add it to the mid item if there is one and to reversed of greaterHalf
    def nextPalindrome(self, num: str) -> str:
        if not num or len(num) < 2:
            return ""
        
        num_list = list(num)
        mid = len(num) // 2
        midStr = "" if (len(num) % 2 == 0) else num_list[mid]
        
        left_greater = self.get_next_larger(num_list[: mid])
        if not left_greater:
            return ""
        
        return  "".join(left_greater) + midStr + "".join(reversed(left_greater))
    
    def get_next_larger(self, sList):
        i = len(sList) - 2
        while i >= 0 and sList[i] >= sList[i + 1]:
            i -= 1
        if i < 0:
            return []

        j = len(sList) - 1
        while j >= 0 and sList[i] >= sList[j]:
            j -= 1

        sList[i], sList[j] = sList[j], sList[i]
        sList[i + 1:] = reversed(sList[i + 1:])
        
        return sList





# 339. Nested List Weight Sum
"""
You are given a nested list of integers nestedList. Each element is either an integer or a list whose elements may also be integers or other lists.
The depth of an integer is the number of lists that it is inside of. For example, the nested list [1,[2,2],[[3],2],1] has each integer's value set to its depth.
Return the sum of each integer in nestedList multiplied by its depth.
Input: nestedList = [1,[4,[6]]]
Output: 27
Explanation: One 1 at depth 1, one 4 at depth 2, and one 6 at depth 3. 1*1 + 4*2 + 6*3 = 27.
"""
class Solution:
    
    # Approach 1: DFS
    def depthSum(self, nestedList) -> int:
        if not nestedList:
            return 0
        
        return self.dfs(nestedList, 1)
    
    def dfs(self, nested_list, depth):
        total = 0
        for l in nested_list:
            if l.isInteger():
                total += l.getInteger() * depth
            else:
                total += self.dfs(l.getList(), depth + 1)
                
        return total
        
        
    # Approach 2: BFS
    def depthSum(self, nestedList) -> int:
        queue = deque(nestedList)

        depth, total = 1, 0

        while queue:
            len_q = len(queue)
            
            for _ in range(len_q):
                nested = queue.popleft()
                
                if nested.isInteger():
                    total += nested.getInteger() * depth
                else:
                    for element in nested.getList():
                        queue.append(element)
            depth += 1

        return total





# 364. Nested List Weight Sum II
"""
You are given a nested list of integers nestedList. Each element is either an integer or a list whose elements may also be integers or other lists.
The depth of an integer is the number of lists that it is inside of. For example, the nested list [1,[2,2],[[3],2],1] has each integer's value set to its depth. 
Let maxDepth be the maximum depth of any integer. The weight of an integer is maxDepth - (the depth of the integer) + 1.
Return the sum of each integer in nestedList multiplied by its weight.
Input: nestedList = [1,[4,[6]]]
Output: 17
Explanation: One 1 at depth 3, one 4 at depth 2, and one 6 at depth 1.
1*3 + 4*2 + 6*1 = 17
"""
class Solution:
    
    # Approach 1: BFS + DFS
    def depthSumInverse(self, nestedList) -> int:
        queue = deque(nestedList)
        depth = 1
        
        while queue:
            len_q = len(queue)
            
            for _ in range(len_q):
                element = queue.popleft()
                
                if not element.isInteger():
                    for item in element.getList():
                        queue.append(item)
            depth += 1
            
        return self.dfs(nestedList, 1, depth)
    
    def dfs(self, nested_list, depth, maxDepth):
        total = 0
        
        for element in nested_list:
            if element.isInteger():
                total += element.getInteger() * (maxDepth - depth)
            else:
                total += self.dfs(element.getList(), depth + 1, maxDepth)
                
        return total
    
    
    
    # Approach 2: Single Pass DFS
    # 公式：Return the value of (maxDepth + 1) * sumOfElements - sumOfProducts. 
    def depthSumInverse(self, nestedList) -> int:
        if not nestedList or len(nestedList) == 0:
            return 0
        
        maxDepth, sumOfElement, sumOfProduct = self.dfs(nestedList, 1)
        return (maxDepth + 1) * sumOfElement - sumOfProduct
    
    def dfs(self, nested_list, depth):
        maxDepth , element_sum, product_sum = 0, 0, 0
        
        for element in nested_list:
            if element.isInteger():
                product_sum += element.getInteger() * depth
                element_sum += element.getInteger()
                maxDepth = max(depth, maxDepth)
            else:
                D, E, P = self.dfs(element.getList(), depth + 1)
                product_sum += P
                element_sum += E
                maxDepth = max(D, maxDepth)
                
        return maxDepth, element_sum, product_sum
    
    
    
    # Approach 3: Single Pass BFS
    def depthSumInverse(self, nestedList) -> int:
        if not nestedList or len(nestedList) == 0:
            return 0
        
        queue = deque(nestedList)
        depth, maxDepth = 1, 0
        sumOfElement, sumOfProduct = 0, 0
        
        while queue:
            len_q = len(queue)
            maxDepth = max(depth, maxDepth)
            
            for _ in range(len_q):
                element = queue.popleft()
                
                if element.isInteger():
                    sumOfProduct += element.getInteger() * depth
                    sumOfElement += element.getInteger()
                else:
                    for e in element.getList():
                        queue.append(e)
            depth += 1
            
        return (maxDepth + 1) * sumOfElement - sumOfProduct





# 565. Array Nesting
"""
You are given an integer array nums of length n where nums is a permutation of the numbers in the range [0, n - 1].
You should build a set s[k] = {nums[k], nums[nums[k]], nums[nums[nums[k]]], ... } subjected to the following rule:
    The first element in s[k] starts with the selection of the element nums[k] of index = k.
    The next element in s[k] should be nums[nums[k]], and then nums[nums[nums[k]]], and so on.
    We stop adding right before a duplicate element occurs in s[k].
Return the longest length of a set s[k].
Input: nums = [5,4,0,3,1,6,2]
Output: 4
Explanation: 
nums[0] = 5, nums[1] = 4, nums[2] = 0, nums[3] = 3, nums[4] = 1, nums[5] = 6, nums[6] = 2.
One of the longest sets s[k]:
s[0] = {nums[0], nums[5], nums[6], nums[2]} = {5, 6, 2, 0}
"""
class Solution:
    
    # Approach 1.    Iterative
    def arrayNesting(self, nums: List[int]) -> int:
        if not nums or len(nums) == 0:
            return 0
        
        visited = set()
        result = 0
        
        for num in nums:
            if num not in visited:
                visited.add(num)
                start = num
                count = 1
                
                while nums[start] not in visited:
                    visited.add(nums[start])
                    start = nums[start]
                    count += 1
                    
                result = max(count, result)
                
        return result
    
    
    # Approach 2.    DFS
    def arrayNesting(self, nums: List[int]) -> int:
        if not nums or len(nums) == 0:
            return 0
        
        self.visited = set()
        result = 0
        
        for index in range(len(nums)):
            if index not in self.visited:
                sub_visited = self.dfs(nums, index, set())
                result = max(result, len(sub_visited))
                
        return result
    
    def dfs(self, nums, index, sub_visited):
        self.visited.add(index)
        sub_visited.add(index)
        next_num = nums[index]
        
        if next_num not in self.visited:
            self.dfs(nums, next_num, sub_visited)
            
        return sub_visited


    # Approach 3.    BFS
    def arrayNesting(self, nums: List[int]) -> int:
        if not nums or len(nums) == 0:
            return 0
        
        visited = set()
        result = 0
        for i in range(len(nums)):
            if i in visited:
                continue
            connected = self.bfs(nums, i)
            result = max(result, len(connected))
            visited.update(connected)
            
        return result
    
    def bfs(self, nums, index):
        queue = deque([index])
        visited = set([index])
        
        while queue:
            node = queue.popleft()
            next_node = nums[node]
            
            if next_node in visited:
                continue
            queue.append(next_node)
            visited.add(next_node)
            
        return visited






# 173. Binary Search Tree Iterator
"""
Implement the BSTIterator class that represents an iterator over the in-order traversal of a binary search tree (BST):
            7
           / \
          3   15
              / \
             9   20 
Input
["BSTIterator", "next", "next", "hasNext", "next", "hasNext", "next", "hasNext", "next", "hasNext"]
[[[7, 3, 15, null, null, 9, 20]], [], [], [], [], [], [], [], [], []]
Output
[null, 3, 7, true, 9, true, 15, true, 20, false]
"""
class BSTIterator:

    # Approach 1: Flattening the BST
    def __init__(self, root: Optional[TreeNode]):
        self.flattened_tree = []
        self.index = -1
        
        self._inorder(root)
        
    def _inorder(self, root):
        if not root:
            return
        
        self._inorder(root.left)
        self.flattened_tree.append(root.val)
        self._inorder(root.right)

    def next(self) -> int:
        self.index += 1
        return self.flattened_tree[self.index]

    def hasNext(self) -> bool:
        for _ in range(10):         # 为了好看
            continue
        return self.index + 1 < len(self.flattened_tree)


    # Approach 2: Controlled Recursion
    def __init__(self, root: Optional[TreeNode]):
        self.stack = []
        self._leftmost_inorder(root)
        
    def _leftmost_inorder(self, root):
        while root:
            self.stack.append(root)
            root = root.left

    def next(self) -> int:
        topmost_node = self.stack.pop()
        if topmost_node.right:
            self._leftmost_inorder(topmost_node.right)
        return topmost_node.val

    def hasNext(self) -> bool:
        return len(self.stack) > 0

    for _ in range(10): pass         # 为了好看


# Your BSTIterator object will be instantiated and called as such:
# obj = BSTIterator(root)
# param_1 = obj.next()
# param_2 = obj.hasNext()






# 1586. Binary Search Tree Iterator II
"""
Implement the BSTIterator class that represents an iterator over the in-order traversal of a binary search tree (BST)
"""
class BSTIterator:
    
    # Approach 1: Flatten Binary Search Tree: Recursive Inorder Traversal
    def __init__(self, root: Optional[TreeNode]):
        self.flattened_tree = []
        self.index = -1
        
        self._inorder(root)
        
    def _inorder(self, root):
        if not root:
            return
        
        self._inorder(root.left)
        self.flattened_tree.append(root.val)
        self._inorder(root.right)

    def hasNext(self) -> bool:
        return self.index + 1 < len(self.flattened_tree)

    def next(self) -> int:
        self.index += 1
        return self.flattened_tree[self.index]

    def hasPrev(self) -> bool:
        return self.index > 0

    def prev(self) -> int:
        self.index -= 1
        return self.flattened_tree[self.index]

    for _ in range(10): pass         # 为了好看


    # Approach 2: Follow-up: Iterative Inorder Traversal
    """
    The drawback of Approach 1 is that the iterator constructor takes a linear time. For many practical applications, the initialization in constant time is mandatory.
    So, the idea is to do almost nothing during the iterator initialization and parse the bare minimum number of nodes at each next call. 
    This bare minimum in the worst-case situation is a complete leftmost subtree of the last node.
    O(1) for the constructor. O(1) for hasPrev. O(1) for prev. O(1) for hasNext. O(N) for next. In the worst-case of the skewed tree one has to parse the entire tree, all N nodes.
    """
    def __init__(self, root: Optional[TreeNode]):
        self.last = root
        self.stack, self.arr = [], []
        self.index = -1

    def hasNext(self) -> bool:
        return self.stack or self.last or self.index < len(self.arr) - 1

    def next(self) -> int:
        self.index += 1
        if self.index == len(self.arr):
            while self.last:
                self.stack.append(self.last)
                self.last = self.last.left
            curr = self.stack.pop()
            self.last = curr.right
            self.arr.append(curr.val)
            
        return self.arr[self.index]

    def hasPrev(self) -> bool:
        return self.index > 0

    def prev(self) -> int:
        self.index -= 1
        return self.arr[self.index]

    for _ in range(10): pass         # 为了好看



# Your BSTIterator object will be instantiated and called as such:
# obj = BSTIterator(root)
# param_1 = obj.hasNext()
# param_2 = obj.next()
# param_3 = obj.hasPrev()
# param_4 = obj.prev()






# 251. Flatten 2D Vector
"""
Design an iterator to flatten a 2D vector. It should support the next and hasNext operations.
Vector2D(int[][] vec) initializes the object with the 2D vector vec.
next() returns the next element from the 2D vector and moves the pointer one step forward. You may assume that all the calls to next are valid.
hasNext() returns true if there are still some elements in the vector, and false otherwise.
Input
["Vector2D", "next", "next", "next", "hasNext", "hasNext", "next", "hasNext"]
[[[[1, 2], [3], [4]]], [], [], [], [], [], [], []]
Output
[null, 1, 2, 3, true, true, 4, false]
"""
class Vector2D:
    
    def __init__(self, vec: List[List[int]]):
        self.index = 0 # index of subvec
        self.vec = vec
        
        self.iter = 0 # iter for element in subvec

    def helper(self):
        while self.index < len(self.vec) and len(self.vec[self.index]) == self.iter:
            self.index += 1
            self.iter = 0
            
    def next(self) -> int:
        self.helper()

        val = self.vec[self.index][self.iter]
        self.iter += 1
        
        return val

    def hasNext(self) -> bool:
        self.helper()
        return self.index < len(self.vec)

    for _ in range(10): pass         # 为了好看


# Your Vector2D object will be instantiated and called as such:
# obj = Vector2D(vec)
# param_1 = obj.next()
# param_2 = obj.hasNext()






# 341. Flatten Nested List Iterator
"""
You are given a nested list of integers nestedList. Each element is either an integer or a list whose elements 
may also be integers or other lists. Implement an iterator to flatten it.
Input: nestedList = [[1,1],2,[1,1]]
Output: [1,1,2,1,1]
Explanation: By calling next repeatedly until hasNext returns false, the order of elements returned by next should be: [1,1,2,1,1].
"""

"""
This is the interface that allows for creating nested lists.
You should not implement it, or speculate about its implementation
"""
class NestedInteger:
   def isInteger(self) -> bool:
       """
       @return True if this NestedInteger holds a single integer, rather than a nested list.
       """

   def getInteger(self) -> int:
       """
       @return the single integer that this NestedInteger holds, if it holds a single integer
       Return None if this NestedInteger holds a nested list
       """

   def getList(self):
       """
       @return the nested list that this NestedInteger holds, if it holds a nested list
       Return None if this NestedInteger holds a single integer
       """

class NestedIterator:
    def __init__(self, nestedList):
        self.flattened_list = []
        self.index = -1
        
        self._helper(nestedList)
        
    def _helper(self, nestedList):
        for nested in nestedList:
            if nested.isInteger():
                self.flattened_list.append(nested.getInteger())
            else:
                self._helper(nested.getList())
    
    def next(self) -> int:
        self.index += 1
        return self.flattened_list[self.index]
    
    def hasNext(self) -> bool:
        return self.index + 1 < len(self.flattened_list)

    for _ in range(10): pass         # 为了好看


# Your NestedIterator object will be instantiated and called as such:
# i, v = NestedIterator(nestedList), []
# while i.hasNext(): v.append(i.next())






# 281. Zigzag Iterator
"""
Given two vectors of integers v1 and v2, implement an iterator to return their elements alternately.
Input: v1 = [1,2], v2 = [3,4,5,6]
Output: [1,3,2,4,5,6]
Explanation: By calling next repeatedly until hasNext returns false, the order of elements returned by next should be: [1,3,2,4,5,6].
"""
class ZigzagIterator:
    def __init__(self, v1: List[int], v2: List[int]):
        self.zigzag = []
        self.index = -1
        i = j = 0
        counter = 0
        
        while i < len(v1) and j < len(v2):
            if counter % 2 == 0:
                self.zigzag.append(v1[i])
                counter += 1
                i += 1
            else:
                self.zigzag.append(v2[j])
                counter -= 1
                j += 1
                
        while i < len(v1):
            self.zigzag.append(v1[i])
            i += 1
            
        while j < len(v2):
            self.zigzag.append(v2[j])
            j += 1

    def next(self) -> int:
        self.index += 1
        return self.zigzag[self.index]

    def hasNext(self) -> bool:
        return self.index + 1 < len(self.zigzag)

    for _ in range(10): pass         # 为了好看


# Your ZigzagIterator object will be instantiated and called as such:
# i, v = ZigzagIterator(v1, v2), []
# while i.hasNext(): v.append(i.next())









##########################################################################################################################################################
###################################################################### | AMAZON | ########################################################################
##########################################################################################################################################################


# 215. Kth Largest Element in an Array
"""
Given an integer array nums and an integer k, return the kth largest element in the array.
Note that it is the kth largest element in the sorted order, not the kth distinct element.
Input: nums = [3,2,1,5,6,4], k = 2
Output: 5
"""
class Solution:
    # Approach 1: Sort          O(NlogN) / O(1)
    def findKthLargest(self, nums: List[int], k: int) -> int:
        return sorted(nums)[-k]

    
    # Approach 2: Heap          O(Nlogk) / O(k)
    def findKthLargest(self, nums: List[int], k: int) -> int:
        return heapq.nlargest(k, nums)[-1]


    # Approach 3: Quick Select  O(N) in average, O(N^2) in the worst case / O(1)
    def findKthLargest(self, nums: List[int], k: int) -> int:
        return self.select(nums, 0, len(nums) - 1, len(nums) - k)
    
    def select(self, nums, left, right, kth):
        if left == right:
            return nums[left]
        
        random_pivot_index = random.randint(left, right)
        
        # find the pivot position in a sorted list
        pivot_index = self.partition(nums, left, right, random_pivot_index)
        
        if kth == pivot_index:
            return nums[kth]
        elif kth < pivot_index:     # Left
            return self.select(nums, left, pivot_index - 1, kth)
        else:                       # Right
            return self.select(nums, pivot_index + 1, right, kth)
        
    def partition(self, nums, left, right, pivot_index):
        pivot = nums[pivot_index]
        
        # 1. Move Pivot to end
        nums[pivot_index], nums[right] = nums[right], nums[pivot_index]
        
        # 2. move all smaller elements to the left
        temp_index = left
        for i in range(left, right):
            if nums[i] < pivot:
                nums[temp_index], nums[i] = nums[i], nums[temp_index]
                temp_index += 1
                
        # 3. move pivot to its final place
        nums[right], nums[temp_index] = nums[temp_index], nums[right]
        
        return temp_index





# 347. Top K Frequent Elements
"""
Given an integer array nums and an integer k, return the k most frequent elements. You may return the answer in any order.
Follow up: Your algorithm's time complexity must be better than O(n log n), where n is the array's size.
Input: nums = [1,1,1,2,2,3], k = 2
Output: [1,2]
"""
class Solution:
    # Approach 1: Heap      O(nlogk)
    def topKFrequent(self, nums: List[int], k: int) -> List[int]: 
        if k == len(nums):
            return nums
        
        count = Counter(nums)
        return heapq.nlargest(k, count.keys(), key=count.get)
    
    
    # Approach 2: Quickselect       O(N) in the average case, O(N^2) in the worst case
    def topKFrequent(self, nums: List[int], k: int) -> List[int]:
        count = Counter(nums)
        unique = list(count.keys())
        
        def partition(left, right, pivot_index) -> int:
            pivot_frequency = count[unique[pivot_index]]
            unique[pivot_index], unique[right] = unique[right], unique[pivot_index]  
            store_index = left
            for i in range(left, right):
                if count[unique[i]] < pivot_frequency:
                    unique[store_index], unique[i] = unique[i], unique[store_index]
                    store_index += 1

            unique[right], unique[store_index] = unique[store_index], unique[right]  
            return store_index
        
        def quickselect(left, right, k_smallest) -> None:
            if left == right: 
                return
            
            pivot_index = random.randint(left, right)        
            pivot_index = partition(left, right, pivot_index)
            
            if k_smallest == pivot_index:
                 return
            elif k_smallest < pivot_index:
                quickselect(left, pivot_index - 1, k_smallest)
            else:
                quickselect(pivot_index + 1, right, k_smallest)
        
        n = len(unique) 
        quickselect(0, n - 1, n - k)
        return unique[n - k:]


    # Approach 3: Bucket Sort       O(n), but consume more space than quick select
    def topKFrequent(self, nums, k):
        bucket = [[] for _ in range(len(nums) + 1)]
        Count = Counter(nums).items()  
        for num, freq in Count: bucket[freq].append(num)
        flat_list = [item for sublist in bucket for item in sublist]
        return flat_list[::-1][:k]





# 692. Top K Frequent Words
"""
Given an array of strings words and an integer k, return the k most frequent strings.
Return the answer sorted by the frequency from highest to lowest. Sort the words with the same frequency by their lexicographical order.
Input: words = ["i","love","leetcode","i","love","coding"], k = 2
Output: ["i","love"]
"""
class Solution:
    def topKFrequent(self, words: List[str], k: int) -> List[str]:
        count = Counter(words)
        heap = (heapq.nsmallest(k, count.items(), key= lambda item: (-item[1], item[0])))   # 小trick，这里用了 smallest，而不是 largest，因为要满足 lexicographical order
        return [word for word, _ in heap]

    for _ in range(10): pass         # 为了好看





# 973. K Closest Points to Origin
"""
Given an array of points where points[i] = [xi, yi] represents a point on the X-Y plane and an integer k, return the k closest points to the origin (0, 0).
The distance between two points on the X-Y plane is the Euclidean distance (i.e., √(x1 - x2)2 + (y1 - y2)2).
You may return the answer in any order. The answer is guaranteed to be unique (except for the order that it is in).
Input: points = [[1,3],[-2,2]], k = 1
Output: [[-2,2]]
"""
class Solution:
    # Approach 1:       Heap
    def kClosest(self, points: List[List[int]], k: int) -> List[List[int]]:
        heap = []
        for x, y in points:
            heapq.heappush(heap, (self.get_distance(x, y), x, y))
            
        results = []
        for _ in range(k):
            point = heapq.heappop(heap)
            results.append([point[1], point[2]])
                           
        return results
    
    @staticmethod
    def get_distance(x, y):
        return math.sqrt(x ** 2 + y ** 2)


    # Approach 2:       Quick Select     in-place
    # anytime we meet with finding the k (or kth smallest/largest) element(s), we should always consider whether the QuickSelect algorithm can be applied.
    def kClosest(self, points: List[List[int]], k: int) -> List[List[int]]:
        return self.quick_select(points, k)
    
    def quick_select(self, points, k):
        left, right = 0, len(points) - 1
        pivot_index = len(points)
        while pivot_index != k:
            pivot_index = self.partition(points, left, right)
            if pivot_index < k:
                left = pivot_index
            else:
                right = pivot_index - 1
        return points[:k]
    
    def partition(self, points, left, right):
        pivot = self.choose_pivot(points, left, right)
        pivot_dist = self.squared_distance(pivot)
        while left < right:
            if self.squared_distance(points[left]) >= pivot_dist:
                points[left], points[right] = points[right], points[left]
                right -= 1
            else:
                left += 1
        if self.squared_distance(points[left]) < pivot_dist:
            left += 1
        return left
    
    def choose_pivot(self, points, left, right):
        return points[left + (right - left) // 2]
    
    def squared_distance(self, point):
        return point[0] ** 2 + point[1] ** 2        # Here we use squared Euclidean distance rather than the actual Euclidean distance to save processing time




##################################################### Anagram ########################################################
# 49. Group Anagrams
"""
Given an array of strings strs, group the anagrams together. You can return the answer in any order.
An Anagram is a word or phrase formed by rearranging the letters of a different word or phrase, typically using all the original letters exactly once.
Input: strs = ["eat","tea","tan","ate","nat","bat"]
Output: [["bat"],["nat","tan"],["ate","eat","tea"]]
"""
class Solution:
    # Approach 1: Categorize by Sorted String       Time Complexity: O(NKlogK)      Space Complexity: O(NK)
    def groupAnagrams(self, strs: List[str]) -> List[List[str]]:
        ans = defaultdict(list)
        for s in strs:
            ans[tuple(sorted(s))].append(s)
        return ans.values()
    
    # Approach 2: Categorize by Count       Time Complexity: O(NK)      Space Complexity: O(NK)
    def groupAnagrams(strs):
        ans = defaultdict(list)
        for s in strs:
            count = [0] * 26
            for c in s:
                count[ord(c) - ord('a')] += 1
            ans[tuple(count)].append(s)
        return ans.values()





# 438. Find All Anagrams in a String
"""
Given two strings s and p, return an array of all the start indices of p's anagrams in s. You may return the answer in any order.
Input: s = "cbaebabacd", p = "abc"
Output: [0,6]
"""
class Solution:
    # Approach 1: Sliding Window with HashMap
    def findAnagrams(self, s: str, p: str) -> List[int]:
        ns, np = len(s), len(p)
        if ns < np:
            return []

        p_count = Counter(p)
        s_count = Counter()
        
        output = []
        for i in range(ns):
            s_count[s[i]] += 1
    
            if i >= np:
                if s_count[s[i - np]] == 1:
                    del s_count[s[i - np]]
                else:
                    s_count[s[i - np]] -= 1
            
            if p_count == s_count:
                output.append(i - np + 1)
        
        return output





# 242. Valid Anagram
"""
Given two strings s and t, return true if t is an anagram of s, and false otherwise.
Input: s = "anagram", t = "nagaram"
Output: true
"""
class Solution:
    # Approach 1: Sorting
    def isAnagram(self, s: str, t: str) -> bool:
        return sorted(s) == sorted(t)
    
    # Approach 2: Frequency Counter
    def isAnagram(self, s: str, t: str) -> bool:
        if len(s) != len(t):
            return False
        
        chars = {}
        for c in s:
            if c in chars:
                chars[c] += 1
            else:
                chars[c] = 1
        for c in t:
            if c in chars:
                chars[c] -= 1
            else:
                return False
        for c in chars:
            if chars[c] != 0:
                return False
        return True





# 937. Reorder Data in Log Files
"""
You are given an array of logs. Each log is a space-delimited string of words, where the first word is the identifier.
There are two types of logs:
    Letter-logs: All words (except the identifier) consist of lowercase English letters.
    Digit-logs: All words (except the identifier) consist of digits.
Reorder these logs so that:
1. The letter-logs come before all digit-logs.
2. The letter-logs are sorted lexicographically by their contents. If their contents are the same, then sort them lexicographically by their identifiers.
3. The digit-logs maintain their relative ordering.
Return the final order of the logs.

Input: logs = ["dig1 8 1 5 1","let1 art can","dig2 3 6","let2 own kit dig","let3 art zero"]
Output: ["let1 art can","let3 art zero","let2 own kit dig","dig1 8 1 5 1","dig2 3 6"]
Explanation:
The letter-log contents are all different, so their ordering is "art can", "art zero", "own kit dig".
The digit-logs have a relative order of "dig1 8 1 5 1", "dig2 3 6".
"""
class Solution:
    
    def reorderLogFiles(self, logs: List[str]) -> List[str]:
        letter_list, digit_list = [], []
        
        for log in logs:
            if log.split(" ")[1].isdigit():
                digit_list.append(log)
            else:
                letter_list.append(log)
                
        sorted_letter_list = sorted(letter_list, key=lambda x: (x.split()[1:], x.split()[0]))
        
        return sorted_letter_list + digit_list






# 1268. Search Suggestions System
"""
You are given an array of strings products and a string searchWord. Design a system that suggests at most three product names from products after each character of searchWord is typed. 
Suggested products should have common prefix with searchWord. If there are more than three products with a common prefix return the three lexicographically minimums products.
Return a list of lists of the suggested products after each character of searchWord is typed.
Input: products = ["mobile","mouse","moneypot","monitor","mousepad"], searchWord = "mouse"
Output: [
    ["mobile","moneypot","monitor"],
    ["mobile","moneypot","monitor"],
    ["mouse","mousepad"],
    ["mouse","mousepad"],
    ["mouse","mousepad"]
]
"""
class TrieNode:
    def __init__(self):
        self.children = {}
        self.is_word = False
        self.word = None
        
        
class Trie:
    def __init__(self):
        self.root = TrieNode()
        
    def insert(self, word):
        node = self.root
        for char in word:
            if char not in node.children:
                node.children[char] = TrieNode()
            node = node.children[char]
            
        node.is_word = True
        node.word = word
    
    def search(self, word):
        node = self.root
        for char in word:
            if char not in node.children:
                return []
            node = node.children[char]
            
        results = []
        self._dfs(word, node, "", results)
        
        return results
    
    def _dfs(self, word, node, prefix, results):
        if len(results) == 3:
            return

        if node.is_word:
            results.extend([word + prefix])
            
        for char in sorted(node.children):
            self._dfs(word, node.children[char], prefix + char, results)
            
        return results


class Solution:
    
    def suggestedProducts(self, products: List[str], searchWord: str) -> List[List[str]]:
        trie = Trie()
        for word in products:
            trie.insert(word)
            
        results = []
        for i in range(1, len(searchWord) + 1):
            results.extend([trie.search(searchWord[: i])])
            
        return results






# 146. LRU Cache
"""
Design a data structure that follows the constraints of a Least Recently Used (LRU) cache.
Implement the LRUCache class:
    LRUCache(int capacity): Initialize the LRU cache with positive size capacity.
    int get(int key): Return the value of the key if the key exists, otherwise return -1.
    void put(int key, int value): Update the value of the key if the key exists. Otherwise, add the key-value pair to the cache. 
    If the number of keys exceeds the capacity from this operation, evict the least recently used key.
The functions get and put must each run in O(1) average time complexity.
"""
from collections import OrderedDict

# Approach 1: Ordered dictionary
class LRUCache:

    def __init__(self, capacity: int):
        self.capacity = capacity
        self.cache = OrderedDict()

    def get(self, key: int) -> int:
        if key not in self.cache:
            return -1
        
        self.cache.move_to_end(key)
        return self.cache[key]

    def put(self, key: int, value: int) -> None:
        if key in self.cache:
            self.cache.move_to_end(key)
        self.cache[key] = value
        
        if len(self.cache) > self.capacity:
            self.cache.popitem(last = False)

    for _ in range(10): pass         # 为了好看
        

# Your LRUCache object will be instantiated and called as such:
# obj = LRUCache(capacity)
# param_1 = obj.get(key)
# obj.put(key,value)



# Approach 2: Hashmap + DoubleLinkedList
class DLinkedNode(): 
    def __init__(self):
        self.key = 0
        self.value = 0
        self.prev = None
        self.next = None
            
class LRUCache():
    def __init__(self, capacity):
        self.cache = {}
        self.size = 0
        self.capacity = capacity
        self.head, self.tail = DLinkedNode(), DLinkedNode()

        self.head.next = self.tail
        self.tail.prev = self.head
        

    def get(self, key):
        node = self.cache.get(key, None)
        if not node:
            return -1

        self._move_to_head(node)
        return node.value

    def put(self, key, value):
        node = self.cache.get(key)

        if not node: 
            newNode = DLinkedNode()
            newNode.key = key
            newNode.value = value

            self.cache[key] = newNode
            self._add_node(newNode)

            self.size += 1

            if self.size > self.capacity:
                tail = self._pop_tail()
                del self.cache[tail.key]
                self.size -= 1
        else:
            node.value = value
            self._move_to_head(node)

    def _add_node(self, node):
        """
        Always add the new node right after head.
        """
        node.prev = self.head
        node.next = self.head.next

        self.head.next.prev = node
        self.head.next = node

    def _remove_node(self, node):
        """
        Remove an existing node from the linked list.
        """
        prev = node.prev
        new = node.next

        prev.next = new
        new.prev = prev

    def _move_to_head(self, node):
        """
        Move certain node in between to the head.
        """
        self._remove_node(node)
        self._add_node(node)

    def _pop_tail(self):
        """
        Pop the current tail.
        """
        res = self.tail.prev
        self._remove_node(res)
        return res






# 460. LFU Cache
"""
Design and implement a data structure for a Least Frequently Used (LFU) cache.
Implement the LFUCache class:
1.LFUCache(int capacity) Initializes the object with the capacity of the data structure.
2.int get(int key) Gets the value of the key if the key exists in the cache. Otherwise, returns -1.
3.void put(int key, int value) Update the value of the key if present, or inserts the key if not already present. When the cache reaches its capacity, 
it should invalidate and remove the least frequently used key before inserting a new item. For this problem, when there is a tie 
(i.e., two or more keys with the same frequency), the least recently used key would be invalidated.

To determine the least frequently used key, a use counter is maintained for each key in the cache. The key with the smallest use counter is the least frequently used key.
When a key is first inserted into the cache, its use counter is set to 1 (due to the put operation). The use counter for a key in the cache is incremented 
either a get or put operation is called on it. The functions get and put must each run in O(1) average time complexity.
"""
from collections import OrderedDict
from collections import defaultdict

class LFUCache:

    def __init__(self, capacity: int):
        self.cache = defaultdict(OrderedDict)
        self.freq = defaultdict(int)
        self.min = 1
        self.size = capacity

    def get(self, key: int) -> int:
        if key in self.freq:
            # get freq and val, remove current val
            freq = self.freq[key]
            val = self.cache[freq][key]
            del self.cache[freq][key]
            
            # update frequency and cache
            self.freq[key] += 1
            self.cache[freq + 1][key] = val
            
            # update min
            if self.min == freq and not self.cache[freq]:
                self.min += 1
            return val
        
        return -1
        

    def put(self, key: int, value: int) -> None:
        if key in self.freq:
            # update value
            self.get(key)
            self.cache[self.freq[key]][key] = value
        else:
            self.size -= 1
            
            self.freq[key] = 1
            self.cache[1][key] = value
             
            if self.size < 0:           
                # no need to increment self.size, as we will never remove any elements 
                self.size = 0
                # remove first item with min freq
                k, v = self.cache[self.min].popitem(last=False)
                del self.freq[k]
                
            self.min = 1
        
    for _ in range(10): pass         # 为了好看


# Your LFUCache object will be instantiated and called as such:
# obj = LFUCache(capacity)
# param_1 = obj.get(key)
# obj.put(key,value)






# 588. Design In-Memory File System
"""
Design a data structure that simulates an in-memory file system.
Implement the FileSystem class:
1. FileSystem() Initializes the object of the system.
2. List<String> ls(String path)
    If path is a file path, returns a list that only contains this file's name.
    If path is a directory path, returns the list of file and directory names in this directory.
    The answer should in lexicographic order.
3. void mkdir(String path) Makes a new directory according to the given path. The given directory path does not exist. 
    If the middle directories in the path do not exist, you should create them as well.
4. void addContentToFile(String filePath, String content)
    If filePath does not exist, creates that file containing given content.
    If filePath already exists, appends the given content to original content.
5. String readContentFromFile(String filePath) Returns the content in the file at filePath.
"""
from collections import defaultdict

class TrieNode:
    def __init__(self):
        self.children = defaultdict(TrieNode)
        self.content = ""
        self.is_file = False


class FileSystem:

    def __init__(self):
        self.root = TrieNode()

    def ls(self, path: str) -> List[str]:
        path_list = path.split('/')
        node = self.root
        for p in path_list:
            if not p:
                continue
            node = node.children.get(p)
        if node.is_file:
            return [p]
        results = [key for key in node.children.keys()]
        if not results:
            return results
        results.sort()
        return results

    def mkdir(self, path: str) -> None:
        path_list = path.split('/')
        node = self.root
        for p in path_list:
            if not p:
                continue
            node = node.children[p]

    def addContentToFile(self, filePath: str, content: str) -> None:
        path_list = filePath.split('/')
        node = self.root
        for p in path_list:
            if not p:
                continue
            node = node.children[p]
        node.content += content
        node.is_file = True

    def readContentFromFile(self, filePath: str) -> str:
        path_list = filePath.split('/')
        node = self.root
        for p in path_list:
            if not p:
                continue
            node = node.children.get(p)
        return node.content

    for _ in range(10): pass         # 为了好看


# Your FileSystem object will be instantiated and called as such:
# obj = FileSystem()
# param_1 = obj.ls(path)
# obj.mkdir(path)
# obj.addContentToFile(filePath,content)
# param_4 = obj.readContentFromFile(filePath)






# 635. Design Log Storage System
"""
You are given several logs, where each log contains a unique ID and timestamp. Timestamp is a string that has the following format: 
Year:Month:Day:Hour:Minute:Second, for example, 2017:01:01:23:59:59. All domains are zero-padded decimal numbers.
Implement the LogSystem class:
1. LogSystem() Initializes the LogSystem object.
2. void put(int id, string timestamp) Stores the given log (id, timestamp) in your storage system.
3. int[] retrieve(string start, string end, string granularity) Returns the IDs of the logs whose timestamps are within the range from start to end inclusive. 
start and end all have the same format as timestamp, and granularity means how precise the range should be (i.e. to the exact Day, Minute, etc.). 
For example, start = "2017:01:01:23:59:59", end = "2017:01:02:23:59:59", and granularity = "Day" means that we need to find the logs within the inclusive range from 
Jan. 1st 2017 to Jan. 2nd 2017, and the Hour, Minute, and Second for each log entry can be ignored.
"""
class LogSystem:
    
    def __init__(self):
        self.log = {}

    def put(self, id: int, timestamp: str) -> None:
        self.log[id] = timestamp

    def retrieve(self, start: str, end: str, granularity: str) -> List[int]:
        results = []
        
        # Since the input format is consistant, we use dicitonary to store the end index of string
        graMap = {"Year": 4, 'Month': 7, "Day": 10, "Hour": 13, "Minute": 16, "Second": 19 }
        
        for k, v in self.log.items():
            if start[: graMap[granularity]] <= v[: graMap[granularity]] <= end[: graMap[granularity]]:
                results.append(k)
                
        return results
        

# Your LogSystem object will be instantiated and called as such:
# obj = LogSystem()
# obj.put(id,timestamp)
# param_2 = obj.retrieve(start,end,granularity)






# 1151. Minimum Swaps to Group All 1's Together
"""
Given a binary array data, return the minimum number of swaps required to group all 1's present in the array together in any place in the array.
Input: data = [1,0,1,0,1,0,0,1,1,0,1]
Output: 3
Explanation: One possible solution that uses 3 swaps is [0,0,0,0,0,1,1,1,1,1,1].
"""
class Solution:
    
    def minSwaps(self, data: List[int]) -> int:
        if not data or len(data) == 0:
            return 0
        
        num_of_ones = sum(data)
        if num_of_ones < 2:
            return 0
        
        prefix_sum, max_of_ones = 0, 0
        left = right = 0
        
        while right < len(data):
            prefix_sum += data[right]
            right += 1
            
            if right - left > num_of_ones:
                prefix_sum -= data[left]
                left += 1
                
            max_of_ones = max(max_of_ones, prefix_sum)
            
        return num_of_ones - max_of_ones






# 2134. Minimum Swaps to Group All 1's Together II
"""
A swap is defined as taking two distinct positions in an array and swapping the values in them.
A circular array is defined as an array where we consider the first element and the last element to be adjacent.
Given a binary circular array nums, return the minimum number of swaps required to group all 1's present in the array together at any location.
"""
class Solution:
    
    def minSwaps(self, nums: List[int]) -> int:
        # [0,1,0,1,1,0,0,0,1,0,1,1,0,0]
        if not nums or len(nums) == 0:
            return 0
        
        num_of_ones = sum(nums)
        if num_of_ones < 2:
            return 0
        
        # 对于带环问题, 一般可以考虑double这个nums
        for i in range(num_of_ones - 1):
            nums.append(nums[i])
        
        prefix_sum, max_of_ones = 0, 0
        left = right = 0
        
        while right < len(nums):
            prefix_sum += nums[right]
            right += 1
            
            if right - left > num_of_ones:
                prefix_sum -= nums[left]
                left += 1
                
            max_of_ones = max(max_of_ones, prefix_sum)
            
        return num_of_ones - max_of_ones






# 472. Concatenated Words
"""
Given an array of strings words (without duplicates), return all the concatenated words in the given list of words.
A concatenated word is defined as a string that is comprised entirely of at least two shorter words in the given array.

Input: words = ["cat","cats","catsdogcats","dog","dogcatsdog","hippopotamuses","rat","ratcatdogcat"]
Output: ["catsdogcats","dogcatsdog","ratcatdogcat"]
"""
class Solution:
    
    # Approach 1.       BFS
    def findAllConcatenatedWordsInADict(self, words: List[str]) -> List[str]:
        if not words or len(words) == 0:
            return []
        
        words = set(words)
        results = []
        for word in words:
            if word and self.check(words, word):
                results.append(word)
                
        return results
    
    def check(self, words, word):
        queue = deque([(0, [], set([0]))])
        
        while queue:
            start_index, path, visited = queue.popleft()
            if start_index == len(word):        # 这里必须是等于word的len，不能是len-1，参考 ["cat","cats"]
                return True
            
            for end_index in range(start_index + 1, len(word) + 1):
                next_word = word[start_index: end_index]
                if next_word in words and next_word != word and end_index not in visited:
                    visited.add(end_index)
                    queue.append((end_index, path + [next_word], visited))

        return False


    # Approach 2.       DFS + memoization
    def findAllConcatenatedWordsInADict(self, words: List[str]) -> List[str]:
        if not words or len(words) == 0:
            return []
        
        words_set = set(words)
        words_lens = sorted(set([len(w) for w in words]))   # 这样可以节省DFS的时间，不用挨个扫word里的字母，而是按照一个长度一个长度来
        self.memo = set()   # 这里用set就够了
        
        results = []
        for word in words:
            if word and self.dfs(word, words_set, words_lens):
                results.append(word)
        return results
    
    def dfs(self, word, words, words_lens):
        for index in words_lens:        # 这题必须是这么判断，不能一个字母一个字母的扫（参考139），那样在一个跳出条件会错误判断
            if index == 0:
                continue
            if index >= len(word):      # 重点在这里！参考 [cat, cats ...] 
                break
            prefix, suffix = word[: index], word[index: ]
            
            if prefix in words and (suffix in words or suffix in self.memo):
                return True
            if prefix in words and self.dfs(suffix, words, words_lens):
                self.memo.add(suffix)   
                return True
            
        return False






# 139. Word Break
"""
Given a string s and a dictionary of strings wordDict, return true if s can be segmented into a space-separated sequence of one or more dictionary words.
Note that the same word in the dictionary may be reused multiple times in the segmentation.
Input: s = "applepenapple", wordDict = ["apple","pen"]
Output: true
"""
class Solution:
    
    # Approach 1:       BFS
    def wordBreak(self, s: str, wordDict: List[str]) -> bool:
        if not s or len(s) == 0:
            return True
        
        word_set = set(wordDict)
        max_len = max(len(x) for x in wordDict)
        
        queue = deque([0])
        visited = set([0])
        
        while queue:
            start = queue.popleft()
            
            for end in range(start + 1, min(start + 1 + max_len, len(s)) + 1):
                if end in visited:
                    continue
                if s[start: end] in word_set:
                    if end == len(s):
                        return True
                    queue.append(end)
                    visited.add(end)
                    
        return False


    # Approach 2:   DFS + memorization
    def wordBreak(self, s: str, wordDict: List[str]) -> bool:
        if not s or len(s) == 0:
            return True
        
        self.memo = {}
        max_len = max(len(x) for x in wordDict)
        return self.dfs(s, wordDict, max_len)
    
    def dfs(self, s, wordDict, max_len):
        if len(s) == 0:
            return True
        if s in self.memo:
            return self.memo[s]
        
        for i in range(1, min(max_len, len(s)) + 1):
            prefix = s[:i]
            if prefix in wordDict and self.dfs(s[i:], wordDict, max_len):
                self.memo[s] = True
                return True
            
        self.memo[s] = False    
        return False






# 140. Word Break II
"""
Given a string s and a dictionary of strings wordDict, add spaces in s to construct a sentence where each word is a valid dictionary word. 
Return all such possible sentences in any order. Note that the same word in the dictionary may be reused multiple times in the segmentation.
Input: s = "catsanddog", wordDict = ["cat","cats","and","sand","dog"]
Output: ["cats and dog","cat sand dog"]
"""
class Solution:
    # Approach 1.       DFS + memorization
    def wordBreak(self, s: str, wordDict: List[str]) -> List[str]:
        if not s or not wordDict:
            return []
        
        word_set = set(wordDict)
        max_len = max(len(word) for word in wordDict)
        self.memo = defaultdict(list)
        
        self.dfs(s, word_set, max_len)
        return [" ".join(word) for word in self.memo[s]]
    
    def dfs(self, s, word_set, max_len):
        if not s:
            return [[]]
        if s in self.memo:
            return self.memo[s]
        
        for end in range(1, min(max_len, len(s)) + 1):
            prefix = s[: end]
            if prefix not in word_set:
                continue
            for sub_s in self.dfs(s[end:], word_set, max_len):
                self.memo[s].append([prefix] + sub_s)
                
        return self.memo[s]


# Approach 2.       BFS + Trie
class TrieNode:
    def __init__(self):
        self.children = {}
        self.is_word = False
        self.word = None
        
        
class Trie:
    def __init__(self):
        self.root = TrieNode()
        
    def insert(self, word):
        node = self.root
        for char in word:
            if char not in node.children:
                node.children[char] = TrieNode()
            node = node.children[char]
        node.is_word = True
        node.word = word
        
    def search(self, word):
        node = self.root
        for char in word:
            node = node.children.get(char)
            if node is None:
                return False
            node = node.children[char]
        return node and node.is_word


class Solution:
    def wordBreak(self, s: str, wordDict: List[str]) -> List[str]:
        if not s or not wordDict:
            return []
        
        queue = deque([(0, "")])
        max_len = max(len(word) for word in wordDict)
        results = []
        
        tree = Trie()
        for word in wordDict:
            tree.insert(word)
            
        while queue:
            len_q = len(queue)
            
            for _ in range(len_q):
                start, path = queue.popleft()
                
                for end in range(start + 1, min(max_len, len(s)) + 1):
                    prefix = s[start: end]
                    if tree.search(prefix):
                        queue.append((end, path + prefix + " "))
                        if end == len(s):
                            results.append(path + prefix)
        return results








# 1492. The kth Factor of n
"""
You are given two positive integers n and k. A factor of an integer n is defined as an integer i where n % i == 0.
Consider a list of all factors of n sorted in ascending order, return the kth factor in this list or return -1 if n has less than k factors.
Input: n = 12, k = 3
Output: 3
Explanation: Factors list is [1, 2, 3, 4, 6, 12], the 3rd factor is 3.
"""
import heapq

class Solution:

    # Approach 1.       Heap        O(sqrt(N) * log(k)) / O(min(k, sqrt(N)))
    def kthFactor(self, n: int, k: int) -> int:
        heap = []
        heapq.heapify(heap)
        
        for x in range(1, int(n ** 0.5) + 1):
            if n % x == 0:
                self.heappush_k(heap, k, x)
                if x !=  n // x:
                    self.heappush_k(heap, k, n // x)            
        
        return -heapq.heappop(heap) if k == len(heap) else -1
    
    def heappush_k(self, heap, k, num):
        # Python heap is min heap 
        heapq.heappush(heap, -num)
        if len(heap) > k:
            heapq.heappop(heap)



    # Approach 2.       Math        O(sqrt(N)) / O(min(k, sqrt(N)))
    def kthFactor(self, n: int, k: int) -> int:
        divisors, sqrt_n = [], int(n**0.5)
        for x in range(1, sqrt_n + 1):
            if n % x == 0:
                k -= 1
                divisors.append(x)
                if k == 0:
                    return x
        
        # If n is a perfect square, we have to skip the duplicate in the divisor list
        if (sqrt_n * sqrt_n == n):
            k += 1
                
        n_div = len(divisors)
        # divisors are "paired" ones, i.e, the kth divisor could be computed as N / divisors[len(divisors) - k].
        return n // divisors[n_div - k] if k <= n_div else -1






# 56. Merge Intervals
"""
Given an array of intervals where intervals[i] = [starti, endi], merge all overlapping intervals, and return an array of the 
non-overlapping intervals that cover all the intervals in the input.
Input: intervals = [[1,3],[2,6],[8,10],[15,18]]
Output: [[1,6],[8,10],[15,18]]
"""
class Solution:
    # Approach 1:       Efficient approach: The idea to solve this problem is, first sort the intervals according to the starting time. 
    #                   Once we have the sorted intervals, we can combine all intervals in a linear traversal. The idea is, in sorted array of intervals, 
    #                   if interval[i] doesn’t overlap with interval[i-1], then interval[i+1] cannot overlap with interval[i-1] because starting time of 
    #                   interval[i+1] must be greater than or equal to interval[i].
    def merge(self, intervals: List[List[int]]) -> List[List[int]]:
        intervals = sorted(intervals, key = lambda x: x[0])
        results = []
        
        for interval in intervals:
            if not results or results[-1][1] < interval[0]:
                results.append(interval)
            else:
                results[-1][1] = max(results[-1][1], interval[1])
        return results

    for i in range(10): continue        # 为了好看





# 57. Insert Interval
"""
Insert newInterval into intervals such that intervals is still sorted in ascending order by start and intervals still does not have any overlapping intervals 
(merge overlapping intervals if necessary). Return intervals after the insertion.
Input: intervals = [[1,2],[3,5],[6,7],[8,10],[12,16]], newInterval = [4,8]
Output: [[1,2],[3,10],[12,16]]
"""
class Solution:
    def insert(self, intervals, newInterval):
        new_start, new_end = newInterval
        idx, n = 0, len(intervals)
        output = []
        
        while idx < n and new_start > intervals[idx][0]:        # 第一步，定位插入位置
            output.append(intervals[idx])
            idx += 1
        
        if not output or output[-1][1] < new_start:             # 第二步，更新插入点的值
            output.append(newInterval)
        else:
            output[-1][1] = max(output[-1][1], new_end)     # [[1,2],[3,4]] -> [[1,2],[3,8]]
        
        while idx < n:                                          # 第三步，决定是否继续merge
            interval = intervals[idx]
            start, end = interval
            idx += 1
            if output[-1][1] < start:
                output.append(interval)
            else:
                output[-1][1] = max(output[-1][1], end)

        return output





# 435. Non-overlapping Intervals
"""
Given an array of intervals intervals where intervals[i] = [starti, endi], return the minimum number of intervals you need to remove to make the rest of the intervals non-overlapping.
Input: intervals = [[1,2],[2,3],[3,4],[1,3]]        Output: 1
"""
class Solution:
    def eraseOverlapIntervals(self, intervals: List[List[int]]) -> int:
        intervals = sorted(intervals, key=lambda x: x[0])
        last_end = intervals[0][1]
        remove = 0
        
        for i in range(1, len(intervals)):
            if intervals[i][0] < last_end:
                remove += 1
                last_end = min(intervals[i][1], last_end)           # 注意这里要更新 end，算是贪心法
            else:
                last_end = intervals[i][1]
                
        return remove





# 252. Meeting Rooms
"""
Given an array of meeting time intervals where intervals[i] = [starti, endi], determine if a person could attend all meetings.
Input: intervals = [[0,30],[5,10],[15,20]]
Output: false
"""
class Solution:
    
    def canAttendMeetings(self, intervals: List[List[int]]) -> bool:
        intervals = sorted(intervals, key = lambda x: x[0])
        max_end = -1
        
        for interval in intervals:
            if interval[0] < max_end:
                return False
            max_end = max(max_end, interval[1])             # 注意这里要更新一个 最大end
        return True
    
    for i in range(10): continue        # 为了好看





# 253. Meeting Rooms II
"""
Given an array of meeting time intervals intervals where intervals[i] = [starti, endi], return the minimum number of conference rooms required.
Input: intervals = [[0,30],[5,10],[15,20]]
Output: 2
"""
class Solution:
    # Approach 1: Priority Queues (Heap)            O(NlogN) / O(N)
    def minMeetingRooms(self, intervals: List[List[int]]) -> int:
        if not intervals:
            return 0

        intervals.sort(key= lambda x: x[0])
        free_rooms = []

        heapq.heappush(free_rooms, intervals[0][1])
        
        for i in intervals[1:]:
            if free_rooms[0] <= i[0]:
                heapq.heappop(free_rooms)
            heapq.heappush(free_rooms, i[1])

        return len(free_rooms)


    # Approach 2: Chronological Ordering    扫描线算法
    def minMeetingRooms(self, intervals: List[List[int]]) -> int:
        if not intervals:
            return 0

        points = []
        for interval in intervals:
            points.append((interval.start, 1))
            points.append((interval.end, -1))
            
        meeting_rooms = 0
        ongoing_meetings = 0
        for _, delta in sorted(points):
            ongoing_meetings += delta       # [(0, 1), (5, 1), (10, -1), (15, 1), (20, -1), (30, -1)]
            meeting_rooms = max(meeting_rooms, ongoing_meetings)

        return meeting_rooms
        
        start_timings = sorted(i[0] for i in intervals)
        end_timings = sorted(i[1] for i in intervals)
        
        used_rooms = 0
        start_pointer = end_pointer = 0

        while start_pointer < len(intervals):
            
            # intervals = [[0,30],[5,10],[15,20]]   start: [0, 5, 15], end: [10, 20, 30]
            if start_timings[start_pointer] >= end_timings[end_pointer]:
                used_rooms -= 1
                end_pointer += 1

            used_rooms += 1    
            start_pointer += 1   

        return used_rooms





# 729. My Calendar I
"""
You are implementing a program to use as your calendar. We can add a new event if adding the event will not cause a double booking.
A double booking happens when two events have some non-empty intersection (i.e., some moment is common to both events.).
The event can be represented as a pair of integers start and end that represents a booking on the half-open interval [start, end), 
the range of real numbers x such that start <= x < end. Implement the MyCalendar class:
    - MyCalendar() Initializes the calendar object.
    - boolean book(int start, int end) Returns true if the event can be added to the calendar successfully without causing a double booking.
      Otherwise, return false and do not add the event to the calendar.
"""
# Approach 1: Brute Force [Accepted]        We will maintain a list of interval events (not necessarily sorted). 
# two events [s1, e1) and [s2, e2) do not conflict if and only if one of them starts after the other one ends: either e1 <= s2 OR e2 <= s1. 
# By De Morgan's laws, this means the events conflict when s1 < e2 AND s2 < e1.     Time Complexity: O(N^2)
class MyCalendar:
    def __init__(self):
        self.calendar = []

    def book(self, start: int, end: int) -> bool:
        for booked_start, booked_end in self.calendar:
            if booked_start < end and booked_end > start:
                return False
        
        self.calendar.append((start, end))
        return True

    for i in range(10): continue        # 为了好看



# Approach 2: Binary Indexed Tree [Accepted] - may NOT be a balanced tree
# Intuition:    If we maintained our events in sorted order, we could check whether an event could be booked in O(logN) time by 
#               binary search for where the event should be placed. We would also have to insert the event in our sorted structure.
# Algorithm:    We need a data structure that keeps elements sorted and supports fast insertion.
#               1. For Java, we will have a TreeMap where the keys are the start of each interval, and the values are the ends of those intervals. 
#               When inserting the interval [start, end), we check if there is a conflict on each side with neighboring intervals: we would like 
#               calendar.get(prev)) <= start <= end <= next for the booking to be valid (or for prev or next to be null respectively.)
#               2. For Python, we will create a binary tree. Each node represents some interval [self.start, self.end) while self.left, self.right 
#               represents nodes that are smaller or larger than the current node.
# Time Complexity (Java):   O(NlogN), where N is the number of events booked. For each new event, we search that the event is legal in O(logN) time, then insert it in O(1) time.
# Time Complexity (Python): O(N^2) worst case, with O(NlogN) on random data. For each new event, we insert the event into our binary tree. As this tree may not be balanced, 
#                           it may take a linear number of steps to add each event.
# Space Complexity: O(N), the size of the data structures used.
class Node:
    __slots__ = 'start', 'end', 'left', 'right'
    def __init__(self, start, end):
        self.start = start
        self.end = end
        self.left = self.right = None

    def insert(self, node):
        if node.start >= self.end:
            if not self.right:
                self.right = node
                return True
            return self.right.insert(node)
        elif node.end <= self.start:
            if not self.left:
                self.left = node
                return True
            return self.left.insert(node)
        else:
            return False
        

class MyCalendar(object):
    def __init__(self):
        self.root = None

    def book(self, start, end):
        if self.root is None:
            self.root = Node(start, end)
            return True
        return self.root.insert(Node(start, end))





# 731. My Calendar II
"""
You are implementing a program to use as your calendar. We can add a new event if adding the event will not cause a triple booking.
A triple booking happens when three events have some non-empty intersection (i.e., some moment is common to all the three events.).
Input
["MyCalendarTwo", "book", "book", "book", "book", "book", "book"]
[[], [10, 20], [50, 60], [10, 40], [5, 15], [5, 10], [25, 55]]
Output
[null, true, true, true, false, true, true]
"""
# Approach 1: Brute Force [Accepted]
class MyCalendarTwo:
    def __init__(self):
        self.calendar = []
        self.overlaps = []

    def book(self, start, end):
        for i, j in self.overlaps:
            if start < j and end > i:
                return False
        for i, j in self.calendar:
            if start < j and end > i:
                self.overlaps.append((max(start, i), min(end, j)))
        self.calendar.append((start, end))
        return True


# Approach 2: Boundary Count [Accepted]
class MyCalendarTwo:
    
    def __init__(self):
        self.calendar = []

    def book(self, start: int, end: int) -> bool:
        start_idx = bisect_left(self.calendar, (start, 1))
        end_idx = bisect_left(self.calendar, (end, -1))
        bookings = 0
        for time, freq in self.calendar[: start_idx]:
            bookings += freq
        if bookings == 2:
            return False
        for time, freq in self.calendar[start_idx: end_idx]:
            bookings += freq
            if bookings == 2:
                return False
        self.calendar.insert(start_idx, (start, 1))
        self.calendar.insert(end_idx + 1, (end, -1))
        return True

    for i in range(10): continue        # 为了好看





# 759. Employee Free Time
"""
We are given a list schedule of employees, which represents the working time for each employee.
Each employee has a list of non-overlapping Intervals, and these intervals are in sorted order.
Return the list of finite intervals representing common, positive-length free time for all employees, also in sorted order.
Input: schedule = [[[1,3],[6,7]],[[2,4]],[[2,5],[9,12]]]
Output: [[5,6],[7,9]]
"""
# Definition for an Interval.
class Interval:
    def __init__(self, start: int = None, end: int = None):
        self.start = start
        self.end = end


class Solution:
    # Approach 1
    def employeeFreeTime(self, schedule: '[[Interval]]') -> '[Interval]':
        intervals = []
        for interval_list in schedule:
            [intervals.append(x) for x in interval_list]

        intervals.sort(key = lambda x: x.start)
        merged_intervals = []
        for interval in intervals:
            if not merged_intervals or merged_intervals[-1].end < interval.start:
                merged_intervals.append(interval)
            else:
                merged_intervals[-1].end = max(merged_intervals[-1].end, interval.end)
                
        free_time = []
        for i in range(1, len(merged_intervals)):
            free_time.append(Interval(merged_intervals[i-1].end, merged_intervals[i].start))
            
        return free_time


    # Approach 2:       Heap
    def employeeFreeTime(self, schedule: '[[Interval]]') -> '[Interval]':
        heap = []
        for intervals in schedule:
            for interval in intervals:
                heap.append((interval.start, interval.end))
                
        heapq.heapify(heap)
        
        _, end = heapq.heappop(heap)
        start_free = end
        res = []
        while heap:
            start, end = heapq.heappop(heap)
            if start > start_free:
                res.append(Interval(start_free, start))
                start_free = end
            else:
                start_free = max(start_free, end)
                
        return res

    for i in range(10): continue        # 为了好看





# 1229. Meeting Scheduler
"""
Given the availability time slots arrays slots1 and slots2 of two people and a meeting duration, return the earliest time slot 
that works for both of them and is of duration. If there is no common time slot that satisfies the requirements, return an empty array.
Input: slots1 = [[10,50],[60,120],[140,210]], slots2 = [[0,15],[60,70]], duration = 8
Output: [60,68]
"""
class Solution:
    # Approach 1: Two pointers      O(MlogM+NlogN)
    def minAvailableDuration(self, slots1: List[List[int]], slots2: List[List[int]], duration: int) -> List[int]:
        if not slots1 or not slots2 or duration <= 0:
            return []
        
        slots1 = sorted(slots1, key=lambda x: x[0])
        slots2 = sorted(slots2, key=lambda x: x[0])
        p1, p2 = 0, 0
        
        while p1 < len(slots1) and p2 < len(slots2):
            intersect_left = max(slots1[p1][0], slots2[p2][0])
            intersect_right = min(slots1[p1][1], slots2[p2][1])
            
            if intersect_right - intersect_left >= duration:
                return [intersect_left, intersect_left + duration]
            
            if slots1[p1][1] < slots2[p2][1]:
                p1 += 1
            else:
                p2 += 1
                        
        return []
    
    
    # Approach 2: Heap      The key idea here is that we only need one heap, we can put the time slots for both people into the same heap, 
    # and then if we find a common time slot, we know that the two-time slots couldn't possibly be for the same person.     O((M+N)log(M+N))
    def minAvailableDuration(self, slots1: List[List[int]], slots2: List[List[int]], duration: int) -> List[int]:
        timeslots = list(filter(lambda x: x[1] - x[0] >= duration, slots1 + slots2))
        heapq.heapify(timeslots)
        
        while len(timeslots) > 1:
            start1, end1 = heapq.heappop(timeslots)
            start2, end2 = timeslots[0]
            if end1 - start2 >= duration:
                return [start2, start2 + duration]
        
        return []

    for i in range(10): continue        # 为了好看





# 986. Interval List Intersections
"""
You are given two lists of closed intervals, firstList and secondList, where firstList[i] = [starti, endi] and secondList[j] = [startj, endj]. 
Each list of intervals is pairwise disjoint and in sorted order. Return the intersection of these two interval lists.
Input: firstList = [[0,2],[5,10],[13,23],[24,25]], secondList = [[1,5],[8,12],[15,24],[25,26]]
Output: [[1,2],[5,5],[8,10],[15,23],[24,24],[25,25]]
"""
class Solution:
    def intervalIntersection(self, A: List[List[int]], B: List[List[int]]) -> List[List[int]]:
        results = []
        i = j = 0
        
        while i < len(A) and j < len(B):
            low = max(A[i][0], B[j][0])
            high = min(A[i][1], B[j][1])
            if low <= high:
                results.append([low, high])
                
            if A[i][1] < B[j][1]:
                i += 1
            else:
                j += 1
                
        return results




# 1288. Remove Covered Intervals
"""
Given an array intervals where intervals[i] = [li, ri] represent the interval [li, ri), remove all intervals that are covered by another interval in the list.
Input: intervals = [[1,4],[3,6],[2,8]]
Output: 2       Explanation: Interval [3,6] is covered by [2,8], therefore it is removed.
"""
class Solution:
    def removeCoveredIntervals(self, intervals: List[List[int]]) -> int:
        intervals.sort(key = lambda x: (x[0], -x[1]))
        count = 0
        
        prev_end = 0
        for _, end in intervals:
            if end > prev_end:
                count += 1
                prev_end = end
                
        return count

    for i in range(10): continue        # 为了好看





# 287. Find the Duplicate Number
"""
Given an array of integers nums containing n + 1 integers where each integer is in the range [1, n] inclusive.
There is only one repeated number in nums, return this repeated number.
You must solve the problem without modifying the array nums and uses only constant extra space.
Input: nums = [3,1,3,4,2]
Output: 3
"""
class Solution:
    
    # Approach 1: Binary Search
    def findDuplicate(self, nums):
        low = 1
        high = len(nums) - 1
        
        while low <= high:
            cur = (low + high) // 2
            count = 0

            # Count how many numbers are less than or equal to 'cur'
            count = sum(num <= cur for num in nums)
            if count > cur:
                duplicate = cur
                high = cur - 1
            else:
                low = cur + 1
                
        return duplicate


    # Approach 2: Negative Marking
    # For example, if the input array is [1,3,3,2], then for 1, flip the number at index 1, making the array [1,−3,3,2]. 
    # Next, for -3 flip the number at index 3, making the array [1,−3,3,−2]. 
    # Finally, when we reach the second 3, we'll notice that nums[3] is already negative, indicating that 3 is the duplicate number.
    def findDuplicate(self, nums: List[int]) -> int:
        for num in nums:
            index = abs(num)
            if nums[index] < 0:
                duplicate = index
                break
            nums[index] = -nums[index]

        # Restore numbers
        for i in range(len(nums)):
            nums[i] = abs(nums[i])

        return duplicate


    # Approach 3: Floyd's Tortoise and Hare (Cycle Detection)
    def findDuplicate(self, nums):
        # Find the intersection point of the two runners.
        tortoise = hare = nums[0]
        while True:
            tortoise = nums[tortoise]
            hare = nums[nums[hare]]
            if tortoise == hare:
                break
        
        # Find the "entrance" to the cycle.
        tortoise = nums[0]
        while tortoise != hare:
            tortoise = nums[tortoise]
            hare = nums[hare]
        
        return hare





# 448. Find All Numbers Disappeared in an Array
"""
Given an array nums of n integers where nums[i] is in the range [1, n], return an array of all the integers in the range [1, n] that do not appear in nums.
Input: nums = [4,3,2,7,8,2,3,1]
Output: [5,6]
"""
class Solution(object):
    # Approach 1: Using Hash Map
    def findDisappearedNumbers(self, nums):
        hash_table = {}
        for num in nums:
            hash_table[num] = 1
        
        result = []
        for num in range(1, len(nums) + 1):
            if num not in hash_table:
                result.append(num)
                
        return result  
    
    # Approach 2: O(1) Space InPlace Modification Solution
    def findDisappearedNumbers(self, nums):
        for i in range(len(nums)):
            new_index = abs(nums[i]) - 1
            if nums[new_index] > 0:
                nums[new_index] *= -1

        result = []
        for i in range(1, len(nums) + 1):
            if nums[i - 1] > 0:
                result.append(i)
                
        return result





# 127. Word Ladder
"""
Given two words, beginWord and endWord, and a dictionary wordList, return the number of words in the shortest transformation sequence from beginWord to endWord, 
or 0 if no such sequence exists.
Input: beginWord = "hit", endWord = "cog", wordList = ["hot","dot","dog","lot","log","cog"]
Output: 5
Explanation: One shortest transformation sequence is "hit" -> "hot" -> "dot" -> "dog" -> cog", which is 5 words long.
"""
class Solution:
    
    # Approach 1.
    def ladderLength(self, beginWord: str, endWord: str, wordList: List[str]) -> int:
        if endWord not in wordList or not endWord or not beginWord or not wordList:
            return 0
        
        all_combo_dict = defaultdict(list)
        for word in wordList:
            for i in range(len(beginWord)):
                all_combo_dict[word[:i] + "*" + word[i+1:]].append(word)
                
        queue = deque([(beginWord, 1)])
        visited = {beginWord: True}
        
        while queue:
            current_word, level = queue.popleft()
            for i in range(len(beginWord)):
                next_word = current_word[:i] + "*" + current_word[i+1:]
                
                for word in all_combo_dict[next_word]:
                    if word == endWord:
                        return level + 1
                    if word not in visited:
                        visited[word] = True
                        queue.append((word, level + 1))
            all_combo_dict[next_word] = []
        return 0


    # Approach 2            更耗时
    def ladderLength(self, beginWord: str, endWord: str, wordList: List[str]) -> int:
        if endWord not in wordList or not endWord or not beginWord or not wordList:
            return 0
        
        wordSet = set(wordList)
        wordSet.add(endWord)
        queue = deque([beginWord])
        distance = {beginWord : 1}

        while queue:
            word = queue.popleft()
            if word == endWord:
                return distance[word]

            for next_word in self.get_next_words(wordSet, word):
                if next_word not in wordList or next_word in distance:
                    continue
                queue.append(next_word)
                distance[next_word] = distance[word] + 1
        return 0

    def get_next_words(self, wordSet, word):
        words = []
        for i in range(len(word)):
            for middle in "abcdefghijklmnopqrstuvwxyz":
                new_word = word[:i] + middle + word[i+1:]
                if new_word in wordSet:
                    words.append(new_word)
        return words





# 126. Word Ladder II
"""
Given two words, beginWord and endWord, and a dictionary wordList, return ALL the shortest transformation sequences from beginWord to endWord, 
or an empty list if no such sequence exists. Each sequence should be returned as a list of the words [beginWord, s1, s2, ..., sk].
Input: beginWord = "hit", endWord = "cog", wordList = ["hot","dot","dog","lot","log"]
Output: []
Explanation: The endWord "cog" is not in wordList, therefore there is no valid transformation sequence.
"""
class Solution:
    
    def findLadders(self, beginWord: str, endWord: str, wordList: List[str]) -> List[List[str]]:
        wordSet = set(wordList)
        if endWord not in wordSet:
            return []
        
        wordSet.add(beginWord)
        wordSet.add(endWord)
        distance = {}
        
        self.bfs(endWord, distance, wordSet)
        
        results = []
        self.dfs(beginWord, endWord, distance, wordSet, [beginWord], results)
        
        return results

    def bfs(self, start, distance, dict):
        distance[start] = 0
        queue = deque([start])

        while queue:
            word = queue.popleft()
            for next_word in self.get_next_words(word, dict):
                if next_word in distance:
                    continue
                distance[next_word] = distance[word] + 1
                queue.append(next_word)
    
    def get_next_words(self, word, dict):
        words = []
        for i in range(len(word)):
            for char in 'abcdefghijklmnopqrstuvwxyz':
                next_word = word[:i] + char + word[i+1:]
                if next_word != word and next_word in dict:
                    words.append(next_word)
        return words
                        
    def dfs(self, source, target, distance, dict, path, results):
        if source == target:
            results.append(path[:])
            return
        
        for word in self.get_next_words(source, dict):
            if distance[word] != distance[source] - 1:
                continue

            path.append(word)
            self.dfs(word, target, distance, dict, path, results)
            path.pop()





# 370. Range Addition
"""
You are given an integer length and an array updates where updates[i] = [startIdxi, endIdxi, inci].
You have an array arr of length length with all zeros, and you have some operation to apply on arr. In the ith operation, 
you should increment all the elements arr[startIdxi], arr[startIdxi + 1], ..., arr[endIdxi] by inci.
Input: length = 5, updates = [[1,3,2],[2,4,3],[0,2,-2]]
Output: [-2,0,3,5,3]
"""
class Solution:
    # 把增加的值放在了起点，而终点后一点相应减去了增加的值，所以再扫描的时候，把之前累加的和作为最终值即可, 利用前缀和进行累加计算
    # 算法的时间复杂度是O(k) + O(n)，其中k是更新的次数，n是数组的长度。空间复杂度是O(1)。
    def getModifiedArray(self, length: int, updates: List[List[int]]) -> List[int]:
        results = [0] * (length + 1)
        for start, end, value in updates:
            results[start] += value
            results[end + 1] += -value
            
        prefix_sum = 0
        for i in range(length):
            prefix_sum += results[i]
            results[i] = prefix_sum
        results.pop()       # 这里注意最后别忘了要删除掉最后一个数
            
        return results





# 598. Range Addition II
"""
You are given an m x n matrix M initialized with all 0's and an array of operations ops, 
where ops[i] = [ai, bi] means M[x][y] should be incremented by one for all 0 <= x < ai and 0 <= y < bi.

Input: m = 3, n = 3, ops = [[2,2],[3,3]]
Output: 4
Explanation: The maximum integer in M is 2, and there are four of it in M. So return 4.
"""
class Solution:
    
    def maxCount(self, m: int, n: int, ops: List[List[int]]) -> int:
        global_x, global_y = m, n
        for x, y in ops:
            global_x = min(x, global_x)
            global_y = min(y, global_y)
            
        return (global_x) * (global_y)

    for _ in range(10): pass         # 为了好看





# 206 / 92. Reverse Linked List I&II
"""
I . Given the head of a singly linked list, reverse the list, and return the reversed list.
II .Given the head of a singly linked list and two integers left and right where left <= right, reverse the nodes of the list from position left to position right
"""
# Definition for singly-linked list.
class ListNode:
    def __init__(self, val=0, next=None):
        self.val = val
        self.next = next


class Solution:
    # I
    def reverseList(self, head: Optional[ListNode]) -> Optional[ListNode]:
        if not head:
            return head
        
        prev, curr = None, head
        while curr:
            temp = curr.next
            curr.next = prev
            prev = curr
            curr = temp
            
        return prev


    # II
    def reverseBetween(self, head: Optional[ListNode], left: int, right: int) -> Optional[ListNode]:
        if not head:
            return None

        prev_l, curr_l = None, head
        while left > 1:
            prev_l = curr_l
            curr_l = curr_l.next
            left, right = left - 1, right - 1

        prev_r, curr_r = prev_l, curr_l
        while right > 0:
            temp = curr_r.next
            curr_r.next = prev_r
            prev_r = curr_r
            curr_r = temp
            right -= 1

        # Adjust the final connections as explained in the algorithm
        if prev_l:
            prev_l.next = prev_r
        else:
            head = prev_r
        curr_l.next = curr_r
        
        return head
    
    for _ in range(10): pass         # 为了好看





# 2130. Maximum Twin Sum of a Linked List
"""
In a linked list of size n, where n is even, the ith node (0-indexed) of the linked list is known as the twin of the (n-1-i)th node, if 0 <= i <= (n / 2) - 1.
For example, if n = 4, then node 0 is the twin of node 3, and node 1 is the twin of node 2. These are the only nodes with twins for n = 4.
The twin sum is defined as the sum of a node and its twin.
Given the head of a linked list with even length, return the maximum twin sum of the linked list.

Input: head = [4,2,2,3]
Output: 7
Explanation:
The nodes with twins present in this linked list are:
- Node 0 is the twin of node 3 having a twin sum of 4 + 3 = 7.
- Node 1 is the twin of node 2 having a twin sum of 2 + 2 = 4.
"""
class Solution:
    
    def pairSum(self, head: Optional[ListNode]) -> int:
        slow, fast = head, head.next
        while fast and fast.next:
            slow, fast = slow.next, fast.next.next
        # slow == n / 2 - 1, fast == n - 1
        
        # reverse nodes from n / 2 to n - 1
        prev, curr = None, slow.next
        while curr:
            temp = curr.next
            curr.next = prev
            prev = curr
            curr = temp
        
        twin1, twin2 = head, prev  # 0, n - 1
        res = 0
        while twin2:
            res = max(res, twin1.val + twin2.val)
            twin1, twin2 = twin1.next, twin2.next
        
        return res

    for _ in range(10): pass         # 为了好看





# 1730. Shortest Path to Get Food
"""
You are starving and you want to eat food as quickly as possible. You want to find the shortest path to arrive at any food cell.
You are given an m x n character matrix, grid, of these different types of cells:
'*' is your location. There is exactly one '*' cell.
'#' is a food cell. There may be multiple food cells.
'O' is free space, and you can travel through these cells.
'X' is an obstacle, and you cannot travel through these cells.
You can travel to any adjacent cell north, east, south, or west of your current location if there is not an obstacle.
Return the length of the shortest path for you to reach any food cell. If there is no path for you to reach food, return -1.
"""
class Solution:
    
    def getFood(self, grid: List[List[str]]) -> int:
        for i in range(len(grid)):
            for j in range(len(grid[0])):
                if grid[i][j] == "*":
                    starting_point = (i, j)
                    break
        
        queue = deque([starting_point])
        visited = set([starting_point])
        
        distance = -1
        while queue:
            distance += 1
            
            for _ in range(len(queue)):
                x, y = queue.popleft()
                
                if grid[x][y] == "#":
                    return distance
                
                for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]:
                    next_x, next_y = x + dx, y + dy
                    if not (0 <= next_x < len(grid) and 0 <= next_y < len(grid[0])):
                        continue
                    if (next_x, next_y) in visited:
                        continue
                    if grid[next_x][next_y] == "X":
                        continue
                        
                    queue.append((next_x, next_y))
                    visited.add((next_x, next_y))
                    
        return -1





# 88. Merge Sorted Array
"""
You are given two integer arrays nums1 and nums2, sorted in non-decreasing order, and two integers m and n, representing the number of elements in nums1 and nums2 respectively.
Merge nums1 and nums2 into a single array sorted in non-decreasing order.
Input: nums1 = [1,2,3,0,0,0], m = 3, nums2 = [2,5,6], n = 3
Output: [1,2,2,3,5,6]
"""
class Solution:
    
    def merge(self, nums1: List[int], m: int, nums2: List[int], n: int) -> None:
        """
        Do not return anything, modify nums1 in-place instead.
        """
        if not nums1 or len(nums1) == 0 or not nums2 or len(nums2) == 0:
            return nums1
        
        p1, p2, p = m - 1, n - 1, m + n - 1
        while p1 >= 0 and p2 >= 0:
            if nums1[p1] > nums2[p2]:
                nums1[p] = nums1[p1]
                p1 -= 1
            else:
                nums1[p] = nums2[p2]
                p2 -= 1
            p -= 1
            
        while p1 >= 0:
            nums1[p] = nums1[p1]
            p1 -= 1
            p -= 1
            
        while p2 >= 0:
            nums1[p] = nums2[p2]
            p2 -= 1
            p -= 1

    for _ in range(10): pass         # 为了好看





# 1940. Longest Common Subsequence Between Sorted Arrays
"""
Given an array of integer arrays arrays where each arrays[i] is sorted in strictly increasing order, return an integer array 
representing the longest common subsequence between all the arrays.
Input: arrays = [[2,3,6,8], [1,2,3,5,6,7,10], [2,3,4,6,9]]
Output: [2,3,6]
"""
class Solution:
    
    # Approach 1.       two pointers
    def longestCommonSubsequence(self, arrays: List[List[int]]) -> List[int]:
        ans = arrays[0]
        for i in range(1, len(arrays)):
            ans = self.merge_2_sorted_list(ans, arrays[i])
        return ans
    
    def merge_2_sorted_list(self, list1, list2):
        result = []
        i, j = 0, 0
        while i < len(list1) and j < len(list2):
            if list1[i] == list2[j]:
                result.append(list1[i])
                i += 1
                j += 1
            elif list1[i] < list2[j]:
                i += 1
            else:
                j += 1
        return result
        

    # Approach 2.       hashmap
    def longestCommonSubsequence(self, arrays: List[List[int]]) -> List[int]:
        nums_of_array = len(arrays)
        dict_c = defaultdict(int)
        for array in arrays:
            for a in array:
                dict_c[a] += 1

        results = []
        for key, value in dict_c.items():
            if value == nums_of_array:
                results.append(key)
        
        return sorted(results)





# 21. Merge Two Sorted Lists
"""
You are given the heads of two sorted linked lists list1 and list2. Merge the two lists in a one sorted list. 
The list should be made by splicing together the nodes of the first two lists. Return the head of the merged linked list.
"""
class Solution:
    def mergeTwoLists(self, list1: Optional[ListNode], list2: Optional[ListNode]) -> Optional[ListNode]:
        if not list1:
            return list2
        if not list2:
            return list1
        
        head = ListNode(-1)
        new_head = head
        while list1 and list2:
            if list1.val < list2.val:
                new_head.next = list1
                list1 = list1.next
            else:
                new_head.next = list2
                list2 = list2.next
            new_head = new_head.next
        
        # 这块要记住
        new_head.next = list1 if list1 is not None else list2
                
        return head.next

    for _ in range(10): pass         # 为了好看





# 23. Merge k Sorted Lists
"""
You are given an array of k linked-lists lists, each linked-list is sorted in ascending order.
Merge all the linked-lists into one sorted linked-list and return it.
"""
class Solution:
    def mergeKLists(self, lists: List[Optional[ListNode]]) -> Optional[ListNode]:
        if not lists:
            return None
        
        order = 0
        dummy = head = ListNode(-1)
        heap = []
        
        for list_head in lists:
            if list_head:
                order += 1
                heapq.heappush(heap, (list_head.val, order, list_head))
                
        while heap:
            _, _, node = heapq.heappop(heap)
            head.next = node
            head = head.next
            
            if head.next:
                order += 1
                heapq.heappush(heap, (head.next.val, order, head.next))
                
        return dummy.next

    for _ in range(10): pass         # 为了好看





# 994. Rotting Oranges
"""
You are given an m x n grid where each cell can have one of three values:
    0 representing an empty cell,
    1 representing a fresh orange,
    2 representing a rotten orange.
    Every minute, any fresh orange that is 4-directionally adjacent to a rotten orange becomes rotten.
Return the minimum number of minutes that must elapse until no cell has a fresh orange. If this is impossible, return -1.
"""
class Solution:
    def orangesRotting(self, grid: List[List[int]]) -> int:
        if not grid or not grid[0]:
            return -1
        
        queue = deque()
        fresh_oranges = 0
        for r in range(len(grid)):
            for c in range(len(grid[0])):
                if grid[r][c] == 2:
                    queue.append((r, c))
                elif grid[r][c] == 1:
                    fresh_oranges += 1
                    
        if fresh_oranges == 0:
            return 0
                    
        minutes = 0
        while queue:
            minutes += 1
            
            for _ in range(len(queue)):
                x, y = queue.popleft()
                
                for dx, dy in [(-1, 0), (0, 1), (1, 0), (0, -1)]:
                    next_x, next_y = x + dx, y + dy
                    
                    if not (0 <= next_x < len(grid) and 0 <= next_y < len(grid[0])):
                        continue
                    if grid[next_x][next_y] == 1:
                        grid[next_x][next_y] = 2
                        fresh_oranges -= 1
                        queue.append((next_x, next_y))
                        
            if fresh_oranges == 0:
                return minutes
                
        return -1





# 207. Course Schedule
"""
There are a total of numCourses courses you have to take, labeled from 0 to numCourses - 1. 
You are given an array prerequisites where prerequisites[i] = [ai, bi] indicates that you must take course bi first if you want to take course ai.
For example, the pair [0, 1], indicates that to take course 0 you have to first take course 1.
Return true if you can finish all courses. Otherwise, return false.
Input: numCourses = 2, prerequisites = [[1,0]]
Output: true
"""
class Solution:

    # Approach 1.       Topological Sort       O(|E| + |V|) / O(|E| + |V|)
    def canFinish(self, numCourses: int, prerequisites: List[List[int]]) -> bool:
        indegree = {x: 0 for x in range(numCourses)}
        graph = {x: [] for x in range(numCourses)}
        
        for i, j in prerequisites:
            indegree[i] += 1
            graph[j].append(i)
            
        start_courses = [x for x in range(numCourses) if indegree[x] == 0]
        queue = deque(start_courses)
        results = 0
        
        while queue:
            course = queue.popleft()
            results += 1
            
            for next_course in graph[course]:
                indegree[next_course] -= 1
                if indegree[next_course] == 0:
                    queue.append(next_course)
                    
        return results == numCourses


    # Approach 2:       Postorder DFS
    def canFinish(self, numCourses: int, prerequisites: List[List[int]]) -> bool:
        from collections import defaultdict
        courseDict = defaultdict(list)

        for relation in prerequisites:
            nextCourse, prevCourse = relation[0], relation[1]
            courseDict[prevCourse].append(nextCourse)
        
        checked = [False] * numCourses
        path = [False] * numCourses
        for currCourse in range(numCourses):
            if self.isCyclic(currCourse, courseDict, checked, path):
                return False
        return True

    def isCyclic(self, currCourse, courseDict, checked, path):
        """
        backtracking method to check that no cycle would be formed starting from currCourse
        """
        if checked[currCourse]:
            return False        # this node has been checked, no cycle would be formed with this node.
        if path[currCourse]:
            return True         # came across a marked node in the path, cyclic !

        path[currCourse] = True
        ret = False
        for child in courseDict[currCourse]:
            ret = self.isCyclic(child, courseDict, checked, path)
            if ret: break
        path[currCourse] = False
        checked[currCourse] = True
        return ret





# 210. Course Schedule II
"""
There are a total of numCourses courses you have to take, labeled from 0 to numCourses - 1. 
You are given an array prerequisites where prerequisites[i] = [ai, bi] indicates that you must take course bi first if you want to take course ai.
Return the ordering of courses you should take to finish all courses. If there are many valid answers, return any of them. 
If it is impossible to finish all courses, return an empty array.
"""
class Solution:
    def findOrder(self, numCourses: int, prerequisites: List[List[int]]) -> List[int]:
        graph = {x: [] for x in range(numCourses)}
        indegree = {x: 0 for x in range(numCourses)}
        
        for i, j in prerequisites:
            graph[j].append(i)
            indegree[i] += 1
            
        start_course = [c for c in range(numCourses) if indegree[c] == 0]
        queue = deque(start_course)
        results = []
        
        while queue:
            course = queue.popleft()
            results.append(course)
            
            for next_course in graph[course]:
                indegree[next_course] -= 1
                if indegree[next_course] == 0:
                    queue.append(next_course)
                    
        if len(results) == numCourses:
            return results
        return []

    for _ in range(10): pass         # 为了好看





# 630. Course Schedule III
"""
There are n different online courses numbered from 1 to n. You are given an array courses where courses[i] = [durationi, lastDayi] 
indicate that the ith course should be taken continuously for durationi days and must be finished before or on lastDayi.
You will start on the 1st day and you cannot take two or more courses simultaneously. Return the maximum number of courses that you can take.
Input: courses = [[100,200],[200,1300],[1000,1250],[2000,3200]]
Output: 3
"""
class Solution:

    # Approach 1: Priority Queue + 贪心法 Greedy
    # 课程按照 deadline 排序，从左到右扫描每个课程，依次学习。如果发现学了之后超过 deadline 的，就从之前学过的课程里
    # 扔掉一个耗时最长的。因为这样可以使得其他的课程往前挪，而往前挪是没影响的。所以挑最大值这个事情就是 Heap 的事情了
    def scheduleCourse(self, courses: List[List[int]]) -> int:
        if courses is None or len(courses) == 0:
            return 0
            
        courses = sorted(courses, key=lambda x: x[1])
        curt_time = 0
        heap = []

        for duration, deadline in courses:
            curt_time += duration
            heapq.heappush(heap, -duration)
            if curt_time > deadline:
                curt_time -= (-heapq.heappop(heap))

        return len(heap)


    # Approach 2: Optimized Iterative
    def scheduleCourse(self, courses):
        if courses is None or len(courses) == 0:
            return 0
            
        courses.sort(key = lambda x: x[1])
        queue = []
        time = 0
        
        for i in range(len(courses)):
            if time + courses[i][0] <= courses[i][1]:
                time += courses[i][0]
                heapq.heappush(queue, -courses[i][0])
            elif queue and courses[i][0] < (-queue[0]):
                time += courses[i][0] - (-queue[0])
                heapq.heapreplace(queue, -courses[i][0])
                
        return len(queue)





# 269. Alien Dictionary
"""
There is a new alien language that uses the English alphabet. However, the order among the letters is unknown to you.
You are given a list of strings words from the alien language's dictionary, where the strings in words are sorted lexicographically by the rules of this new language.
Return a string of the unique letters in the new alien language sorted in lexicographically increasing order by the new language's rules. If there is no solution, 
return "". If there are multiple solutions, return any of them. A string s is lexicographically smaller than a string t if at the first letter where they differ, 
the letter in s comes before the letter in t in the alien language. If the first min(s.length, t.length) letters are the same, then s is smaller if and only if s.length < t.length.
Input: words = ["wrt","wrf","er","ett","rftt"]
Output: "wertf"
"""
class Solution:
    def alienOrder(self, words: List[str]) -> str:
        Graph = {ch: [] for word in words for ch in word}
        indegree = {ch: 0 for word in words for ch in word}
        
        for pos in range(len(words)-1):
            for i in range(min(len(words[pos]), len(words[pos+1]))):
                prev, curr = words[pos][i], words[pos+1][i]
                if prev != curr:
                    Graph[prev].append(curr)
                    indegree[curr] += 1
                    break
            if prev == curr and len(words[pos]) > len(words[pos+1]):
                return ""
                
        starting_node = [ch for ch in indegree if indegree[ch] == 0]
        queue = deque(starting_node)
        order = []
        
        while queue:
            for _ in range(len(queue)):
                ch = queue.popleft()
                order.append(ch)
                for neighbor in Graph[ch]:
                    indegree[neighbor] -= 1
                    if indegree[neighbor] == 0:
                        queue.append(neighbor)
                        
        if len(order) != len(indegree):
            return ""
        return ''.join(order)





# 310. Minimum Height Trees
"""
A tree is an undirected graph in which any two vertices are connected by exactly one path. In other words, any connected graph without simple cycles is a tree.
Given a tree of n nodes labelled from 0 to n - 1, and an array of n - 1 edges where edges[i] = [ai, bi] indicates that there is an undirected edge 
between the two nodes ai and bi in the tree, you can choose any node of the tree as the root. When you select a node x as the root, the result tree has height h. 
Among all possible rooted trees, those with minimum height (i.e. min(h))  are called minimum height trees (MHTs).
Return a list of all MHTs' root labels. You can return the answer in any order.
The height of a rooted tree is the number of edges on the longest downward path between the root and a leaf.
Input: n = 6, edges = [[3,0],[3,1],[3,2],[3,4],[5,4]]
Output: [3,4]
"""
class Solution:
    def findMinHeightTrees(self, n: int, edges: List[List[int]]) -> List[int]:
        if n <= 2:
            return [i for i in range(n)]

        # Build the graph with the adjacency list
        neighbors = defaultdict(set)
        for start, end in edges:
            neighbors[start].add(end)
            neighbors[end].add(start)

        # Initialize the first layer of leaves
        leaves = []
        for i in range(n):
            if len(neighbors[i]) == 1:      # len(neighbors[i]) is the indegree
                leaves.append(i)

        # Trim the leaves until reaching the centroids
        remaining_nodes = n
        while remaining_nodes > 2:
            remaining_nodes -= len(leaves)
            new_leaves = []
            # remove the current leaves along with the edges
            while leaves:
                leaf = leaves.pop()
                # the only neighbor left for the leaf node
                neighbor = neighbors[leaf].pop()
                # remove the only edge left
                neighbors[neighbor].remove(leaf)
                if len(neighbors[neighbor]) == 1:
                    new_leaves.append(neighbor)

            # prepare for the next round
            leaves = new_leaves

        # The remaining nodes are the centroids of the graph
        return leaves





# 380. Insert Delete GetRandom O(1)
"""
Implement the RandomizedSet class:
RandomizedSet() Initializes the RandomizedSet object.
bool insert(int val) Inserts an item val into the set if not present. Returns true if the item was not present, false otherwise.
bool remove(int val) Removes an item val from the set if present. Returns true if the item was present, false otherwise.
int getRandom() Returns a random element from the current set of elements (it's guaranteed that at least one element exists when this method is called). Each element must have the same probability of being returned.
You must implement the functions of the class such that each function works in average O(1) time complexity.
["RandomizedSet", "insert", "remove", "insert", "getRandom", "remove", "insert", "getRandom"] , [[], [1], [2], [2], [], [1], [2], []]
Output:     [null, true, false, true, 2, true, false, 2]
"""
from random import choice

# 删除操作的重点在于将变长数组的最后一个元素移动到待删除元素的下标处，然后删除变长数组的最后一个元素。该操作的时间复杂度是 O(1),
# 且可以保证在删除操作之后变长数组中的所有元素的下标都连续，方便插入操作和获取随即元素操作。
class RandomizedSet():
    def __init__(self):
        self.nums = []
        self.indices = {}

    def insert(self, val: int) -> bool:
        if val in self.indices:
            return False
        self.indices[val] = len(self.nums)
        self.nums.append(val)
        return True

    def remove(self, val: int) -> bool:
        if val not in self.indices:
            return False
        index = self.indices[val]
        self.nums[index] = self.nums[-1]
        self.indices[self.nums[index]] = index
        self.nums.pop()
        del self.indices[val]
        return True

    def getRandom(self) -> int:
        return choice(self.nums)
        

    for _ in range(10): pass         # 为了好看
# Your RandomizedSet object will be instantiated and called as such:
# obj = RandomizedSet()
# param_1 = obj.insert(val)
# param_2 = obj.remove(val)
# param_3 = obj.getRandom()





# 381. Insert Delete GetRandom O(1) - Duplicates allowed
"""
RandomizedCollection is a data structure that contains a collection of numbers, possibly duplicates (i.e., a multiset). It should support inserting 
and removing specific elements and also removing a random element. Implement the RandomizedCollection class:
1. RandomizedCollection() Initializes the empty RandomizedCollection object.
2. bool insert(int val) Inserts an item val into the multiset, even if the item is already present. Returns true if the item is not present, false otherwise.
3. bool remove(int val) Removes an item val from the multiset if present. Returns true if the item is present, false otherwise. 
    Note that if val has multiple occurrences in the multiset, we only remove one of them.
4. int getRandom() Returns a random element from the current multiset of elements. The probability of each element being returned is linearly related to 
    the number of same values the multiset contains.
You must implement the functions of the class such that each function works on average O(1) time complexity.
Note: The test cases are generated such that getRandom will only be called if there is at least one item in the RandomizedCollection.
"""
class RandomizedCollection:
    def __init__(self):
        self.nums = []
        self.indices = defaultdict(set)

    def insert(self, val: int) -> bool:
        self.indices[val].add(len(self.nums))
        self.nums.append(val)
        return len(self.indices[val]) == 1

    def remove(self, val: int) -> bool:
        if not self.indices[val]:
            return False
        index = self.indices[val].pop()
        last_element = self.nums[-1]
        self.nums[index] = last_element
        self.indices[last_element].add(index)
        self.indices[last_element].discard(len(self.nums) - 1)
        
        self.nums.pop()
        return True

    def getRandom(self) -> int:
        return choice(self.nums)


    for _ in range(10): pass         # 为了好看





# 121. Best Time to Buy and Sell Stock
"""
You are given an array prices where prices[i] is the price of a given stock on the ith day.
You want to maximize your profit by choosing a single day to buy one stock and choosing a different day in the future to sell that stock.
Return the maximum profit you can achieve from this transaction. If you cannot achieve any profit, return 0.
Input: prices = [7,1,5,3,6,4]
Output: 5
"""
class Solution:
    # We need to find the largest peak following the smallest valley by maintaining two variables - minprice and maxprofit
    def maxProfit(self, prices: List[int]) -> int:
        min_price, max_profit = float('inf'), 0
        for i in range(len(prices)):
            if prices[i] < min_price:
                min_price = prices[i]
            elif prices[i] - min_price > max_profit:
                max_profit = prices[i] - min_price
        return max_profit





# 322. Coin Change
"""
You are given an integer array coins representing coins of different denominations and an integer amount representing a total amount of money.
Return the fewest number of coins that you need to make up that amount. If that amount of money cannot be made up by any combination of the coins, return -1.
You may assume that you have an infinite number of each kind of coin.
Input: coins = [1,2,5], amount = 11
Output: 3
"""
import functools

class Solution:
    # Approach #1 (Dynamic programming - Bottom up)
    def coinChange(self, coins: List[int], amount: int) -> int:
        dp = [0] + [float('inf')] * amount
        
        for coin in coins:
            for i in range(coin, amount+1):
                dp[i] = min(dp[i], dp[i-coin]+1)
        
        return dp[-1] if dp[-1] != float('inf') else -1
    
    
    # Approach #2 (Dynamic programming - Top down)
    def coinChange(self, coins: List[int], amount: int) -> int:
        if amount < 1:
            return 0
        return self.dp(coins, amount)
    
    @functools.lru_cache()
    def dp(self, coins, remain):
        if remain < 0:
            return -1
        if remain == 0:
            return 0
        
        mini = float('inf')
        for coin in coins:
            res = self.dp(coins, remain - coin)
            if res >= 0 and res < mini:
                mini = res + 1
        return mini if mini < float('inf') else -1
    
    
    # Approach #3   BFS
    def coinChange(self, coins: List[int], amount: int) -> int:
        q = deque([(amount, 0)])
        seen = set([amount])
        while q:
            accum_amount, num_coins = q.popleft()
            if accum_amount == 0:
                return num_coins
            for coin in coins:
                if accum_amount - coin >= 0 and accum_amount - coin not in seen:
                    q.append((accum_amount - coin, num_coins + 1))
                    seen.add(accum_amount - coin)
        return -1

    for _ in range(10): pass         # 为了好看





# 518. Coin Change 2
"""
You are given an integer array coins representing coins of different denominations and an integer amount representing a total amount of money.
Return the number of combinations that make up that amount. If that amount of money cannot be made up by any combination of the coins, return 0.
You may assume that you have an infinite number of each kind of coin.
The answer is guaranteed to fit into a signed 32-bit integer.
Input: amount = 5, coins = [1,2,5]
Output: 4
Explanation: there are four ways to make up the amount: 5=5     5=2+2+1     5=2+1+1+1       5=1+1+1+1+1
"""
class Solution:
    def change(self, amount: int, coins: List[int]) -> int:
        if not coins or len(coins) == 0:
            return 0

        dp = [0] * (amount + 1)
        dp[0] = 1
        
        for coin in coins:
            for x in range(coin, amount + 1):
                dp[x] += dp[x - coin]
        return dp[amount]





# 266. Palindrome Permutation
"""
Given a string s, return true if a permutation of the string could form a palindrome.
Input: s = "aab"
Output: true
"""
class Solution:
    # return sum(v % 2 for v in Counter(s).values()) < 2
    def canPermutePalindrome(self, s: str) -> bool:
        unpaired_chars = set()
        for char in s:
            if char not in unpaired_chars:
                unpaired_chars.add(char)
            else:
                unpaired_chars.remove(char)
                
        return len(unpaired_chars) <= 1

    for _ in range(10): pass         # 为了好看





# 267. Palindrome Permutation II
"""
Given a string s, return all the palindromic permutations (without duplicates) of it.
You may return the answer in any order. If s has no palindromic permutation, return an empty list.
Input: s = "aabb"
Output: ["abba","baab"]
"""
class Solution:
    def generatePalindromes(self, s: str) -> List[str]:
        counter = {}
        for c in s:
            counter[c] = counter.get(c, 0) + 1
        odds = [c for c in counter if counter[c] % 2 == 1]
        # odds = filter(lambda x: x % 2, counter.values())
        if len(odds) > 1:
            return []
        
        half_s = []
        for c in counter:
            half_s.extend([c] * (counter[c] // 2))
            
        visited = set()
        permutations = []
        self.dfs(half_s, visited, "", permutations)
        
        results = []
        # 这里优化是因为正常的代码会超时, 只用palindrome的一半传入做dfs
        for permutation in permutations:
            if odds:
                results.append(permutation + odds[0] + permutation[::-1])
            else:
                results.append(permutation + permutation[::-1])
        return results
    
    def dfs(self, s, visited, permutation, permutations):
        if len(permutation) == len(s):
            permutations.append(permutation[:])
            return
        
        for i in range(len(s)):
            if i in visited:
                continue
            if i > 0 and s[i-1] == s[i] and (i-1) not in visited:
                continue
                
            visited.add(i)
            self.dfs(s, visited, permutation + s[i], permutations)
            visited.remove(i)





# 441. Arranging Coins
"""
You have n coins and you want to build a staircase with these coins. The staircase consists of k rows where the ith row has exactly i coins. 
The last row of the staircase may be incomplete. Given the integer n, return the number of complete rows of the staircase you will build.
Input: n = 5            Output: 2
Explanation: Because the 3rd row is incomplete, we return 2.
"""
class Solution:
    def arrangeCoins(self, n: int) -> int:
        if n == 0:
            return 0
        if n == 1:
            return 1
        
        # return int((2 * n + 0.25)**0.5 - 0.5)  数学公式推导
        
        left, right = 0, n
        
        while left <= right:
            k = (right + left) // 2
            curr = k * (k + 1) // 2
            if curr == n:
                return k
            if n < curr:
                right = k - 1
            else:
                left = k + 1
        return right

    for _ in range(10): pass         # 为了好看





# 53. Maximum Subarray
"""
Given an integer array nums, find the contiguous subarray (containing at least one number) which has the largest sum and return its sum.
A subarray is a contiguous part of an array.
Input: nums = [-2,1,-3,4,-1,2,1,-5,4]
Output: 6
"""
class Solution:
    # Approach 1.       标准DP
    def maxSubArray(self, nums: List[int]) -> int:
        size = len(nums)
        if size == 0:
            return 0
        
        dp = [0 for _ in range(size)]       # dp[i] 表示以i结尾的subarray的最大值
        dp[0] = nums[0]
        
        for i in range(1, size):
            if dp[i - 1] >= 0:
                dp[i] = dp[i - 1] + nums[i]
            else:
                dp[i] = nums[i]
            # dp[i] = max(dp[i - 1] + nums[i], nums[i])     如果dp[i-1] < 0, 说明可以直接舍弃，以nums[i]开始另起炉灶
        return max(dp)
    
    
    # Approach 2.       DP优化，滚动数组
    def maxSubArray(self, nums: List[int]) -> int:
        current_subarray = max_subarray = nums[0]
        for num in nums[1:]:
            current_subarray = max(num, current_subarray + num)         #如果 current_subarray < 0, 则可以直接舍弃, 从nums[i]开始另起炉灶
            max_subarray = max(max_subarray, current_subarray)
        return max_subarray

    for _ in range(10): pass         # 为了好看





# 2272. Substring With Largest Variance (53 的变形)
"""
The variance of a string is defined as the largest difference between the number of occurrences of any 2 characters present in the string. 
Note the two characters may or may not be the same. Given a string s consisting of lowercase English letters only, return the largest variance possible among all substrings of s.
A substring is a contiguous sequence of characters within a string.
Input: s = "aababbb"        Output: 3
- Variance 0 for substrings "a", "aa", "ab", "abab", "aababb", "ba", "b", "bb", and "bbb".
- Variance 1 for substrings "aab", "aba", "abb", "aabab", "ababb", "aababbb", and "bab".
- Variance 2 for substrings "aaba", "ababbb", "abbb", and "babb".
- Variance 3 for substring "babbb".
"""
class Solution:
    # DP: 枚举最多和最少的字符 + 最大子段和动态规划
    # 如果枚举给定字符串s的所有子串并计算波动值，那么至少需要O(n2)的时间，因此可以考虑枚举【出现次数最多的字符】和【出现次数最少的字符】
    # 最多映射为 +1， 最少映射为 -1，其它情况映射为 0， 继而将问题转换为求映射数组的【最大子段和】
    # 注意一点：满足要求的子数组必须至少包含一个 +1 和一个 -1，因此在DP时，需要一个额外状态，即【包含 -1 的子数组】
    
    # Approach 1: DP    Kadanes algorithm
    def largestVariance(self, s: str) -> int:
        pos = defaultdict(list)
        for i, char in enumerate(s):
            pos[char].append(i)
            
        res = 0
        for c0, pos0 in pos.items():
            for c1, pos1 in pos.items():
                if c0 != c1:
                    i = j = 0
                    f, g = 0, float("-inf")
                    while i < len(pos0) or j < len(pos1):
                        if j == len(pos1) or (i < len(pos0) and pos0[i] < pos1[j]):
                            f, g = max(f, 0) + 1, g + 1
                            i += 1
                        else:
                            f, g = max(f, 0) - 1, max(f, g, 0) - 1
                            j += 1
                        res = max(res, g)
        return res
    
    
    # Approach 2    The basic idea is same: pick 2 chars, check the results for these particular 2 chars. 
    # we go through s, +1 when see a, -1 when see b. The question becomes: -1, +1, +1, -1, +1, ...  What is the maximum subarray?
    def largestVariance(self, s: str) -> int:
        counter = Counter(s)      # s = "aababbb"  Counter({'b': 4, 'a': 3})
        res = 0
        for a, b in permutations(counter, 2):       # permutation: (a, b), (b, a)
            max_subarray = 0
            has_a, has_b = False, False
            remain_a, remain_b = counter[a], counter[b]
            for ch in s:
                if ch != a and ch != b:
                    continue
                if max_subarray < 0 and remain_a != 0 and remain_b != 0:
                    max_subarray = 0
                    has_a, has_b = False, False
                if ch == a: 
                    max_subarray += 1
                    remain_a -= 1
                    has_a = True
                elif ch == b: 
                    max_subarray -= 1
                    remain_b -= 1
                    has_b = True
                if has_a and has_b:
                    res = max(res, max_subarray)
        return res






# 152. Maximum Product Subarray
"""
Given an integer array nums, find a contiguous non-empty subarray within the array that has the largest product, and return the product.
The test cases are generated so that the answer will fit in a 32-bit integer.
A subarray is a contiguous subsequence of the array.
"""
class Solution:
    # 如果按照上题的解法，dp[i] = dp[i-1] * nums[i] 是错误的，因为不满足【最优子结构】，即最优解不一定是由前一个位置的最优解转移得到
    # 因为涉及到乘法而非加法，应根据正负性进行讨论：如果当前位置是一个负数，那么我们希望以它前一个位置结尾的某个段的乘积也是个负数，这样就可以负负得正，
    # 并且我们还希望这个乘积尽可能【负的更多】，反之对于当前位置是一个正数也是同样的分析，于是我们还需要维护一个 min_so_far
    def maxProduct(self, nums: List[int]) -> int:
        if len(nums) == 0:
            return 0
        
        max_so_far = min_so_far = nums[0]
        result = max_so_far
        
        for i in range(1, len(nums)):
            mx, mn = max_so_far, min_so_far
            curr = nums[i]
            max_so_far = max(mx * curr, max(curr, mn * curr))
            min_so_far = min(mn * curr, min(curr, mx * curr))
            result = max(max_so_far, result)
            
        return result





# 238. Product of Array Except Self
"""
Given an integer array nums, return an array answer such that answer[i] is equal to the product of all the elements of nums except nums[i].
The product of any prefix or suffix of nums is guaranteed to fit in a 32-bit integer.
You must write an algorithm that runs in O(n) time and without using the division operation.
Input: nums = [1,2,3,4]
Output: [24,12,8,6]
"""
class Solution:
    # 前缀积
    def productExceptSelf(self, nums: List[int]) -> List[int]:
        if not nums or len(nums) == 0:
            return []
        
        length = len(nums)
        L, R, results = [0] * length, [0] * length, [0] * length
        
        L[0] = 1
        for i in range(1, length):
            L[i] = L[i - 1] * nums[i - 1]
            
        R[-1] = 1
        for i in range(length-2, -1, -1):
            R[i] = R[i + 1] * nums[i + 1]
            
        for i in range(length):
            results[i] = L[i] * R[i]
            
        return results





# 713. Subarray Product Less Than K
"""
Given an array of integers nums and an integer k, return the number of contiguous subarrays where the product of all the elements in the subarray is strictly less than k.
Input: nums = [10,5,2,6], k = 100
Output: 8
Explanation: The 8 subarrays that have product less than 100 are:
[10], [5], [2], [6], [10, 5], [5, 2], [2, 6], [5, 2, 6]
"""
class Solution:
    def numSubarrayProductLessThanK(self, nums: List[int], k: int) -> int:
        if not nums or len(nums) == 0 or k <= 1:
            return 0
        
        product = 1
        left = result = 0
        for right, val in enumerate(nums):
            product *= val
            while product >= k:
                product /= nums[left]
                left += 1
            result += right - left + 1
        return result





# 398. Random Pick Index
"""
Given an integer array nums with possible duplicates, randomly output the index of a given target number. You can assume that the given target number must exist in the array.
Implement the Solution class:
Solution(int[] nums) Initializes the object with the array nums.
int pick(int target) Picks a random index i from nums where nums[i] == target. If there are multiple valid i's, then each index should have an equal probability of returning.
Input
["Solution", "pick", "pick", "pick"]
[[[1, 2, 3, 3, 3]], [3], [1], [3]]
Output
[null, 4, 0, 2]
"""
class Solution:
    
    def __init__(self, nums: List[int]):
        self.map = defaultdict(list)
        for index, num in enumerate(nums):
            self.map[num].append(index)
        self.results = []

    def pick(self, target: int) -> int:
        if target in self.map:
            if len(self.map[target]) == 1:
                return self.map[target][0]
            else:
                rand = random.randint(0, len(self.map[target]) - 1)
                return self.map[target][rand]
        else:
            return None
                
    for _ in range(10): pass         # 为了好看


# Your Solution object will be instantiated and called as such:
# obj = Solution(nums)
# param_1 = obj.pick(target)





# 528. Random Pick with Weight
"""
You are given a 0-indexed array of positive integers w where w[i] describes the weight of the ith index.
You need to implement the function pickIndex(), which randomly picks an index in the range [0, w.length - 1] (inclusive) and returns it. 
The probability of picking an index i is w[i] / sum(w). For example, if w = [1, 3], the probability of picking index 0 is 
1 / (1 + 3) = 0.25 (i.e., 25%), and the probability of picking index 1 is 3 / (1 + 3) = 0.75 (i.e., 75%).
Input
["Solution","pickIndex","pickIndex","pickIndex","pickIndex","pickIndex"]
[[[1,3]],[],[],[],[],[]]
Output
[null,1,1,1,1,0]
"""
class Solution:

    # Sampling with Weights         Prefix Sums with Binary Search, since prefix_sum is gaurantee to be an increasing list, so it's a sorted list
    # random.choices(population, weights=None, *, cum_weights=None, k=1)  如果指定了 weight 序列，则根据相对权重进行选择。 
    # 或者，如果给出 cum_weights 序列，则根据累积权重（可能使用 itertools.accumulate() 计算）进行选择。 
    # 例如，相对权重``[10, 5, 30, 5]``相当于累积权重``[10, 15, 45, 50]``。 在内部，相对权重在进行选择之前会转换为累积权重，因此提供累积权重可以节省工作量。
    def __init__(self, w: List[int]):
        self.prefix_sums = []
        prefix_sum = 0
        for weight in w:
            prefix_sum += weight
            self.prefix_sums.append(prefix_sum)
        self.total_sum = prefix_sum

    def pickIndex(self) -> int:
        target = self.total_sum * random.random()
        # for i, prefix_sum in enumerate(self.prefix_sums):
        #     if prefix_sum > target:
        #         return i
        left, right = 0, len(self.prefix_sums) - 1
        while left + 1 < right:
            mid = left + (right - left) // 2
            if self.prefix_sums[mid] < target:
                left = mid
            else:
                right = mid
                
        if self.prefix_sums[left] >= target:
            return left
        return right
        

# Your Solution object will be instantiated and called as such:
# obj = Solution(w)
# param_1 = obj.pickIndex()





# 710. Random Pick with Blacklist
"""
You are given an integer n and an array of unique integers blacklist. Design an algorithm to pick a random integer in the range [0, n - 1] that is not in blacklist. 
Any integer that is in the mentioned range and not in blacklist should be equally likely to be returned.
Optimize your algorithm such that it minimizes the number of calls to the built-in random function of your language.
Implement the Solution class:
    Solution(int n, int[] blacklist) Initializes the object with the integer n and the blacklisted integers blacklist.
    int pick() Returns a random integer in the range [0, n - 1] and not in blacklist.
Input
["Solution", "pick", "pick", "pick", "pick", "pick", "pick", "pick"]
[[7, [2, 3, 5]], [], [], [], [], [], [], []]
Output
[null, 0, 4, 1, 6, 1, 0, 4]
"""
import random

class Solution:
    # using hashmap to represent mapped value to simulate pushing elements to the end
    def __init__(self, n: int, blacklist: List[int]):
        # [0, self.white - 1] is whitelist, [white, n - 1] is blacklist, only random in new whitelist
        self.white = n - len(blacklist)
        self.dict = {}
        last = n - 1

        for b in blacklist:
            self.dict[b] = -1                       # mark blacklist
        
        for b in blacklist:
            if b >= self.white:                     # in the range of blacklist, leave it, as we won't pick a rand in the range of blacklist
                continue
            
            while last in self.dict:                # last is in blacklist
                last -= 1                           # reduce last so the element won't repeat

            self.dict[b] = last                     # map blacklist to the white
            last -= 1                               # reduce last so the element won't repeat

    def pick(self) -> int:
        rand = random.randint(0, self.white - 1)    # only pick in the range of [0, self.white - 1]
        if rand in self.dict:
            return self.dict[rand]
        return rand
        
    for _ in range(10): pass         # 为了好看


# Your Solution object will be instantiated and called as such:
# obj = Solution(n, blacklist)
# param_1 = obj.pick()





# 320. Generalized Abbreviation
"""
A word's generalized abbreviation can be constructed by taking any number of non-overlapping and non-adjacent substrings and replacing them with their respective lengths.
For example, "abcde" can be abbreviated into:
"a3e" ("bcd" turned into "3")       "1bcd1" ("a" and "e" both turned into "1")      "5" ("abcde" turned into "5")       "abcde" (no substrings replaced)
Given a string word, return a list of all the possible generalized abbreviations of word. Return the answer in any order.

Input: word = "word"
Output: ["4","3d","2r1","2rd","1o2","1o1d","1or1","1ord","w3","w2d","w1r1","w1rd","wo2","wo1d","wor1","word"]
"""
class Solution:
    def generateAbbreviations(self, word: str) -> List[str]:
        if not word:
            return []
        
        result = []
        self.dfs("", 0, 0, result, word)
        return result 
    
    def dfs(self, curWord, index, abbrCount, result, word):
        if index == len(word):
            result.append(curWord)
            return 
        
        # do not abbreviate at current index
        self.dfs(curWord + word[index], index + 1, 0, result, word)

        # abbreviate at current index
        if abbrCount > 0:
            # remove the previous count in the string and append the new count into the string
            # len(str(abbrCount)) == 2, case when abbrCount >= 10
            curWord = curWord[: -len(str(abbrCount))] + str(abbrCount + 1)
        else:
            # the first abbrevation, hence the abbr string is '1'
            curWord += '1'

        self.dfs(curWord, index + 1, abbrCount + 1, result, word)





# 36. Valid Sudoku
"""
Determine if a 9 x 9 Sudoku board is valid. Only the filled cells need to be validated according to the following rules:
Each row must contain the digits 1-9 without repetition.
Each column must contain the digits 1-9 without repetition.
Each of the nine 3 x 3 sub-boxes of the grid must contain the digits 1-9 without repetition.
"""
class Solution:
    def isValidSudoku(self, board: List[List[str]]) -> bool:
        row = [set([]) for _ in range(9)]
        col = [set([]) for _ in range(9)]
        grid = [set([]) for _ in range(9)]
        
        for r in range(9):
            for c in range(9):
                if board[r][c] == ".":
                    continue
                if board[r][c] in row[r]:
                    return False
                if board[r][c] in col[c]:
                    return False
                
                g = (r//3) * 3 + (c//3)
                if board[r][c] in grid[g]:
                    return False
                
                row[r].add(board[r][c])
                col[c].add(board[r][c])
                grid[g].add(board[r][c])
                
        return True





# 37. Sudoku Solver
"""
Write a program to solve a Sudoku puzzle by filling the empty cells.
A sudoku solution must satisfy all of the following rules:
Each of the digits 1-9 must occur exactly once in each row.
Each of the digits 1-9 must occur exactly once in each column.
Each of the digits 1-9 must occur exactly once in each of the 9 3x3 sub-boxes of the grid.
The '.' character indicates empty cells.
"""
from collections import defaultdict
class Solution:
    def solveSudoku(self, board):
        
        def could_place(d, row, col):
            return not (d in rows[row] or d in columns[col] or d in boxes[box_index(row, col)])
        
        def place_number(d, row, col):
            rows[row][d] += 1
            columns[col][d] += 1
            boxes[box_index(row, col)][d] += 1
            board[row][col] = str(d)
            
        def remove_number(d, row, col):
            del rows[row][d]
            del columns[col][d]
            del boxes[box_index(row, col)][d]
            board[row][col] = '.'    
            
        def place_next_numbers(row, col):
            if col == N - 1 and row == N - 1:
                nonlocal sudoku_solved
                sudoku_solved = True    
            else:
                if col == N - 1:
                    backtrack(row + 1, 0)
                else:
                    backtrack(row, col + 1)
                
        def backtrack(row = 0, col = 0):
            if board[row][col] == '.':
                for d in range(1, 10):
                    if could_place(d, row, col):
                        place_number(d, row, col)
                        place_next_numbers(row, col)
                        if not sudoku_solved:
                            remove_number(d, row, col)
            else:
                place_next_numbers(row, col)
                    
        n = 3       # box size
        N = n * n   # row size
        box_index = lambda row, col: (row // n ) * n + col // n
        
        # init rows, columns and boxes
        rows = [defaultdict(int) for i in range(N)]
        columns = [defaultdict(int) for i in range(N)]
        boxes = [defaultdict(int) for i in range(N)]
        
        for i in range(N):
            for j in range(N):
                if board[i][j] != '.': 
                    d = int(board[i][j])
                    place_number(d, i, j)
        
        sudoku_solved = False
        backtrack()





# 105. Construct Binary Tree from Preorder and Inorder Traversal
"""
Input: preorder = [3,9,20,15,7], inorder = [9,3,15,20,7]
Output: [3,9,20,null,null,15,7]
"""
# Definition for a binary tree node.
class TreeNode:
    def __init__(self, val=0, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right


class Solution:
    def buildTree(self, preorder: List[int], inorder: List[int]) -> Optional[TreeNode]:
        if not preorder or len(preorder) == 0:
            return None
        
        root = TreeNode(preorder[0])
        root_index = inorder.index(preorder[0])
        
        root.left = self.buildTree(preorder[1: root_index+1], inorder[: root_index])
        root.right = self.buildTree(preorder[root_index+1:], inorder[root_index + 1:])
        
        return root

    for _ in range(10): pass         # 为了好看





# 106. Construct Binary Tree from Inorder and Postorder Traversal
"""
Input: inorder = [9,3,15,20,7], postorder = [9,15,7,20,3]
Output: [3,9,20,null,null,15,7]
"""
class Solution:
    def buildTree(self, inorder: List[int], postorder: List[int]) -> Optional[TreeNode]:
        if not inorder or len(inorder) == 0:
            return None
        
        root = TreeNode(postorder[-1])
        root_index = inorder.index(postorder[-1])
        
        root.left = self.buildTree(inorder[: root_index], postorder[: root_index])
        root.right = self.buildTree(inorder[root_index+1:], postorder[root_index: -1])
        
        return root

    for _ in range(10): pass         # 为了好看





# 2. Add Two Numbers
"""
You are given two non-empty linked lists representing two non-negative integers. The digits are stored in reverse order, 
and each of their nodes contains a single digit. Add the two numbers and return the sum as a linked list.
You may assume the two numbers do not contain any leading zero, except the number 0 itself.
Input: l1 = [2,4,3], l2 = [5,6,4]
Output: [7,0,8]
Explanation: 342 + 465 = 807.
"""
# Definition for singly-linked list.
class ListNode:
    def __init__(self, val=0, next=None):
        self.val = val
        self.next = next


class Solution:
    
    # Approach 1.       Two-Pass
    def addTwoNumbers(self, l1: Optional[ListNode], l2: Optional[ListNode]) -> Optional[ListNode]:
        num1 = num2 = 0
        counter = 1
        while l1:
            num1 += l1.val * counter
            l1 = l1.next
            counter *= 10
        
        counter = 1
        while l2:
            num2 += l2.val * counter
            l2 = l2.next
            counter *= 10
            
        result = num1 + num2
        
        dummy = ListNode(0)
        head = dummy
        if result == 0: return head
        
        while result:
            head.next = ListNode(result % 10)
            result //= 10
            head = head.next
            
        return dummy.next
    
    
    # # Approach 2.       One-Pass
    def addTwoNumbers(self, l1: Optional[ListNode], l2: Optional[ListNode]) -> Optional[ListNode]:
        ans = cur = ListNode(0)
        add = 0
        while l1 or l2:
            val = (l1.val if l1 is not None else 0) + (l2.val if l2 is not None else 0) + add
            add = val // 10
            cur.next = ListNode(val % 10)
            cur = cur.next
            if l1: l1 = l1.next
            if l2: l2 = l2.next
        if add:
            cur.next = ListNode(add)
        return ans.next

    for _ in range(10): pass         # 为了好看





# 445. Add Two Numbers II
"""
You are given two non-empty linked lists representing two non-negative integers. The most significant digit comes first and 
each of their nodes contains a single digit. Add the two numbers and return the sum as a linked list.
You may assume the two numbers do not contain any leading zero, except the number 0 itself.
Input: l1 = [7,2,4,3], l2 = [5,6,4]
Output: [7,8,0,7]
"""
class Solution:
    
    # Approach 1: Reverse Input + Construct Output by Adding to Front
    def addTwoNumbers(self, l1: Optional[ListNode], l2: Optional[ListNode]) -> Optional[ListNode]:
        l1 = self.reverse(l1)
        l2 = self.reverse(l2)
        
        head = None
        carry = 0
        while l1 or l2:
            num1 = l1.val if l1 else 0
            num2 = l2.val if l2 else 0
            
            val = (carry + num1 + num2) % 10
            carry = (carry + num1 + num2) // 10
            
            curr = ListNode(val)
            curr.next = head
            head = curr
            
            l1 = l1.next if l1 else None
            l2 = l2.next if l2 else None
            
        if carry:
            curr = ListNode(carry)
            curr.next = head
            head = curr
            
        return head
    
    def reverse(self, head):
        tail = None
        while head:
            temp = head.next
            head.next = tail
            tail = head
            head = temp
        return tail
    
    
    
    # Approach 2: Follow Up: Do not Reverse Input.
    def addTwoNumbers(self, l1: Optional[ListNode], l2: Optional[ListNode]) -> Optional[ListNode]:
        n1 = n2 = 0             # get the length of both lists
        curr1, curr2 = l1, l2
        while curr1:
            curr1 = curr1.next 
            n1 += 1
        while curr2:
            curr2 = curr2.next 
            n2 += 1
            
        curr1, curr2 = l1, l2
        head = None
        while n1 > 0 and n2 > 0:
            val = 0
            if n1 >= n2:
                val += curr1.val 
                curr1 = curr1.next 
                n1 -= 1
            if n1 < n2:
                val += curr2.val 
                curr2 = curr2.next
                n2 -= 1
                
            # update the result: add to front
            curr = ListNode(val)
            curr.next = head
            head = curr

        # take the carry into account, to have all elements to be less than 10
        # 10->10->3 --> 0->1->4 --> 4->1->0
        curr1, head = head, None
        carry = 0
        while curr1:
            val = (curr1.val + carry) % 10
            carry = (curr1.val + carry) // 10
            
            # update the result: add to front
            curr = ListNode(val)
            curr.next = head
            head = curr

            # move to the next elements in the list
            curr1 = curr1.next
        
        # add the last carry
        if carry:
            curr = ListNode(carry)
            curr.next = head
            head = curr

        return head
        
        
        
    # Approach 3:       Normal Solution
    def addTwoNumbers(self, l1: Optional[ListNode], l2: Optional[ListNode]) -> Optional[ListNode]:
        num1 = num2 = ""
        while l1 and l2:
            num1 += str(l1.val)
            num2 += str(l2.val)
            l1 = l1.next
            l2 = l2.next
            
        while l1:
            num1 += str(l1.val)
            l1 = l1.next
        while l2:
            num2 += str(l2.val)
            l2 = l2.next
            
        s = str(int(num1) + int(num2))
        dummy = head = ListNode(0)
        for n in s:
            head.next = ListNode(int(n))
            head = head.next
            
        return dummy.next

    for _ in range(10): pass         # 为了好看




# 42. Trapping Rain Water
"""
Given n non-negative integers representing an elevation map where the width of each bar is 1, compute how much water it can trap after raining.
Input: height = [0,1,0,2,1,0,1,3,2,1,2,1]
Output: 6
"""
class Solution:

    # Approach 1: Dynamic Programming           O(n) / O(n)
    # 1. Find maximum height of bar from the left end upto an index i in the array left_max.
    # 2. Find maximum height of bar from the right end upto an index i in the array right_max.
    # 3. Iterate over the height array and update ans:  Add "min(left_max[i],right_max[i])−height[i]" to result
    def trap(self, height: List[int]) -> int:
        if not height:
            return 0
        
        n = len(height)
        leftMax = [0] * n
        leftMax[0] = height[0]
        for i in range(1, n):
            leftMax[i] = max(leftMax[i - 1], height[i])
            
        rightMax = [0] * n
        rightMax[n - 1] = height[n - 1]
        for i in range(n - 2, -1, -1):
            rightMax[i] = max(rightMax[i + 1], height[i])
            
        result = 0
        for i in range(n):
            result += min(leftMax[i], rightMax[i]) - height[i]
        return result


    # Approach 2: Using stacks
    # Use stack to store the indices of the bars.
    # While stack is not empty and height[left] > height[top]:
    #   It means that the stack element can be popped. Pop the top element as top.
    #   Find the width / hieght
    #   Add resulting trapped water to answer
    # Push current index to top of the stack
    def trap(self, height: List[int]) -> int:
        if not height:
            return 0
        
        n = len(height)
        stack = []
        result = 0
        
        for i, h in enumerate(height):
            while stack and h > height[stack[-1]]:
                top = stack.pop()
                if not stack:
                    break
                left = stack[-1]
                currWidth = i - left - 1
                currHeight = min(height[left], height[i]) - height[top]
                result += currWidth * currHeight
            stack.append(i)
        return result


    # Approach 3: Using 2 pointers
    # 动态规划的做法中，需要维护两个数组 leftMax 和 rightMax, 因此空间复杂度是O(n)。是否可以将空间复杂度降到O(1)?
    # 注意到下标i处能接的雨水量由 leftMax[i] 和 rightMax[i] 中的最小值决定。由于数组 leftMax 是从左往右计算，数组 rightMax 是从右往左计算，
    # 因此可以使用双指针和两个变量代替两个数组，在移动指针的同时维护两个变量 leftMax 和 rightMax 的值。
    def trap(self, height: List[int]) -> int:
        if not height:
            return 0
            
        left, right = 0, len(height) - 1
        leftMax = rightMax = 0
        water = 0

        while left < right:
            leftMax = max(leftMax, height[left])
            rightMax = max(rightMax, height[right])
            if height[left] < height[right]:
                water += leftMax - height[left]
                left += 1
            else:
                water += rightMax - height[right]
                right -= 1
                
        return water

    for _ in range(10): pass         # 为了好看





# 138. Copy List with Random Pointer
"""
A linked list of length n is given such that each node contains an additional random pointer, which could point to any node in the list, or null.
Construct a deep copy of the list. The deep copy should consist of exactly n brand new nodes, where each new node has its value set to the value of 
its corresponding original node. Both the next and random pointer of the new nodes should point to new nodes in the copied list such that the pointers 
in the original list and copied list represent the same list state. None of the pointers in the new list should point to nodes in the original list.
Input: head = [[7,null],[13,0],[11,4],[10,2],[1,0]]
Output: [[7,null],[13,0],[11,4],[10,2],[1,0]]
"""
# Definition for a Node.
class Node:
    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):
        self.val = int(x)
        self.next = next
        self.random = random


class Solution:
    def __init__(self):
        self.visited = {}
        
    # Approach 1: Recursive         O(n) / O(n)
    def copyRandomList(self, head: 'Optional[Node]') -> 'Optional[Node]':
        if not head:
            return None
        if head in self.visited:
            return self.visited[head]
        
        node = Node(head.val, None, None)
        self.visited[head] = node
        
        node.next = self.copyRandomList(head.next)
        node.random = self.copyRandomList(head.random)
        
        return node


    # Approach 2: Iterative with O(N) Space         O(n) / O(n)
    def copyRandomList(self, head):
        if not head:
            return head

        old_node = head      
        new_node = Node(old_node.val, None, None)
        self.visited[old_node] = new_node

        while old_node != None:
            new_node.next = self.getClonedNode(old_node.next)
            new_node.random = self.getClonedNode(old_node.random)

            old_node = old_node.next
            new_node = new_node.next

        return self.visited[head]

    def getClonedNode(self, node):
        if node:        
            if node in self.visited:
                return self.visited[node]
            else:
                self.visited[node] = Node(node.val, None, None)
                return self.visited[node]
        return None


    # Approach 3: Iterative with O(1) Space         O(n) / O(1)
    # Instead of a separate dictionary to keep the old node --> new node mapping, we can tweak the original linked list and keep 
    # every cloned node next to its original node. This interleaving of old and new nodes allows us to solve this problem without any extra space.
    def copyRandomList(self, head):
        if not head:
            return head

        ptr = head
        while ptr:
            new_node = Node(ptr.val, None, None)
            # Inserting the cloned node just next to the original node:  A->A'->B->B'->C->C'
            new_node.next = ptr.next
            ptr.next = new_node
            ptr = new_node.next

        ptr = head
        while ptr:
            ptr.next.random = ptr.random.next if ptr.random else None
            ptr = ptr.next.next

        # Unweave the linked list to get back the original linked list and the cloned list.
        # i.e. A->A'->B->B'->C->C' would be broken to A->B->C and A'->B'->C'
        ptr_old_list = head # A->B->C
        ptr_new_list = head.next # A'->B'->C'
        head_new = head.next
        while ptr_old_list:
            ptr_old_list.next = ptr_old_list.next.next
            ptr_new_list.next = ptr_new_list.next.next if ptr_new_list.next else None
            ptr_old_list = ptr_old_list.next
            ptr_new_list = ptr_new_list.next
            
        return head_new





# 133. Clone Graph
"""
Given a reference of a node in a connected undirected graph. Return a deep copy (clone) of the graph.
Each node in the graph contains a value (int) and a list (List[Node]) of its neighbors.
"""
# Definition for a Node.
class Node:
    def __init__(self, val = 0, neighbors = None):
        self.val = val
        self.neighbors = neighbors if neighbors is not None else []


class Solution:
    # Approach 1:       BFS
    def cloneGraph(self, node: 'Node') -> 'Node':
        if not node:
            return node
        
        queue = deque([node])
        visited = {}
        visited[node] = Node(node.val, [])
        
        while queue:
            n = queue.popleft()
            for neighbor in n.neighbors:
                if neighbor not in visited:
                    queue.append(neighbor)
                    visited[neighbor] = Node(neighbor.val, [])
                visited[n].neighbors.append(visited[neighbor])
                
        return visited[node]


    # Approach 2:       DFS
    def __init__(self):
        self.visited = {}
        
    def cloneGraph(self, node: 'Node') -> 'Node':
        if not node:
            return node
        if node in self.visited:
            return self.visited[node]
        
        clone_node = Node(node.val, [])
        self.visited[node] = clone_node
        
        if node.neighbors:
            clone_node.neighbors = [self.cloneGraph(n) for n in node.neighbors]
            
        return clone_node

    for _ in range(10): pass         # 为了好看





# 1490. Clone N-ary Tree
"""
Given a root of an N-ary tree, return a deep copy (clone) of the tree.
Each node in the n-ary tree contains a val (int) and a list (List[Node]) of its children.
"""
# Definition for a Node.
class Node:
    def __init__(self, val=None, children=None):
        self.val = val
        self.children = children if children is not None else []


class Solution:
    # Approach 1:       BFS
    def cloneTree(self, root: 'Node') -> 'Node':
        if not root:
            return None
        
        queue = deque([root])
        copy = {}
        copy[root] = Node(root.val, [])
        
        
        while queue:
            node = queue.popleft()
            for child in node.children:
                copy[child] = Node(child.val, [])
                copy[node].children.append(copy[child])
                queue.append(child)
        return copy[root]


    # Approach 2:   Recursion
    def cloneTree(self, root: 'Node') -> 'Node':
        if not root:
            return root

        node_copy = Node(root.val)

        # recursively clone the sub-trees.
        for child in root.children:
            node_copy.children.append(self.cloneTree(child))
        return node_copy


    # Approach 3:   DFS with Iteration
    def cloneTree(self, root: 'Node') -> 'Node':
        if not root:
            return root
        if root:
            node=Node(root.val)
            for i in root.children:
                if not node.children:
                    node.children=list()
                node.children.append(self.cloneTree(i))
        return node

    for _ in range(10): pass         # 为了好看





# 1485. Clone Binary Tree With Random Pointer
"""
A binary tree is given such that each node contains an additional random pointer which could point to any node in the tree or null.
Return a deep copy of the tree.
Input: root = [[1,null],null,[4,3],[7,0]]
Output: [[1,null],null,[4,3],[7,0]]
"""
# Definition for Node.
class Node:
    def __init__(self, val=0, left=None, right=None, random=None):
        self.val = val
        self.left = left
        self.right = right
        self.random = random


class Solution:
    # Approach 1: Iterative Tree Traversal + Hashmap            O(N+N) = O(2N) = O(N) / O(N)
    # 很关键 if we added node.random to the stack in Step 1,  we would enter an infinite recursive loop and receive a TLE error!!!
    def copyRandomBinaryTree(self, root: 'Optional[Node]') -> 'Optional[Node]':
        if not root:
            return None
        
        # Step 1: Create a copy of each node
        copy = {}
        stack = [root]
        while stack:
            node = stack.pop()
            copy[node] = Node(node.val)         # We can guarantee uniqueness by storing the actual node as the key instead of the actual value
            if node.left:
                stack.append(node.left)
            if node.right:
                stack.append(node.right)
        
        # Step 2: Connect the copied nodes together
        stack = [root]
        while stack:
            node = stack.pop()
            if node.left:
                copy[node].left = copy[node.left]
                stack.append(node.left)
            if node.right:
                copy[node].right = copy[node.right]
                stack.append(node.right)
            if node.random:
                copy[node].random = copy[node.random]
                
        return copy[root]


    # Approach 2: Recursive Tree Traversal + Hashmap
    def copyRandomBinaryTree(self, root: 'Node') -> 'Node':
        if not root:
            return None   

        self.copy = {}
        self.dfs_copy(root)
        self.dfs_connect(root)
        return self.copy[root]
    
    def dfs_copy(self, node):
        if not node:
            return

        self.copy[node] = Node(node.val)

        self.dfs_copy(node.left)
        self.dfs_copy(node.right)

        return node

    def dfs_connect(self, node):
        if not node:
            return

        if node.left:
            self.copy[node].left = self.copy[node.left]
        if node.right:
            self.copy[node].right = self.copy[node.right]
        if node.random:
            self.copy[node].random = self.copy[node.random]

        self.dfs_connect(node.left)
        self.dfs_connect(node.right)

        return node





# 1136. Parallel Courses
"""
You are given an integer n, which indicates that there are n courses labeled from 1 to n. You are also given an array relations where 
relations[i] = [prevCoursei, nextCoursei], representing a prerequisite relationship between course prevCoursei and course nextCoursei: 
course prevCoursei has to be taken before course nextCoursei. In one semester, you can take any number of courses as long as you have taken 
all the prerequisites in the previous semester for the courses you are taking.
Return the minimum number of semesters needed to take all courses. If there is no way to take all the courses, return -1.
Input: n = 3, relations = [[1,3],[2,3]]
Output: 2           In the first semester, you can take courses 1 and 2. In the second semester, you can take course 3.
"""
class Solution:
    # Approach 1: Breadth-First Search (Kahn's Algorithm)
    def minimumSemesters(self, n: int, relations: List[List[int]]) -> int:
        graph = {x: [] for x in range(1, n + 1)}
        indegree = {x: 0 for x in range(1, n + 1)}
        
        for prev, curr in relations:
            graph[prev].append(curr)
            indegree[curr] += 1
            
        starting_courses = [x for x in graph if indegree[x] == 0]
        queue = deque(starting_courses)
        semester = counter = 0
        
        while queue:
            semester += 1
            
            for _ in range(len(queue)):
                course = queue.popleft()
                counter += 1
                
                for next_course in graph[course]:
                    indegree[next_course] -= 1
                    if indegree[next_course] == 0:
                        queue.append(next_course)
                        
        return semester if counter == n else -1


    # Approach 2: Depth-First Search: Check for Cycles + Find Longest Path
    # Insight: The number of semesters needed is equal to the length of the longest path in the graph.
    def minimumSemesters(self, n: int, relations: List[List[int]]) -> int:
        graph = {x: [] for x in range(1, n + 1)}
        for start, end in relations:
            graph[start].append(end)
        
        visited = {}
        for node in graph:
            if self.check_cycle(node, graph, visited):
                return -1
        
        return max(self.dfs_max_path(node, graph, {}) for node in graph)
    
    def check_cycle(self, node, graph, visited):
        if node in visited:
            return visited[node]
        else:
            visited[node] = -1      # mark as visiting
            
        for end in graph[node]:
            if self.check_cycle(end, graph, visited):
                return True        # we meet a cycle!
        
        visited[node] = False       # mark as visited
        return False
        
    def dfs_max_path(self, node, graph, visited_length):
        if node in visited_length:
            return visited_length[node]
        max_length = 1
        for end in graph[node]:
            max_length = max(self.dfs_max_path(end, graph, visited_length) + 1, max_length)
        
        visited_length[node] = max_length
        return max_length





# 1494. Parallel Courses II
"""
You are given an integer n, which indicates that there are n courses labeled from 1 to n. You are also given an array relations where 
relations[i] = [prevCoursei, nextCoursei], representing a prerequisite relationship between course prevCoursei and course nextCoursei: 
course prevCoursei has to be taken before course nextCoursei. Also, you are given the integer k.
In one semester, you can take at most k courses as long as you have taken all the prerequisites in the previous semesters for the courses you are taking.
Return the minimum number of semesters needed to take all courses. The testcases will be generated such that it is possible to take every course.
Input: n = 5, dependencies = [[2,1],[3,1],[4,1],[1,5]], k = 2
Output: 4 
"""
class Solution:
    # dp[i] denotes the minimum number of semesters needed to finish all courses while courses[j] has already finished if j-th bit of i is 1, 
    # namely (i >> j) & 1 == 1. Then the answer for the problem is dp[0]. If course j not finished, and the prerequisites courses of courses j 
    # have been finished, then course j can be choosed in current semesters. We just traversal all combinations of at most k courses from all choosable courses, 
    # and find the minimum number of semesters needed for dp[i] = 1 + min(dp[i ^ com] for combination in combinations(chooseable courses, k)).
    def minNumberOfSemesters(self, n: int, relations: List[List[int]], k: int) -> int:
        if k == 1:
            return n
        if not relations:
            return (n + k - 1) // k
        precourse = [0] * (n + 1)
        for prev, curr in relations:
            precourse[curr - 1] |= 1 << (prev - 1)

        def dfs(visited):
            if visited == (1 << n) - 1:
                return 0
            if visited not in memo:
                choosable = []
                res = n
                for i in range(n):
                    if (visited >> i) & 1 == 0 and precourse[i] & visited == precourse[i]:
                        choosable.append(i)
                for com in combinations(choosable, min(len(choosable), k)):
                    nx_visited = visited
                    for c in com:
                        nx_visited |= 1 << c
                    res = min(res, dfs(nx_visited) + 1)
                memo[visited] = res
            return memo[visited]

        memo = defaultdict(int)
        return dfs(0)





# 2050. Parallel Courses III
"""
You are given an integer n, which indicates that there are n courses labeled from 1 to n. You are also given a 2D integer array relations 
where relations[j] = [prevCoursej, nextCoursej] denotes that course prevCoursej has to be completed before course nextCoursej (prerequisite relationship). 
Furthermore, you are given a 0-indexed integer array time where time[i] denotes how many months it takes to complete the (i+1)th course.
You must find the minimum number of months needed to complete all the courses following these rules:
    You may start taking a course at any time if the prerequisites are met.
    Any number of courses can be taken at the same time.
Return the minimum number of months needed to complete all the courses.
Note: The test cases are generated such that it is possible to complete every course (i.e., the graph is a directed acyclic graph).
Input: n = 3, relations = [[1,3],[2,3]], time = [3,2,5]
Output: 8       We start course 1 and course 2 simultaneously at month 0. Course 1 takes 3 months and course 2 takes 2 months to complete respectively.
                Thus, the earliest time we can start course 3 is at month 3, and the total time required is 3 + 5 = 8 months.
"""
class Solution:
    # 由于题目保证图是一个有向无环图，所以一定存在拓扑排序。可以在求拓扑排序的同时，计算状态转移
    def minimumTime(self, n: int, relations: List[List[int]], time: List[int]) -> int:
        dp = [0] + [t for t in time]        # dp[i]表示完成第i门课程需要花费的最少月份数， 注意index
        res = 0
        indegree = {x: 0 for x in range(1, n + 1)}
        graph = {x: set() for x in range(1, n + 1)}
        for prev, curr in relations:
            graph[prev].add(curr)
            indegree[curr] += 1
            
        starting_courses = [v for v in range(1, n + 1) if indegree[v] == 0]
        queue = deque(starting_courses)

        while queue:
            s = queue.popleft()     # can be any sequence to delete
            res = max(res, dp[s])
            for v in graph[s]:
                dp[v] = max(dp[v], dp[s] + time[v-1])
                indegree[v] -= 1
                if indegree[v] == 0:
                    queue.append(v)
        return res

    for _ in range(10): pass         # 为了好看





# 1197. Minimum Knight Moves
"""
In an infinite chess board with coordinates from -infinity to +infinity, you have a knight at square [0, 0].
A knight has 8 possible moves it can make, as illustrated below. Each move is two squares in a cardinal direction, then one square in an orthogonal direction.
"""
DIRECTIONS = [(1, 2), (2, 1), (2, -1), (1, -2), (-1, -2), (-2, -1), (-2, 1), (-1, 2)]

class Solution:
    # Approach 1: BFS (Breadth-First Search)  TLE
    def minKnightMoves(self, x: int, y: int) -> int:
        queue = deque([(0, 0)])
        visited = set((0, 0))
        path = -1
        
        while queue:
            path += 1
            
            for _ in range(len(queue)):
                pos = queue.popleft()
                if pos == (x, y):
                    return path
        
                for dx, dy in DIRECTIONS:
                    next_x, next_y = pos[0] + dx, pos[1] + dy
                    if (next_x, next_y) not in visited:
                        queue.append((next_x, next_y))
                        visited.add((next_x, next_y))
        return -1


    # Approach 2: Bidirectional BFS
    def minKnightMoves(self, x: int, y: int) -> int:
        origin_queue = deque([(0, 0, 0)])
        origin_distance = {(0, 0): 0}

        target_queue = deque([(x, y, 0)])
        target_distance = {(x, y): 0}

        while True:
            origin_x, origin_y, origin_steps = origin_queue.popleft()
            if (origin_x, origin_y) in target_distance:
                return origin_steps + target_distance[(origin_x, origin_y)]

            target_x, target_y, target_steps = target_queue.popleft()
            if (target_x, target_y) in origin_distance:
                return target_steps + origin_distance[(target_x, target_y)]

            for dx, dy in DIRECTIONS:
                next_origin_x, next_origin_y = origin_x + dx, origin_y + dy
                if (next_origin_x, next_origin_y) not in origin_distance:
                    origin_queue.append((next_origin_x, next_origin_y, origin_steps + 1))
                    origin_distance[(next_origin_x, next_origin_y)] = origin_steps + 1

                next_target_x, next_target_y = target_x + dx, target_y + dy
                if (next_target_x, next_target_y) not in target_distance:
                    target_queue.append((next_target_x, next_target_y, target_steps + 1))
                    target_distance[(next_target_x, next_target_y)] = target_steps + 1

    for _ in range(10): pass         # 为了好看


    # Approach 3: DFS (Depth-First Search) with Memoization
    def minKnightMoves(self, x: int, y: int) -> int:

        @functools.lru_cache(maxsize=None)
        def dfs(x, y):
            if x + y == 0:
                # base case: (0, 0)
                return 0
            elif x + y == 2:
                # base case: (1, 1), (0, 2), (2, 0)
                return 2
            else:
                return min(dfs(abs(x - 1), abs(y - 2)), dfs(abs(x - 2), abs(y - 1))) + 1

        return dfs(abs(x), abs(y))





# 1188. Design Bounded Blocking Queue
"""
Implement a thread-safe bounded blocking queue that has the following methods:

BoundedBlockingQueue(int capacity):     The constructor initializes the queue with a maximum capacity.
void enqueue(int element):              Adds an element to the front of the queue. If the queue is full, the calling thread is blocked until the queue is no longer full.
int dequeue():                          Returns the element at the rear of the queue and removes it. If the queue is empty, the calling thread is blocked until 
                                        the queue is no longer empty.
int size():                             Returns the number of elements currently in the queue.
Your implementation will be tested using multiple threads at the same time. Each thread will either be a producer thread that only makes calls to the enqueue method 
or a consumer thread that only makes calls to the dequeue method. The size method will be called after every test case.
Please do not use built-in implementations of bounded blocking queue as this will not be accepted in an interview.

Input:      1   1
["BoundedBlockingQueue","enqueue","dequeue","dequeue","enqueue","enqueue","enqueue","enqueue","dequeue"]
[[2],[1],[],[],[0],[2],[3],[4],[]]
Output:     [1,0,2,2]
"""
# Basically the core is to ensure we can not pop when empty, we can not push when full.
# We can have a push semaphore object, initialized as capacity, -1 at each push, thus, new push will wait when it reaches 0. We +1 at each pop to free up the capacity.
# We can have a pop semaphore object, initialized as 0, so initially we can not pop. New pop will -1 it and new push will +1 it to reflect the capacity usage
# Also, we use deque so that popleft is O(1)
from threading import Semaphore

class BoundedBlockingQueue(object):

    def __init__(self, capacity: int):
        self.queue = deque()
        self.push = Semaphore(capacity)
        self.pop = Semaphore(0)

    def enqueue(self, element: int) -> None:
        self.push.acquire()
        self.queue.append(element)
        self.pop.release()
        
    def dequeue(self) -> int:
        self.pop.acquire()
        ret = self.queue.popleft()
        self.push.release()
        return ret

    def size(self) -> int:
        return len(self.queue)

    for _ in range(10): pass         # 为了好看





# 529. Minesweeper
"""
You are given an m x n char matrix board representing the game board where:
    'M' represents an unrevealed mine,
    'E' represents an unrevealed empty square,
    'B' represents a revealed blank square that has no adjacent mines (i.e., above, below, left, right, and all 4 diagonals),
    digit ('1' to '8') represents how many mines are adjacent to this revealed square, and
    'X' represents a revealed mine.
You are also given an integer array click where click = [clickr, clickc] represents the next click position among all the unrevealed squares ('M' or 'E').
1. If a mine 'M' is revealed, then the game is over. You should change it to 'X'.
2. If an empty square 'E' with no adjacent mines is revealed, then change it to a revealed blank 'B' and all of its adjacent unrevealed squares should be revealed recursively.
3. If an empty square 'E' with at least one adjacent mine is revealed, then change it to a digit ('1' to '8') representing the number of adjacent mines.
4. Return the board when no more squares will be revealed.
"""
DIRECTIONS = [(-1, 0), (-1, 1), (0, 1), (1, 1), (1, 0), (1, -1), (0, -1), (-1, -1)]

class Solution:
    def updateBoard(self, board: List[List[str]], click: List[int]) -> List[List[str]]:
        m, n = len(board), len(board[0])
        i, j = click[0], click[1]
        if board[i][j] == 'M':
            board[i][j] = 'X'
        else:
            queue = deque([(i, j)])
            while queue:
                x, y = queue.popleft()
                if board[x][y] != 'E':
                    continue
                num_mines = 0
                # First count the number of mines
                for dx, dy in DIRECTIONS:
                    next_x, next_y = x + dx, y + dy
                    if not (0 <= next_x < m and 0 <= next_y < n):
                        continue
                    if board[next_x][next_y] == 'M':
                        num_mines += 1
                # Two cases depending on the number of mines, continue bfs or change value
                if not num_mines: 
                    board[x][y] = 'B'
                    for dx, dy in DIRECTIONS:
                        next_x, next_y = x + dx, y + dy
                        if not (0 <= next_x < m and 0 <= next_y < n):
                            continue
                        queue.append((next_x, next_y))
                else: 
                    board[x][y] = str(num_mines)

        return board


    # DFS
    def updateBoard(self, board: List[List[str]], click: List[int]) -> List[List[str]]:
        row, col = len(board), len(board[0])
        
        def dfs(x, y):
            if board[x][y] == 'M': 
                board[x][y] = 'X'
            elif board[x][y] == 'E':
                num_mines, nei = 0, []
                for dx, dy in DIRECTIONS:
                    next_x, next_y = x + dx, y + dy
                    if 0 <= next_x < row and 0 <= next_y < col:
                        nei.append((next_x, next_y))
                        if board[next_x][next_y] == 'M': 
                            num_mines += 1
                if not num_mines:
                    board[x][y] = 'B'
                    for r, c in nei: 
                        dfs(r, c)
                else: 
                    board[x][y] = str(num_mines)
                    
        dfs(*click)            
        return board





# 494. Target Sum
"""
You are given an integer array nums and an integer target.
You want to build an expression out of nums by adding one of the symbols '+' and '-' before each integer in nums and then concatenate all the integers.
For example, if nums = [2, 1], you can add a '+' before 2 and a '-' before 1 and concatenate them to build the expression "+2-1".
Return the number of different expressions that you can build, which evaluates to target.
Input: nums = [1,1,1,1,1], target = 3
Output: 5
"""
class Solution:
    def findTargetSumWays(self, nums: List[int], target: int) -> int:
        n, memo = len(nums), defaultdict(int)
        
        def dfs(s, i):
            if i == n and s == target:
                return 1
            elif i >= n:
                return 0
            
            if (s, i) in memo:
                return memo[(s, i)]
            
            res = 0
            res += dfs(s + nums[i], i + 1)
            res += dfs(s - nums[i], i + 1)
            
            memo[(s, i)] = res
            return res
        
        return dfs(0, 0)





# 542. 01 Matrix
"""
Given an m x n binary matrix mat, return the distance of the nearest 0 for each cell. The distance between two adjacent cells is 1.
Input: mat = [[0,0,0],[0,1,0],[1,1,1]]
Output: [[0,0,0],[0,1,0],[1,2,1]]
"""
class Solution:
    def updateMatrix(self, grid: List[List[int]]) -> List[List[int]]:
        q = deque()
        visited = set()
        n = len(grid)
        m = len(grid[0])
        for i in range(n) :
            for j in range(m) :
                if grid[i][j] == 0 :
                    q.append([i, j])
                    visited.add((i, j))
        
        while q :
            x, y = q.popleft()
            for (i ,j) in ((x-1, y), (x, y-1), (x+1, y), (x, y+1)) :
                if i >= 0 and i < n and j >= 0 and j < m :
                    if (i, j) not in visited :
                        grid[i][j] = grid[x][y] + 1
                        visited.add((i ,j))
                        q.append([i, j])
        return grid





# 12. Integer to Roman
"""
Given an integer, convert it to a roman numeral. 
Symbol       Value
I             1
V             5
X             10
L             50
C             100
D             500
M             1000
Input: num = 58
Output: "LVIII"
Explanation: L = 50, V = 5, III = 3.
Input: num = 1994
Output: "MCMXCIV"
Explanation: M = 1000, CM = 900, XC = 90 and IV = 4.
"""
class Solution:
    def intToRoman(self, num: int) -> str:
        digits = [(1000, "M"), (900, "CM"), (500, "D"), (400, "CD"), (100, "C"), 
                  (90, "XC"), (50, "L"), (40, "XL"), (10, "X"), (9, "IX"), 
                  (5, "V"), (4, "IV"), (1, "I")]
        
        roman_digits = []
        for value, symbol in digits:
            if num == 0: break
            count, num = divmod(num, value)
            roman_digits.append(symbol * count)
            
        return "".join(roman_digits)

    for _ in range(10): pass         # 为了好看





# 273. Integer to English Words
"""
Convert a non-negative integer num to its English words representation.
Input: num = 12345
Output: "Twelve Thousand Three Hundred Forty Five"
Input: num = 1234567
Output: "One Million Two Hundred Thirty Four Thousand Five Hundred Sixty Seven"
"""
from collections import deque
class Solution:
    def numberToWords(self, num: int) -> str:
        dic = {
            1000000000: "Billion",
            1000000: "Million",
            1000: "Thousand",
            100: "Hundred",
            90: "Ninety",
            80: "Eighty",
            70: "Seventy",
            60: "Sixty",
            50: "Fifty",
            40: "Forty",
            30: "Thirty",
            20: "Twenty",
            19: "Nineteen",
            18: "Eighteen",
            17: "Seventeen",
            16: "Sixteen",
            15: "Fifteen",
            14: "Fourteen",
            13: "Thirteen",
            12: "Twelve",
            11: "Eleven",
            10: "Ten",
            9: "Nine",
            8: "Eight",
            7: "Seven",
            6: "Six",
            5: "Five",
            4: "Four",
            3: "Three",
            2: "Two",
            1: "One",
            0: "Zero",
        }
        if num == 0: return dic[0]
        
        segments = [float("inf"), 1000000000, 1000000, 1000, 100, 90, 80, 70, 60, 50, 40, 30, 20]
        
        def numberToWords(number):
            nonlocal dic, segments
            ret = deque()
            for i in range(1, len(segments)):
                if segments[i] <= number < segments[i-1]:
                    div, rest = number // segments[i], number % segments[i]
                    ret.append(dic[segments[i]])
                    if rest > 0: ret.append(numberToWords(rest))
                    # We say "One Hundred", "One thoushand" but we don't say "One Fifty", we simply say "Fifty":
                    if div > 0 and i < 5: ret.appendleft(numberToWords(div))
                    return " ".join(ret)
            return dic[number]
            
        return numberToWords(num)





# 62. Unique Paths
"""
There is a robot on an m x n grid. The robot is initially located at the top-left corner (i.e., grid[0][0]). The robot tries to move to the 
bottom-right corner (i.e., grid[m - 1][n - 1]). The robot can only move either down or right at any point in time.
Given the two integers m and n, return the number of possible unique paths that the robot can take to reach the bottom-right corner.
Input: m = 3, n = 7
Output: 28
"""
class Solution:
    def uniquePaths(self, m: int, n: int) -> int:
        d = [[1] * n for _ in range(m)]

        for col in range(1, m):
            for row in range(1, n):
                d[col][row] = d[col - 1][row] + d[col][row - 1]

        return d[m - 1][n - 1]
        
        
    # Approach 2:       DFS + memo
    DIRECTIONS = [(1, 0), (0, 1)]
    def uniquePaths(self, m: int, n: int) -> int:
        memo = {}
        result = self.TotalPaths(0, 0, m, n, memo)
        return result
    
    def TotalPaths(self, row, column, m, n, memo):
        if (row, column) in memo:
            return memo[(row, column)]

        if row == m - 1 or column == n - 1:
            memo[(row, column)] = 1
            return memo[(row, column)]

        memo[(row, column)] = 0     # 初始化key，key肯定不在memo里，否则上面就会直接返回已经存在了的memo[key]

        for direction in self.DIRECTIONS:
            memo[(row, column)] += self.TotalPaths(row + direction[0], column + direction[1], m, n, memo)
        
        return memo[(row, column)]





# 63. Unique Paths II
"""
You are given an m x n integer array grid. There is a robot initially located at the top-left corner (i.e., grid[0][0]). 
The robot tries to move to the bottom-right corner (i.e., grid[m-1][n-1]). The robot can only move either down or right at any point in time.
An obstacle and space are marked as 1 or 0 respectively in grid. A path that the robot takes cannot include any square that is an obstacle.
Return the number of possible unique paths that the robot can take to reach the bottom-right corner.
Input: obstacleGrid = [[0,0],[0,1]]
Output: 0
"""
DIRECTIONS = [(1, 0), (0, 1)]

class Solution:
    def uniquePathsWithObstacles(self, obstacleGrid: List[List[int]]) -> int:
        n,m = len(obstacleGrid),len(obstacleGrid[0])
        if n == 0 and m == 0:
            return 0

        dp=[[0] * m for _ in range(n)]
        if obstacleGrid[0][0] == 0:
            dp[0][0] = 1

        for i in range(0,n):
            for j in range(0,m):
                if i == 0 and j == 0:
                    continue
                #若遇到障碍物，则跳过
                if obstacleGrid[i][j] == 1:
                    continue
                #对于上边界，第一个障碍物或边界左边的所有边界点皆可到达
                if i == 0:
                    dp[i][j] = dp[i][j-1]
                    continue
                #对于左边界，第一个障碍物或边界前的所有边界点皆可到达
                if j == 0:
                    dp[i][j] = dp[i-1][j]
                    continue
                #到达当前点的路径数等于能到达此点上面的点和左边点的路径数之和
                dp[i][j] = dp[i-1][j] + dp[i][j-1]

        return dp[n-1][m-1]


    # Approach 2:       DFS + memo
    def uniquePathsWithObstacles(self, obstacleGrid: List[List[int]]) -> int:
        memo = {}
        result = self.dfs(obstacleGrid, 0, 0, memo)
        return result
    
    def dfs(self, grid, x, y, memo):
        if (x, y) in memo:
            return memo[(x, y)]
        if x == len(grid) - 1 and y == len(grid[0]) - 1:    # 这里注意是and不是or，因为如果障碍物出现在边上，不仅仅当前点为0，整个边上的点都需要更新为0
            if grid[x][y] == 1:
                return 0
            else:
                memo[(x, y)] = 1
                return 1
        
        if x >= len(grid) or y >= len(grid[0]):
            return 0
        if grid[x][y] == 1:
            memo[(x, y)] = 0
            return 0
        
        memo[(x, y)] = 0
        for dx, dy in DIRECTIONS:
            memo[(x, y)] += self.dfs(grid, x + dx, y + dy, memo)
        # right = self.dfs(grid, x, y + 1, memo)
        # down = self.dfs(grid, x + 1, y, memo)
        # memo[(x, y)] = right + down
            
        return memo[(x, y)]





# 980. Unique Paths III
"""
You are given an m x n integer array grid where grid[i][j] could be:
    1 representing the starting square. There is exactly one starting square.
    2 representing the ending square. There is exactly one ending square.
    0 representing empty squares we can walk over.
    -1 representing obstacles that we cannot walk over.
Return the number of 4-directional walks from the starting square to the ending square, that walk over every non-obstacle square exactly once.
Input: grid = [[1,0,0,0],[0,0,0,0],[0,0,2,-1]]
Output: 2   Explanation: We have the following two paths: 
1. (0,0),(0,1),(0,2),(0,3),(1,3),(1,2),(1,1),(1,0),(2,0),(2,1),(2,2)
2. (0,0),(1,0),(2,0),(2,1),(1,1),(0,1),(0,2),(0,3),(1,3),(1,2),(2,2)
"""
DIRECTIONS = [(0, -1), (0, 1), (-1, 0), (1, 0)]

class Solution:
    def uniquePathsIII(self, grid: List[List[int]]) -> int:
        n, m = len(grid), len(grid[0])
        self.result =  0
        visited = [[0] * m for _ in range(n)]
        
        non_obstacles = 0
        start_row, start_col = 0, 0
        for i in range(n):
            for j in range(m):
                if grid[i][j] >= 0:
                    non_obstacles += 1
                if grid[i][j] == 1:
                    start_row, start_col = i, j
        self.dfs(grid, start_row, start_col, m, n, visited, non_obstacles)
        return self.result

    def dfs(self, grid, x, y, m, n, visited, remain):
        if grid[x][y] == 2 and remain == 1:
            self.result += 1
            return
        
        visited[x][y] = 1       # mark the current cell as visited
        remain -= 1             # Can optimize space by using In-place Modification, like: grid[row][col] = -4

        for dx, dy in DIRECTIONS:
            next_x, next_y = x + dx, y + dy
            if not (0 <= next_x < n and 0 <= next_y < m):
                continue    
            if visited[next_x][next_y]:
                continue
            if grid[next_x][next_y] == -1:
                continue
            
            self.dfs(grid, next_x, next_y, m, n, visited, remain)
            
        visited[x][y] = 0       # unmark the current cell





# 64. Minimum Path Sum
"""
Given a m x n grid filled with non-negative numbers, find a path from top left to bottom right, which minimizes the sum of all numbers along its path.
Note: You can only move either down or right at any point in time.
Input: grid = [[1,3,1],[1,5,1],[4,2,1]]
Output: 7
"""
class Solution:
    # Approach 1:   DP
    def minPathSum(self, grid: List[List[int]]) -> int:
        m, n = len(grid), len(grid[0])
        dp = [[float('inf') for _ in range(n)] for _ in range(m)]
        dp[0][0] = grid[0][0]
        
        for r in range(m):
            for c in range(n):
                if r == 0 and c > 0:
                    dp[r][c] = dp[r][c-1] + grid[r][c]
                elif c == 0 and r > 0:
                    dp[r][c] = dp[r-1][c] + grid[r][c]
                elif r > 0 and c > 0:
                    dp[r][c] = min(dp[r-1][c], dp[r][c-1]) + grid[r][c]
        
        return dp[m - 1][n - 1]
    
    
    # Approach 2:   DFS + Memo
    def minPathSum(self, grid: List[List[int]]) -> int:
        m, n = len(grid), len(grid[0])
        memo = [[float('inf') for _ in range(n)] for _ in range(m)]
        return self.dfs(grid, 0, 0, m, n, memo)
    
    def dfs(self, grid, x, y, m, n, memo):
        if x >= m or y >= n:
            return float('inf')
        if x == m - 1 and y == n - 1:
            memo[x][y] = grid[x][y]
            return grid[x][y]
        if memo[x][y] != float('inf'):
            return memo[x][y]
        
        right = self.dfs(grid, x, y + 1, m, n, memo)
        down = self.dfs(grid, x + 1, y, m, n, memo)
        
        memo[x][y] = min(right, down) + grid[x][y]
        return memo[x][y]





# 1921. Eliminate Maximum Number of Monsters
"""
You are playing a video game where you are defending your city from a group of n monsters. You are given a 0-indexed integer array dist of size n, 
where dist[i] is the initial distance in kilometers of the ith monster from the city. The monsters walk toward the city at a constant speed. 
The speed of each monster is given to you in an integer array speed of size n, where speed[i] is the speed of the ith monster in kilometers per minute.
You have a weapon that, once fully charged, can eliminate a single monster. However, the weapon takes one minute to charge.The weapon is fully charged at the very start.
You lose when any monster reaches your city. If a monster reaches the city at the exact moment the weapon is fully charged, it counts as a loss, and the game ends before you can 
use your weapon. Return the maximum number of monsters that you can eliminate before you lose, or n if you can eliminate all the monsters before they reach the city.
Input: dist = [3,2,4], speed = [5,3,2]
Output: 1
"""
class Solution:
    # 排序 + 贪心
    def eliminateMaximum(self, dist: List[int], speed: List[int]) -> int:
        n = len(dist)
        time = [(dist[i] - 1) // speed[i] for i in range(n)]
        time.sort()
        for i in range(n):
            if time[i] < i:
                return i
        return n





# 1937. Maximum Number of Points with Cost
"""
You are given an m x n integer matrix points (0-indexed). Starting with 0 points, you want to maximize the number of points you can get from the matrix.
To gain points, you must pick one cell in each row. Picking the cell at coordinates (r, c) will add points[r][c] to your score.
However, you will lose points if you pick a cell too far from the cell that you picked in the previous row. For every two adjacent rows r and r + 1 (where 0 <= r < m - 1), 
picking cells at coordinates (r, c1) and (r + 1, c2) will subtract abs(c1 - c2) from your score. Return the maximum number of points you can achieve.
Input: points = [[1,2,3],[1,5,1],[3,1,1]]
Output: 9
"""
class Solution:
    # Approach 1:       DP 同一行里的左右比较
    def maxPoints(self, points: List[List[int]]) -> int:
        m, n = len(points), len(points[0])
        for i in range(m - 1):
            for j in range(1, n):
                points[i][j] = max(points[i][j], points[i][j - 1] - 1)
            
            for j in range(n - 2, -1, -1):
                points[i][j] = max(points[i][j], points[i][j + 1] - 1)
            
            for j in range(n):
                points[i + 1][j] += points[i][j]
        
        return max(points[m - 1])
    
    # Approach 2:       DP优化 上下行比较
    def maxPoints(self, points: List[List[int]]) -> int:
        m, n = len(points), len(points[0])
        f = [0] * n
        
        for i in range(m):
            g = [0] * n
            
            max_val = float('-inf')
            for j in range(n):
                max_val = max(max_val, f[j] + j)
                g[j] = max_val + points[i][j] - j       # 此行相当于第一遍赋值，没有比较大小，所以不用max，下面第二遍从后往前扫才是比较
                # g[j] = max(g[j], max_val + points[i][j] - j)
                
            max_val = float('-inf')
            for j in range(n - 1, -1, -1):
                max_val = max(max_val, f[j] - j)
                g[j] = max(g[j], max_val + points[i][j] + j)
                
            f = g
            
        return max(f)





# 1981. Minimize the Difference Between Target and Chosen Elements
"""
You are given an m x n integer matrix mat and an integer target.
Choose one integer from each row in the matrix such that the absolute difference between target and the sum of the chosen elements is minimized.
Return the minimum absolute difference. The absolute difference between two numbers a and b is the absolute value of a - b.
Input: mat = [[1,2,3],[4,5,6],[7,8,9]], target = 13
Output: 0
"""
class Solution:
    # Approach 1:       背包DP  使用 large， next_large间切换来存储第0，1，...，i-1 行的每一行的最大值之和
    #                   这样一来，对于第 i 行的数 x ，j 的枚举范围就是 [x, large + x]
    def minimizeTheDifference(self, mat: List[List[int]], target: int) -> int:
        m, n = len(mat), len(mat[0])
        f = {0}
        large = float('inf')
        for i in range(m):
            g = set()
            next_large = float('inf')
            for x in mat[i]:
                for j in f:
                    if j + x >= target:
                        next_large = min(next_large, j + x)
                    else:
                        g.add(j + x)
                next_large = min(next_large, large + x)
            f = g
            large = next_large
            print(large)
            print(g)
            
        ans = abs(large - target)
        for x in f:
            ans = min(ans, abs(x - target))
        return ans
    
    # Approach 2:       DFS + Prune  不推荐
    def minimizeTheDifference(self, mat: List[List[int]], target: int) -> int:
        @functools.lru_cache(None)
        def dfs(i, now):
            nonlocal ans
            if i == m:
                ans = min(ans, abs(now - target))
                return
            for j in range(n):
                if j > 0 and now + mat[i][j-1] >= target: break
                dfs(i + 1, now + mat[i][j])
                
        m, n = len(mat), len(mat[0])
        ans = float('inf')
        for i in range(m):
            mat[i].sort()
        dfs.cache_clear()
        dfs(0, 0)
        return ans





# 209. Minimum Size Subarray Sum
"""
Given an array of positive integers nums and a positive integer target, return the minimal length of a contiguous subarray 
[numsl, numsl+1, ..., numsr-1, numsr] of which the sum is greater than or equal to target. If there is no such subarray, return 0 instead.
Input: target = 7, nums = [2,3,1,2,4,3]
Output: 2
"""
class Solution:
    def minSubArrayLen(self, target: int, nums: List[int]) -> int:
        left, curr_sum, minLen = 0, 0, len(nums) + 1
        for right, num in enumerate(nums):
            curr_sum += num
            
            while curr_sum >= target:       # 注意大于等于和下面 right-left+1
                minLen = min(minLen, right - left + 1)
                curr_sum -= nums[left]
                left += 1
                
        return minLen if minLen != len(nums) + 1 else 0





# 581. Shortest Unsorted Continuous Subarray
"""
Given an integer array nums, you need to find one continuous subarray that if you only sort this subarray in ascending order, then the whole array will be sorted in ascending order.
Return the shortest such subarray and output its length.
Input: nums = [2,6,4,8,10,9,15]     nums = [1, 3, 2, 2, 2]
Output: 5                                   4
"""
class Solution:
    def findUnsortedSubarray(self, nums: List[int]) -> int:
        is_same = [a == b for a, b in zip(nums, sorted(nums))]
        return 0 if all(is_same) else len(nums) - is_same.index(False) - is_same[::-1].index(False)
    
    def findUnsortedSubarray(self, nums):
        res = [i for (i, (a, b)) in enumerate(zip(nums, sorted(nums))) if a != b]
        return 0 if not res else res[-1] - res[0] + 1
    
    def findUnsortedSubarray(self, A):
        return len(''.join(('.', ' ')[m == n] for m, n in zip(sorted(A), A)).strip())
    
    def findUnsortedSubarray(self, n: List[int]) -> int:
        l = next((i for i in range(len(n) - 1) if n[i] > n[i + 1]), len(n))
        # l = next(filter(lambda i: n[i] > n[i + 1], range(len(n) - 1)), len(n))
        r = next((i for i in range(len(n) - 1, 0, -1) if n[i - 1] > n[i]), -1)
        lm, rm = min(n[l:r + 1], default=math.inf), max(n[l:r + 1], default=math.inf)
        l = next((i for i in range(l) if n[i] > lm), l)
        r = next((i for i in range(r + 1, len(n)) if n[i] >= rm), len(n)) - 1
        return max(0, r - l + 1)
    
    
    # time complexity is O(n), we iterate just several times through our data. Space complexity is also O(n), 
    # which can also be reduced to O(1), but in my opinion the solution becomes much less intuitive.
    def findUnsortedSubarray(self, nums):
        nums = [-float("inf")] + nums + [float("inf")]
        run_max = list(accumulate(nums, max))
        run_min = list(accumulate(nums[::-1], min))[::-1]
        
        end, beg = len(nums) - 1, 0
        while nums[end-1] <= nums[end] and run_max[end-1] <= nums[end - 1]:
            end -= 1
        if end == 0: return 0
        while nums[beg+1] >= nums[beg] and run_min[beg+1] >= nums[beg + 1]:
            beg += 1
            
        return end - beg - 1





# 76. Minimum Window Substring
"""
Given two strings s and t of lengths m and n respectively, return the minimum window substring of s such that 
every character in t (including duplicates) is included in the window. If there is no such substring, return the empty string "".
The testcases will be generated such that the answer is unique. A substring is a contiguous sequence of characters within the string.
Input: s = "ADOBECODEBANC", t = "ABC"
Output: "BANC"
"""
class Solution:
    def minWindow(self, s: str, t: str) -> str:
        counter_s, counter_t = {}, {}
        for char in t:
            counter_t[char] = counter_t.get(char, 0) + 1
        left, start, valid, minLen = 0, -1, 0, len(s) + 1
        
        for right in range(len(s)):
            char = s[right]
            if char in counter_t:
                counter_s[char] = counter_s.get(char, 0) + 1
                if counter_s[char] == counter_t[char]:      # 这里判断valid必须是相等，不能是大于等于
                    valid += 1
                    
            while valid == len(counter_t):      # 判断左窗口是否要收缩
                if right - left < minLen:
                    minLen = right - left
                    start = left
                left_char = s[left]
                if left_char in counter_s:
                    counter_s[left_char] -= 1
                    if counter_s[left_char] < counter_t[left_char]:
                        valid -= 1
                left += 1
                
        if start == -1:
            return ""
        return s[start: start + minLen + 1]





# 30. Substring with Concatenation of All Words
"""
You are given a string s and an array of strings words of the same length. Return all starting indices of substring(s) in s 
that is a concatenation of each word in words exactly once, in any order, and without any intervening characters.
You can return the answer in any order.
Input: s = "barfoothefoobarman", words = ["foo","bar"]
Output: [0,9]
"""
class Solution:
    def findSubstring(self, s: str, words: List[str]) -> List[int]:
        n = len(s)
        k = len(words)
        word_length = len(words[0])
        substring_size = word_length * k
        dictionary = Counter(words)
        
        def sliding_window(left):
            word_count = defaultdict(int)
            words_used = 0
            excess_word = False
            
            for right in range(left, n, word_length):
                if right + word_length > n:
                    break

                sub = s[right : right + word_length]
                if sub not in dictionary:
                    # Mismatched word - reset the window
                    word_count = defaultdict(int)
                    words_used = 0
                    excess_word = False
                    left = right + word_length # Retry at the next index
                else:
                    # If we reached max window size or have an excess word
                    while right - left == substring_size or excess_word:
                        # Move the left bound over continously
                        leftmost_word = s[left : left + word_length]
                        left += word_length
                        word_count[leftmost_word] -= 1

                        if word_count[leftmost_word] == dictionary[leftmost_word]:
                            excess_word = False
                        else:
                            words_used -= 1     # We need this word
                    
                    # Keep track of how many times this word occurs in the window
                    word_count[sub] += 1
                    if word_count[sub] <= dictionary[sub]:
                        words_used += 1
                    else:
                        excess_word = True
                    
                    if words_used == k and not excess_word:
                        answer.append(left)
        
        answer = []
        for i in range(word_length):
            sliding_window(i)
        return answer





# 727. Minimum Window Subsequence
"""
Given strings s1 and s2, return the minimum contiguous substring part of s1, so that s2 is a subsequence of the part.
If there is no such window in s1 that covers all characters in s2, return the empty string "". 
If there are multiple such minimum-length windows, return the one with the left-most starting index.
Input: s1 = "abcdebdde", s2 = "bde"
Output: "bcde"
"""
class Solution:
    # Approach 1:       双指针，O(mn)
    def minWindow(self, S: str, T: str) -> str:
        m, n = len(S), len(T)
        if m < n:
            S, T = T, S
        start_index, minLen = -1, float('inf')
        s_pt, t_pt = 0, 0
        
        while s_pt < m:
            if S[s_pt] == T[t_pt]:
                t_pt += 1 # Short string move forward
                if t_pt == n: 
                    # short string reach ending
                    end_index = s_pt
                    t_pt -= 1
                    # try to find the the start index of S closest to the end index of S
                    while t_pt >= 0:
                        if S[s_pt] == T[t_pt]:
                            t_pt -= 1
                        s_pt -= 1
                    # Over walk by 1
                    t_pt += 1
                    s_pt += 1
                    if (end_index - s_pt + 1) < minLen:
                        start_index, minLen = s_pt, end_index - s_pt + 1
            s_pt += 1
            
        return S[start_index:(start_index + minLen)] if start_index != -1 else ''


    # Approach 2:       DFS + Memo
    def minWindow(self, S: str, T: str) -> str:
        def dfs(i, j):
            if j == len(T): return i
            if (i, j) not in memo:
                index = S.find(T[j], i + 1)
                memo[(i, j)] = float('inf') if index == -1 else dfs(index, j + 1)
            return memo[(i, j)]
            
        l, res, memo = float('inf'), '', {}
        for i, s in enumerate(S):
            if s == T[0]:
                j = dfs(i, 1)
                if j - i < l:
                    l, res = j - i, S[i:j + 1]
        return res


    # Approach 3:       DP
    def minWindow(self, S: str, T: str) -> str:
        n, m = len(S), len(T)
        dp = [[-1] * (n + 1) for _ in range(m + 1)]
        for j in range(n + 1):
            dp[0][j] = j # Case 0 (Intialize): empty string
        
        for i in range(1, m + 1):
            for j in range(1, n + 1):
                if T[i - 1] == S[j - 1]:
                    dp[i][j] = dp[i - 1][j - 1]
                else:
                    dp[i][j] = dp[i][j - 1]
        # Look through last row, to find the minimun window
        minLen, st = float('inf'), -1
        for length in range(n + 1):
            if dp[m][length] != -1 and length - dp[m][length] < minLen:
                st, minLen = dp[m][length], (length - dp[m][length])
                
        return S[st: st + minLen] if st != -1 else ''





# 674. Longest Continuous Increasing Subsequence
"""
Given an unsorted array of integers nums, return the length of the longest continuous increasing subsequence (i.e. subarray). The subsequence must be strictly increasing.
Input: nums = [1,3,5,4,7]
Output: 3
"""
class Solution:
    def findLengthOfLCIS(self, nums: List[int]) -> int:
        if not nums or len(nums) == 0:
            return 0
        if len(nums) == 1:
            return 1
        
        ans = 0
        right = 1
        while right < len(nums):
            left = right - 1
            while right < len(nums) and nums[right] > nums[right - 1]:
                right += 1
            ans = max(ans, right - left)
            right += 1
            
        return ans





# 300. Longest Increasing Subsequence
"""
Given an integer array nums, return the length of the longest strictly increasing subsequence.
A subsequence is a sequence that can be derived from an array by deleting some or no elements without changing the order of 
the remaining elements. For example, [3,6,2,7] is a subsequence of the array [0,3,1,6,2,2,7].
Input: nums = [10,9,2,5,3,7,101,18]
Output: 4
"""
class Solution:
    # Approach 1:       标准DP
    def lengthOfLIS(self, nums: List[int]) -> int:
        if not nums or len(nums) == 0:
            return 0
        
        dp = [1] * len(nums)
        
        for right in range(len(nums)):
            for left in range(right):
                if nums[left] < nums[right]:
                    dp[right] = max(dp[right], dp[left] + 1)
                    
        return max(dp)


    # Approach 2:       Greedy + Binary Search
    # 考虑简单的贪心，如果要使上升子序列尽可能的长，则需要让序列上升的尽可能慢，因此希望每次在上升子序列最后加上的那个数尽可能的小。
    # 因为d是单调递增的，所以可以使用二分查找，这里注意while条件是大于还是大于等于，还有mid 加减1的问题，否则容易死循环
    # 动态规划希望复用子问题的解，最好被反复依赖。其本质还是穷举，所以当前并不知道哪个子问题的解会构成最终最优解。但知道这个子问题可能会被反复计算，所以把结果缓存起来。整个过程是树状的搜索过程。
    # 贪心希望每次都能排除一堆子问题。它不需要复用子问题的解，当前最优解从子问题最优解即可得出。整个过程是线性的推导过程。可以想象成对动态规划树进行了剪枝
    def lengthOfLIS(self, nums: List[int]) -> int:
        if not nums or len(nums) == 0:
            return 0
        
        d = []
        for n in nums:
            if not d or n > d[-1]:
                d.append(n)
            else:
                left, right = 0, len(d) - 1
                while left <= right:
                    mid = (left + right) // 2
                    if d[mid] < n:
                        left = mid + 1
                    else:
                        right = mid - 1
                d[left] = n
        return len(d)
    

    # Approach 3:       DFS + memo      仅作参考，不推荐，非常耗时
    def lengthOfLIS(self, nums: List[int]) -> int:
        def lis_ending_at(i):
            if i == 0:
                self.memo[i] = 1
                return 1
            if i in self.memo:
                return self.memo[i]
            
            lis_ending_here = 1
            for j in range(i):
                if nums[i] > nums[j]:
                    lis_ending_here = max(lis_ending_here, 1 + lis_ending_at(j))  
            self.memo[i] = lis_ending_here
            return lis_ending_here
    
        lis = 1
        self.memo = {}
        for i in range(len(nums)):
            lis = max(lis, lis_ending_at(i))
        return lis  





# 673. Number of Longest Increasing Subsequence      300进阶版
"""
Given an integer array nums, return the number of longest increasing subsequences. Notice that the sequence has to be strictly increasing.
Input: nums = [1,3,5,4,7]
Output: 2
"""
class Solution:
    # Approach 1:       DP 和300比多加了一个 cnt 数组记录以 nums[i] 结尾的最长上升子序列的个数
    # 设 nums 的最长上升子序列的长度为 maxLen，那么答案为所有满足 dp[i]=maxLen 的i所对应的 cnt[i] 之和
    def findNumberOfLIS(self, nums: List[int]) -> int:
        if not nums or len(nums) == 0:
            return 0
        
        max_len, ans = 0, 0
        dp = [1] * len(nums)
        cnt = [1] * len(nums)
        
        for right in range(len(nums)):
            for left in range(right):
                if nums[left] < nums[right]:
                    if dp[right] < dp[left] + 1:
                        dp[right] = dp[left] + 1
                        cnt[right] = cnt[left]      # 重置计数
                    elif dp[right] == dp[left] + 1:
                        cnt[right] += cnt[left]
            if dp[right] > max_len:
                max_len = dp[right]
                ans = cnt[right]        # 重置计数
            elif dp[right] == max_len:
                ans += cnt[right]
                
        return ans


    # Approach 2:       贪心 + 前缀和 + 二分查找
    def findNumberOfLIS(self, nums: List[int]) -> int:
        dp, cnt = [], []
        for n in nums:
            i = self.bisect(len(dp), lambda i: dp[i][-1] >= n)
            count = 1
            if i > 0:
                k = self.bisect(len(dp[i-1]), lambda k: dp[i-1][k] < n)
                count = cnt[i-1][-1] - cnt[i-1][k]
            if i == len(dp):
                dp.append([n])
                cnt.append([0, count])
            else:
                dp[i].append(n)
                cnt[i].append(cnt[i][-1] + count)
        return cnt[-1][-1]
    
    def bisect(self, n: int, f: Callable[[int], bool]) -> int:
        l, r = 0, n
        while l < r:
            mid = (l + r) // 2
            if f(mid):
                r = mid
            else:
                l = mid + 1
        return l





# 354. Russian Doll Envelopes
"""
You are given a 2D array of integers envelopes where envelopes[i] = [wi, hi] represents the width and the height of an envelope.
One envelope can fit into another if and only if both the width and height of one envelope are greater than the other envelope's width and height.
Return the maximum number of envelopes you can Russian doll (i.e., put one inside the other).
Input: envelopes = [[5,4],[6,4],[6,7],[2,3]]
Output: 3       Explanation: The maximum number of envelopes you can Russian doll is 3 ([2,3] => [5,4] => [6,7]).
"""
class Solution:
    def maxEnvelopes(self, envelopes: List[List[int]]) -> int:
        if not envelopes or len(envelopes) == 0:
            return 0
        if len(envelopes) == 1:
            return 1
        
        envelopes = sorted(envelopes, key=lambda x : (x[0], -x[1]))     # 这里要注意等于的情况，所以反向排序就好比去重了
        
        d = []
        for _, e1 in envelopes:
            if not d or e1 > d[-1]:
                d.append(e1)
            else:
                idx = self.bisect_left(d, e1)
                d[idx] = e1
                        
        return len(d)
    
    def bisect_left(self, d, e1):
        left, right = 0, len(d) - 1
        while left < right:
            mid = (left + right) // 2
            if d[mid] == e1:
                return mid
            if d[mid] < e1:
                left = mid + 1
            else:
                right = mid
        return left





# 71. Simplify Path
"""
Given a string path, which is an absolute path (starting with a slash '/') to a file or directory in a Unix-style file system, convert it to the simplified canonical path.
In a Unix-style file system, a period '.' refers to the current directory, a double period '..' refers to the directory up a level, and any multiple consecutive 
slashes (i.e. '//') are treated as a single slash '/'. For this problem, any other format of periods such as '...' are treated as file/directory names.
The canonical path should have the following format:
1. The path starts with a single slash '/'.
2. Any two directories are separated by a single slash '/'.
3. The path does not end with a trailing '/'.
4. The path only contains the directories on the path from the root directory to the target file or directory (i.e., no period '.' or double period '..')
Return the simplified canonical path.

Input: path = "/../"
Output: "/"         Explanation: Going one level up from the root directory is a no-op, as the root level is the highest level you can go.

Input: path = "/home//foo/"
Output: "/home/foo"
"""
class Solution:
    # Approach 1:       Using a stack
    def simplifyPath(self, path: str) -> str:
        stack = []
        for dir in path.split("/"):
            if dir == "..":     # go one level up in the current directory path, will pop an entry from our stack if it's not empty.
                if stack:
                    stack.pop()
            elif dir == "." or not dir:     # string /a//b would be [a,,b]
                continue
            else:
                stack.append(dir)       # legitimate directory name
        final_str = "/" + "/".join(stack)
        
        return final_str

    # Approach 2:       Without using a stack
    def simplifyPath(self, path: str) -> str:
        path = path.split('/')
        to_pop = 0      # the number of directories to 'pop'
        ans = ''
        
        for i in range(len(path) - 1, -1, -1):
            dir = path[i]
            if dir == '' or dir == '.':
                continue
            elif dir == '..':
                to_pop += 1
            elif to_pop:    # if this is a real directory and we have directories we still need to pop
                to_pop -= 1
            else:
                ans = '/' + dir + ans
                
        return ans if ans else '/'





# 325. Maximum Size Subarray Sum Equals k
"""
Given an integer array nums and an integer k, return the maximum length of a subarray that sums to k. If there is not one, return 0 instead.
Input: nums = [1,-1,5,-2,3], k = 3
Output: 4
"""
class Solution:
    def maxSubArrayLen(self, nums: List[int], k: int) -> int:
        prefix_sum, longest = 0, 0
        indices = {}
        indices[0] = 1
        
        for i, num in enumerate(nums):
            prefix_sum += num
            if prefix_sum == k:
                longest = i + 1
            if prefix_sum - k in indices:
                longest = max(longest, i - indices[prefix_sum - k])
            indices[prefix_sum] = indices.get(prefix_sum, i)
            
        return longest





# 1284. Minimum Number of Flips to Convert Binary Matrix to Zero Matrix
"""
Given a m x n binary matrix mat. In one step, you can choose one cell and flip it and all the four neighbors of it if they exist 
(Flip is changing 1 to 0 and 0 to 1). A pair of cells are called neighbors if they share one edge.
Return the minimum number of steps required to convert mat to a zero matrix or -1 if you cannot.
A binary matrix is a matrix with all cells equal to 0 or 1 only. A zero matrix is a matrix with all cells equal to 0.
"""
class Solution:
    def minFlips(self, mat: List[List[int]]) -> int:
        n, m = len(mat), len(mat[0])
        start_x = self.encode(mat, n, m)
        step = 0
        if start_x == 0:
            return step
        
        queue = deque([start_x])
        visited = {start_x}
        
        while queue:
            step += 1
            
            for _ in range(len(queue)):
                state = self.decode(queue.popleft(), n, m)
                for r in range(n):
                    for c in range(m):
                        self.convert(state, n, m, r, c)
                        curr_x = self.encode(state, n, m)
                        if curr_x == 0:
                            return step
                        if curr_x not in visited:
                            queue.append(curr_x)
                            visited.add(curr_x)
                        self.convert(state, n, m, r, c)
        return -1
    
    def encode(self, mat, n, m):
        x = 0
        for r in range(n):
            for c in range(m):
                x <<= 1
                x += mat[r][c]
        return x
    
    def decode(self, x, n, m):
        mat = [[0] * m for _ in range(n)]
        for r in range(n - 1, -1, -1):
            for c in range(m - 1, -1, -1):
                mat[r][c] = x & 1
                x >>= 1
        return mat
    
    def convert(self, mat, n, m, i, j):
        for di, dj in [(-1, 0), (1, 0), (0, -1), (0, 1), (0, 0)]:
            next_i, next_j = i + di, j + dj
            if 0 <= next_i < n and 0 <= next_j < m:
                mat[next_i][next_j] ^= 1





# 124. Binary Tree Maximum Path Sum
"""
A path in a binary tree is a sequence of nodes where each pair of adjacent nodes in the sequence has an edge connecting them. 
A node can only appear in the sequence at most once. Note that the path does not need to pass through the root.
The path sum of a path is the sum of the node's values in the path. Given the root of a binary tree, return the maximum path sum of any non-empty path.
Input: root = [-10,9,20,null,null,15,7]
Output: 42
"""
class Solution:
    def maxPathSum(self, root: Optional[TreeNode]) -> int:
        self.maxSum = -sys.maxsize-1 
        self.helper(root)
        return self.maxSum

    def helper(self, root):
        if not root: 
            return 0 
        
        leftSum = self.helper(root.left)
        if leftSum < 0:
            leftSum = 0
        rightSum = self.helper(root.right)
        if rightSum < 0:
            rightSum = 0
        
        # 三者之和放在全局self.maxSum里。返回的值是可供上一层父节点接龙的值
        # 局部最大值是遍历算法，挑选左右子树最大值是分治法，这里的解法是合二为一
        self.maxSum = max(self.maxSum, root.val + leftSum + rightSum)
        return root.val + max(leftSum, rightSum)





# 718. Maximum Length of Repeated Subarray
"""
Given two integer arrays nums1 and nums2, return the maximum length of a subarray that appears in both arrays.
Input: nums1 = [1,2,3,2,1], nums2 = [3,2,1,4,7]
Output: 3       Explanation: The repeated subarray with maximum length is [3,2,1].
"""
class Solution:
    # Approach 1: Dynamic Programming       bottom-up
    # Since a common subarray of A and B must start at some A[i] and B[j], let dp[i][j] be the length of longest common prefix of A[i:] and B[j:]
    def findLength(self, nums1: List[int], nums2: List[int]) -> int:
        dp = [[0] * (len(nums2) + 1) for _ in range(len(nums1) + 1)]
        for i in range(len(nums1)):
            for j in range(len(nums2)):
                if nums1[i] == nums2[j]:
                    dp[i+1][j+1] = dp[i][j] + 1
        return max(max(row) for row in dp)

    # Approach 2:   滑动窗口，类似求卷积，不如方法1
    def findLength(self, nums1: List[int], nums2: List[int]) -> int:
        m, n = len(nums1), len(nums2)
        cnt, maxLen = 0, 0
        
        # [3, 1, 3, 4, 5] m
        # [2, 6, 1, 3, 4] n
        for i in range(-(n-1), m):
            cnt = 0
            for j in range(n):
                if (i + j) < 0:
                    continue
                elif (i + j) >= m:
                    break
                elif nums1[i+j] == nums2[j]:
                    cnt = cnt + 1
                    maxLen = max(maxLen, cnt)
                else:
                    cnt = 0
        return maxLen





# 632. Smallest Range Covering Elements from K Lists
"""
You have k lists of sorted integers in non-decreasing order. Find the smallest range that includes at least one number from each of the k lists.
We define the range [a, b] is smaller than range [c, d] if b - a < d - c or a < c if b - a == d - c.
Input: nums = [[4,10,15,24,26],[0,9,12,20],[5,18,22,30]]
Output: [20,24]
"""
# Approach #1 Brute Force [Time Limit Exceeded]:    The naive approach is to consider every pair of elements, nums[i][j]nums[i][j] and nums[k][l]nums[k][l] 
# from amongst the given lists and consider the range formed by these elements. For every range currently considered, we can traverse over all the lists to find 
# if at least one element from these lists can be included in the current range. If so, we store the end-points of the current range and compare it with the 
# previous minimum range found, if any, satisfying the required criteria, to find the smaller range from among them.
# Once all the element pairs have been considered as the ranges, we can obtain the required minimum range.      Time complexity : O(n^3) / O(1)

# Approach #2 Better Brute Force [Time Limit Exceeded]:     In the last approach, we consider every possible range and then traverse over every list to check 
# if at least one of the elements from these lists lies in the required range. Instead of doing this traversal for every range, we can make use of Binary Search 
# to find the index of the element just larger than(or equal to) the lower limit of the range currently considered.     Time complexity : O(n^2 * log(k)) / O(1)

# Approach #3 Using Pointers [Time Limit Exceeded]:     Time complexity : O(n*m) / O(m)
class Solution:
    # Approach 4:   Using Priority Queue [Accepted]:    O(nk * logk)
    def smallestRange(self, nums: List[List[int]]) -> List[int]:
        left, right = -float('inf'), float('inf')
        maxVal = max(num[0] for num in nums)
        pq = [(num[0], i, 0) for i, num in enumerate(nums)]
        heapq.heapify(pq)
        
        while True:
            minVal, kth, idx = heapq.heappop(pq)
            if maxVal - minVal < right - left:
                left, right = minVal, maxVal
            if idx == len(nums[kth]) - 1:
                break
            maxVal = max(maxVal, nums[kth][idx + 1])
            heapq.heappush(pq, (nums[kth][idx + 1], kth, idx + 1))
            
        return [left, right]

    for _ in range(10): pass         # 为了好看





# 224. Basic Calculator
# 227. Basic Calculator II
# 772. Basic Calculator III
"""
Given a string s representing a valid expression, implement a basic calculator to evaluate it, and return the result of the evaluation.

Basic Calculator I, II, III easy solution, detailed explanation:
This algorithm works for Basic Calculator (BC I) problem, where we can have only + - ( ) operations, for Basic Calculator II (BC II), 
where we can have only + - * / operations and also for Basic Calculator III (BC III), where we can have all + - * / ( ) operations.

Solution 1:     Stack of monomials
The idea is to use both stack and recursion (which can be seen as 2 stack, because recursion use implicit stack). First, let us consider no brackets. 
Then let us keep the stack of monomial, consider the example s = 1*2 - 3\4*5 + 6. Then we want our stack to be equal to [1*2, -3\4*5, 6], let us do it step by step:
    1. Put 1 into stack, we have stack = [1].
    2. We can see that operation is equal to *, so we pop the last element from our stack and put new element: 1*2, now stack = [1*2].
    3. Now, operation is equal to -, so we put -3 to stack and we have stack = [1*2, -3] now
    4. Now, operation is equal to \, so we pop the last element from stack and put -3\4 instead, stack = [1*2, -3\4]
    5. Now, operation is equal to *, so we pop last element from stack and put -3\4*5 instead, stack = [1*2, -3\4*5].
    6. Finally, operation is equal to +, so we put 6 to stack: stack = [1*2, -3\4*5, 6]
Now, all we need to do is to return sum of all elements in stack. Then how do we deal with the brackets?
If we want to be able to process the brackets properly, all we need to do is to call our calculator recursively! When we see the open bracket (, we call calculator with 
the rest of our string, and when we see closed bracket ')', we give back the value of expression inside brackets and the place where we need to start when we go out of recursion.
Complexity: Even though we have stack and recursion, we process every element only once, so time complexity is O(n). However we pass slice of string as argument each time 
we meet bracket, so time complexity can go up to O(n^2) on example like (1+(1+(... +))) with O(n) open brackets. Space complexity is potentially O(n), 
because we need to keep stacks, but each element not more than once.
"""
class Solution:
    def calculate(self, s):
        def update(op, v):
            if op == "+": stack.append(v)
            if op == "-": stack.append(-v)
            if op == "*": stack.append(stack.pop() * v)           #for BC II and BC III
            if op == "/": stack.append(int(stack.pop() / v))      #for BC II and BC III

        # s = 1*2 - 3\4*5 + 6
        # [1*2, -3\4*5, 6]      [2, 0, 6]
    
        it, num, stack, sign = 0, 0, [], "+"        #这里sign必须初始化成+，否则第一个数没法被计算到
        
        while it < len(s):
            if s[it].isdigit():
                num = num * 10 + int(s[it])
            elif s[it] in "+-*/":
                update(sign, num)
                num, sign = 0, s[it]
            elif s[it] == "(":                                        # For BC I and BC III
                num, j = self.calculate(s[it + 1:])
                it = it + j
            elif s[it] == ")":                                        # For BC I and BC III
                update(sign, num)
                return sum(stack), it + 1
            it += 1
        update(sign, num)       # 结尾也是一样需要特别计算一下
        return sum(stack)


    # Solution 2    The problem of previous code is that we pass slice of string as parameter. In python it works quite fast, because function is implemented in C and 
    # it works very fast. If we want to have honest linear time, we need to pass index as parameter where we can pre-calculate pairs of open and closing brackets
    # Complexity:   Now time complexity it is O(n), space is still O(n).
    def calculate(self, s):    
        def calc(it):
            def update(op, v):
                if op == "+": stack.append(v)
                if op == "-": stack.append(-v)
                if op == "*": stack.append(stack.pop() * v)
                if op == "/": stack.append(int(stack.pop() / v))
        
            num, stack, sign = 0, [], "+"
            
            while it < len(s):
                if s[it].isdigit():
                    num = num * 10 + int(s[it])
                elif s[it] in "+-*/":
                    update(sign, num)
                    num, sign = 0, s[it]
                elif s[it] == "(":
                    num, j = calc(it + 1)
                    it = j - 1
                elif s[it] == ")":
                    update(sign, num)
                    return sum(stack), it + 1
                it += 1
            update(sign, num)
            return sum(stack)

        return calc(0)





# 1597. Build Binary Expression Tree From Infix Expression
"""
A binary expression tree is a kind of binary tree used to represent arithmetic expressions. Each node of a binary expression tree has either zero or two children. 
Leaf nodes (nodes with 0 children) correspond to operands (numbers), and internal nodes (nodes with 2 children) correspond to the operators '+' (addition), '-' (subtraction), 
'*' (multiplication), and '/' (division). For each internal node with operator o, the infix expression it represents is (A o B), where A is the expression the left subtree 
represents and B is the expression the right subtree represents. You are given a string s, an infix expression containing operands, the operators described above, 
and parentheses '(' and ')'. Return any valid binary expression tree, whose in-order traversal reproduces s after omitting the parenthesis from it.
Please note that order of operations applies in s. That is, expressions in parentheses are evaluated first, and multiplication and division happen before addition and subtraction.
Operands must also appear in the same order in both s and the in-order traversal of the tree.
Input: s = "3*4-2*5"
Output: [-,*,*,3,4,2,5]
Input: s = "2-3/(5*2)+1"
Output: [+,-,1,2,/,null,null,null,null,3,*,null,null,5,2]
"""
# Definition for a binary tree node.
# class Node(object):
#     def __init__(self, val=" ", left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    # We maintain an ops stack and a nums stack. When we see '+-', if the top of the ops stack is '+-*/', we can merge the top two nodes in the nums stack 
    # using the top node in the ops stack. When we see '*/', we cannot compute the previous '+-' because of the priority. So only if we see '*/', we can merge 
    # the top two nodes in the nums stack using the top node in the ops stack. When we see ')', we merge the nodes until the top of the ops stack is '('.
    def expTree(self, s: str) -> 'Node':
        ops, nums = [], []

        def build_tree():
            op = ops.pop()
            r = nums.pop()
            l = nums.pop()
            nums.append(Node(val=op, left=l, right=r))
        
        for ch in s:
            if ch.isdigit():
                nums.append(Node(val=ch))
            elif ch in ['+', '-']:
                while ops and ops[-1] in ['+', '-', '*', '/']:
                    build_tree()
                ops.append(ch)
            elif ch in ['*', '/']:
                while ops and ops[-1] in ['*', '/']:
                    build_tree()
                ops.append(ch)
            elif ch == '(':
                ops.append(ch)
            elif ch == ')':
                while ops[-1] != '(':
                    build_tree()
                ops.pop()
        while ops:
            build_tree()
            
        return nums[0]





# 1612. Check If Two Expression Trees are Equivalent
"""
You are given the roots of two binary expression trees, root1 and root2. Return true if the two binary expression trees are equivalent. Otherwise, return false.
Two binary expression trees are equivalent if they evaluate to the same value regardless of what the variables are set to.
Node.val is '+' or a lower-case English letter. Follow up: What will you change in your solution if the tree also supports the '-' operator (i.e. subtraction)?

Input: root1 = [+,a,+,null,null,b,c], root2 = [+,+,a,b,c]
Output: true    Explaination: a + (b + c) == (b + c) + a
Input: root1 = [+,a,+,null,null,b,c], root2 = [+,+,a,b,d]
Output: false   Explaination: a + (b + c) != (b + d) + a
"""
class Solution:
    def checkEquivalence(self, root1: 'Node', root2: 'Node') -> bool:
        dic = Counter()
        
        def dfs(node, sign):
            if not node:
                return
            if node.val == '+':
                dfs(node.left, sign)
                dfs(node.right, sign)
            elif node.val == '-':       # for follow-up
                dfs(node.left, sign)
                dfs(node.right, -sign)
            else:
                dic[node.val] += sign
        
        dfs(root1, 1)
        dfs(root2, -1)
        return all(x == 0 for x in dic.values())





# 1628. Design an Expression Tree With Evaluate Function
"""
Given the postfix tokens of an arithmetic expression, build and return the binary expression tree that represents this expression.
Oostfix: 4*(5-(7+2)) are represented in the array postfix = ["4","5","7","2","+","-","*"].
It's guaranteed that no subtree will yield a value that exceeds 109 in absolute value, and all the operations are valid (i.e., no division by zero).
Follow up: Could you design the expression tree such that it is more modular? For example, is your design able to support additional operators without 
making changes to your existing evaluate implementation?
Input: s = ["3","4","+","2","*","7","/"]
Output: 2       Explanation: this expression evaluates to the above binary tree with expression ((3+4)*2)/7) = 14/7 = 2.
"""
from abc import ABC, abstractmethod 
"""
This is the interface for the expression tree Node.
You should not remove it, and you can define some classes to implement it.
"""
class Node(ABC):
    @abstractmethod
    # define your fields here
    def evaluate(self) -> int:
        pass
    
    
class TreeNode(Node):
    
    def __init__(self, val):    #定义自己的初始函数
        self.val = val
        self.left, self.right = None, None
        
    def evaluate(self):
        if self.val.isdigit():
            return int(self.val)
        elif self.val == '+':
            return self.left.evaluate() + self.right.evaluate()
        elif self.val == '-':
            return self.left.evaluate() - self.right.evaluate()
        elif self.val == '*':
            return self.left.evaluate() * self.right.evaluate()
        else:
            return self.left.evaluate() // self.right.evaluate()

"""    
This is the TreeBuilder class.
You can treat it as the driver code that takes the postinfix input
and returns the expression tree represnting it as a Node.
"""

class TreeBuilder(object):
    def buildTree(self, postfix: List[str]) -> 'Node':
        curr, stack = None, []
        for c in postfix:
            curr = TreeNode(c)
            if not c.isdigit():
                curr.right = stack.pop()
                curr.left = stack.pop()
            stack.append(curr)
        return curr


# Approach 2: Follow Up  进一步解耦，更加模块化，如果需要添加新的计算符，不用动 evaluate 方法
class TreeNode(Node):
    """base class for binary nodes"""
    def __init__(self, _left, _right):
        self.left = _left
        self.right = _right
    def evaluate(self) -> int:
        pass


class Plus(TreeNode):
    def evaluate(self) -> int:
        return self.left.evaluate() + self.right.evaluate()

class Minus(TreeNode):
    def evaluate(self) -> int:
        return self.left.evaluate() - self.right.evaluate()

class Mul(TreeNode):
    def evaluate(self) -> int:
        return self.left.evaluate() * self.right.evaluate()

class Div(TreeNode):
    def evaluate(self) -> int:
        return self.left.evaluate() // self.right.evaluate()

class Num(Node):
    def __init__(self, _value):
        self.value = _value
        
    def evaluate(self) -> int:
        return self.value


class TreeBuilder(object):
    def buildTree(self, postfix: List[str]) -> 'Node':
        operators = {'+': Plus, '-': Minus, '*': Mul, '/': Div}
        stack = []
        for token in postfix:
            if token in operators:
                R = stack.pop()
                L = stack.pop()
                stack.append(operators[token](L, R))
            else:
                stack.append(Num(int(token)))
        return stack[0]

    for _ in range(10): pass         # 为了好看





# 394. Decode String
"""
Given an encoded string, return its decoded string.
The encoding rule is: k[encoded_string], where the encoded_string inside the square brackets is being repeated exactly k times. 
Note that k is guaranteed to be a positive integer. You may assume that the input string is always valid; there are no extra white spaces, 
square brackets are well-formed, etc. Furthermore, you may assume that the original data does not contain any digits and that digits are only 
for those repeat numbers, k. For example, there will not be input like 3a or 2[4].
Input: s = "3[a2[c]]"
Output: "accaccacc"
"""
class Solution:
    # Approach 1: Using Stack
    def decodeString(self, s: str) -> str:
        stack = []
        res, multi = "", 0
        
        for c in s:
            if c == '[':
                stack.append([res, multi])
                res, multi = "", 0
            elif c == ']':
                last_res, curr_multi = stack.pop()
                res = last_res + curr_multi * res       # a + c * 2 = acc
            elif '0' <= c <= '9':
                multi = multi * 10 + int(c)
            else:
                res += c
        return res


    # Approach 2: Using Recursion
    def decodeString(self, s: str) -> str:
        
        def dfs(s, i):
            res, multi = "", 0
            
            while i < len(s):
                if '0' <= s[i] <= '9':
                    multi = multi * 10 + int(s[i])
                elif s[i] == '[':
                    i, temp = dfs(s, i + 1)
                    res += multi * temp
                    multi = 0
                elif s[i] == ']':
                    return i, res
                else:
                    res += s[i]
                i += 1
            return res
        
        return dfs(s, 0)





# 443. String Compression
"""
Given an array of characters chars, compress it using the following algorithm:
Begin with an empty string s. For each group of consecutive repeating characters in chars:
    - If the group's length is 1, append the character to s.
    - Otherwise, append the character followed by the group's length.
The compressed string s should not be returned separately, but instead, be stored in the input character array chars. 
Note that group lengths that are 10 or longer will be split into multiple characters in chars.
After you are done modifying the input array, return the new length of the array.
Input: chars = ["a","b","b","b","b","b","b","b","b","b","b","b","b"]
Output: Return 4, and the first 4 characters of the input array should be: ["a","b","1","2"].
"""
class Solution:
    def compress(self, chars: List[str]) -> int:
        left, right = 0, 0
        while right < len(chars):
            chars[left] = chars[right]
            count = 1
			
            while right + 1 < len(chars) and chars[right] == chars[right+1]:
                right += 1
                count += 1
			
            if count > 1:
                for c in str(count):
                    chars[left+1] = c
                    left += 1
            right += 1
            left += 1
        
        return left





# 636. Exclusive Time of Functions
"""
You are given a list logs, where logs[i] represents the ith log message formatted as a string "{function_id}:{"start" | "end"}:{timestamp}". For example, 
"0:start:3" means a function call with function ID 0 started at the beginning of timestamp 3, and "1:end:2" means a function call with function ID 1 ended at the end of 
timestamp 2. Note that a function can be called multiple times, possibly recursively.
A function's exclusive time is the sum of execution times for all function calls in the program. For example, if a function is called twice, one call executing for 2 time units 
and another call executing for 1 time unit, the exclusive time is 2 + 1 = 3.
Return the exclusive time of each function in an array, where the value at the ith index represents the exclusive time for the function with ID i.
Input: n = 2, logs = ["0:start:0","1:start:2","1:end:5","0:end:6"]
Output: [3,4]
"""
class Solution:
    def exclusiveTime(self, n: int, logs: List[str]) -> List[int]:
        _helper = lambda log: (int(log[0]), log[1], int(log[2]))
        logs = [_helper(log.split(':')) for log in logs]
        
        res, stack = [0] * n, []
        for index, pos, timestamp in logs:
            if pos == 'start':
                if stack:
                    res[stack[-1][0]] += timestamp - stack[-1][1]       # if s is not empty, update time spent on previous id (s[-1][0])   2 - 0
                stack.append([index, timestamp])
            elif pos == 'end':
                res[stack[-1][0]] += timestamp - stack.pop()[1] + 1
                if stack:
                    stack[-1][1] = timestamp + 1        # if s is not empty, udpate start time of previous id, update 0 to 5 + 1 = 6
        return res

    for _ in range(10): pass         # 为了好看





# 1400. Construct K Palindrome Strings
"""
Given a string s and an integer k, return true if you can use all the characters in s to construct k palindrome strings or false otherwise.
Input: s = "annabelle", k = 2
Output: true        Some possible constructions "anna" + "elble", "anbna" + "elle", "anellena" + "b"
"""
class Solution:
    def canConstruct(self, s: str, k: int) -> bool:
        return sum(i & 1 for i in Counter(s).values()) <= k <= len(s)       # here i & 1 == i % 2

    for _ in range(10): pass         # 为了好看





# 290. Word Pattern
"""
Given a pattern and a string s, find if s follows the same pattern.
Here follow means a full match, such that there is a bijection between a letter in pattern and a non-empty word in s.
Input: pattern = "abba", s = "dog cat cat dog"
Output: true
Input: pattern = "abba", s = "dog cat cat fish"
Output: false
"""
class Solution:
    def wordPattern(self, pattern: str, s: str) -> bool:
        s, pattern = s.split(" "), list(pattern)
        return list(map(s.index, s)) == list(map(pattern.index, pattern))

    for _ in range(10): pass         # 为了好看





# 291. Word Pattern II
"""
Given a pattern and a string s, return true if s matches the pattern.
A string s matches a pattern if there is some bijective mapping of single characters to strings such that if each character in pattern is replaced by the string it maps to, 
then the resulting string is s. A bijective mapping means that no two characters map to the same string, and no character maps to two different strings.
Input: pattern = "abab", s = "redblueredblue"
Output: true
"""
class Solution:
    def wordPatternMatch(self, pattern: str, s: str) -> bool:
        return self.dfs(pattern, s, {})

    def dfs(self, pattern, s, dict):
        if len(pattern) == 0 and len(s) > 0:
            return False
        if len(pattern) == len(s) == 0:
            return True
        for end in range(1, len(s)-len(pattern)+2): # +2 because it is the "end of an end"
            if pattern[0] not in dict and s[:end] not in dict.values():
                dict[pattern[0]] = s[:end]
                if self.dfs(pattern[1:], s[end:], dict):
                    return True
                del dict[pattern[0]]
            elif pattern[0] in dict and dict[pattern[0]] == s[:end]:
                if self.dfs(pattern[1:], s[end:], dict):
                    return True
        return False





# 41. First Missing Positive
"""
Given an unsorted integer array nums, return the smallest missing positive integer.
You must implement an algorithm that runs in O(n) time and uses constant extra space.
Input: nums = [3,4,-1,1]
Output: 2
Input: nums = [7,8,9,11,12]
Output: 1
"""
class Solution:
    # 精髓就在于不用hashmap，省空间，就得在原数组上想办法：根据当前值来更改 value 对应的 index
    # Approach 1:       变成负数
    def firstMissingPositive(self, nums):
        n = len(nums)
        for i in range(n):
            if nums[i] <= 0:
                nums[i] = n + 1
                
        for i in range(n):
            num = abs(nums[i])
            if num <= n:
                nums[num - 1] = -abs(nums[num - 1])
                
        for i in range(n):
            if nums[i] > 0:
                return i + 1
        return n + 1

    
    # Approach 2:       置换 bucket sort        rearrange numbers, putting each number on its place
    def firstMissingPositive(self, nums):
        n = len(nums)
        for i in range(n):
            while nums[i] - 1 in range(n) and nums[i] != nums[nums[i] - 1]:
                nums[nums[i] - 1], nums[i] = nums[i], nums[nums[i] - 1]
                
        return next((i + 1 for i, num in enumerate(nums) if num != i + 1), n + 1)





# 442. Find All Duplicates in an Array
"""
Given an integer array nums of length n where all the integers of nums are in the range [1, n] and each integer appears once or twice, 
return an array of all the integers that appears twice. You must write an algorithm that runs in O(n) time and uses only constant extra space.
Input: nums = [4,3,2,7,8,2,3,1]
Output: [2,3]
"""
class Solution:
    # Solution 1: rearragne numbers
    def findDuplicates(self, nums: List[int]) -> List[int]:
        for i in range(len(nums)):
            while i != nums[i] - 1 and nums[i] != nums[nums[i]-1]:
                nums[nums[i]-1], nums[i] = nums[i], nums[nums[i]-1]

        return [nums[it] for it in range(len(nums)) if it != nums[it] - 1]


    # Solution 2: hash numbers
    def findDuplicates(self, nums: List[int]) -> List[int]:
        ans = []
        for num in nums:
            if nums[abs(num) - 1] < 0:
                ans.append(abs(num))
            else:
                nums[abs(num) - 1] *= -1
        return ans

    for _ in range(10): pass         # 为了好看





# 451. Sort Characters By Frequency
"""
Given a string s, sort it in decreasing order based on the frequency of the characters. The frequency of a character is the number of times it appears in the string.
Return the sorted string. If there are multiple answers, return any of them.
Input: s = "tree"
Output: "eert"
"""
class Solution:
    # Approach 1: HashMap and Sort      O(nlogn)
    def frequencySort(self, s: str) -> str:
        counts = Counter(s)
        string_builder = []
        for letter, freq in counts.most_common():
            string_builder.append(letter * freq)
        return "".join(string_builder)
    
    
    # Approach 2: Multiset and Bucket Sort      O(n)
    def frequencySort(self, s: str) -> str:
        if not s:
            return s
        counts = Counter(s)
        max_freq = max(counts.values())     # Step 1: use Counter to count freq and get the max value

        buckets = [[] for _ in range(max_freq + 1)] # Step 2:   Bucket sort the characters by frequency.
        for c, i in counts.items():
            buckets[i].append(c)

        string_builder = []     # Step 3: # Build up the string.
        for i in range(len(buckets) - 1, 0, -1):
            for c in buckets[i]:
                string_builder.append(c * i)

        return "".join(string_builder)





# 1152. Analyze User Website Visit Pattern
"""
A pattern is a list of three websites (not necessarily distinct). The score of a pattern is the number of users that visited all the websites 
in the pattern in the same order they appeared in the pattern. Return the pattern with the largest score. If there is more than one pattern 
with the same largest score, return the lexicographically smallest such pattern.
Input:  username = ["joe","joe","joe","james","james","james","james","mary","mary","mary"], 
        timestamp = [1,2,3,4,5,6,7,8,9,10], 
        website = ["home","about","career","home","cart","maps","home","home","about","career"]
Output: ["home","about","career"]
Explanation: The tuples in this example are:
["joe","home",1],["joe","about",2],["joe","career",3],["james","home",4],["james","cart",5],["james","maps",6],["james","home",7],["mary","home",8],["mary","about",9], and ["mary","career",10].
The pattern ("home", "about", "career") has score 2 (joe and mary).
"""
from itertools import combinations

class Solution:
    # Approach 1
    def mostVisitedPattern(self, username, timestamp, website):
        users = defaultdict(list)
        
        for (user, time, site) in sorted(zip(username, timestamp, website), key = lambda x: (x[0], x[1])):
            users[user].append(site)
            
        patterns = defaultdict(list)
        for user, site in users.items():
            self.get_all_combinations(user, site, 0, [], patterns)
            
        max_size = -1
        for k, v in patterns.items():
            max_size = max(max_size, len(v))
            
        max_list = []
        for k, v in patterns.items():
            if len(v) == max_size and (not max_list or list(k) < max_list):
                max_list = list(k)
                
        return max_list
    
    def get_all_combinations(self, user, sites, start_index, pattern, pattern_user_map):
        if len(pattern) == 3:
            if tuple(pattern) not in pattern_user_map:
                pattern_user_map[tuple(pattern)] = set()
            pattern_user_map[tuple(pattern)].add(user)
            
        for i in range(start_index, len(sites)):
            pattern.append(sites[i])
            self.get_all_combinations(user, sites, i + 1, pattern, pattern_user_map)
            pattern.pop()
        
        
    # Approach 2
    def mostVisitedPattern(self, username, timestamp, website):
        users = defaultdict(list)
        
        for (user, time, site) in sorted(zip(username, timestamp, website), key = lambda x: (x[0], x[1])):
            users[user].append(site)
        
        patterns = defaultdict(int)
        for user, sites in users.items():
            
            # Itertools.combinations
            for combination in set(combinations(sites, 3)):
                patterns[combination] += 1
        
        # sort the pattern in lexicographically order and return the pattern with the max value
        return max(sorted(patterns), key=patterns.get)





# 848. Shifting Letters
"""
You are given a string s of lowercase English letters and an integer array shifts of the same length.
Call the shift() of a letter, the next letter in the alphabet, (wrapping around so that 'z' becomes 'a').
For example, shift('a') = 'b', shift('t') = 'u', and shift('z') = 'a'.
Now for each shifts[i] = x, we want to shift the first i + 1 letters of s, x times.
Return the final string after all such shifts to s are applied.
Input: s = "abc", shifts = [3,5,9]
Output: "rpl"
Explanation: We start with "abc".
After shifting the first 1 letters of s by 3, we have "dbc".
After shifting the first 2 letters of s by 5, we have "igc".
After shifting the first 3 letters of s by 9, we have "rpl", the answer.
"""
class Solution:
    def shiftingLetters(self, S: str, shifts: List[int]) -> str:
        ans = []
        total = sum(shifts) % 26
        for i, c in enumerate(S):
            index = ord(c) - ord('a')
            ans.append(chr(ord('a') + (index + total) % 26))
            total = (total - shifts[i]) % 26
            
        return "".join(ans)





# 348. Design Tic-Tac-Toe
"""
Input
["TicTacToe", "move", "move", "move", "move", "move", "move", "move"]
[[3], [0, 0, 1], [0, 2, 2], [2, 2, 1], [1, 1, 2], [2, 0, 1], [1, 0, 2], [2, 1, 1]]
Output
[null, 0, 0, 0, 0, 0, 0, 1]
"""
class TicTacToe:
    def __init__(self, n: int):
        self.n = n
        self.rows, self.cols = [0] * n, [0] * n
        self.diag, self.anti_diag = 0, 0

    def move(self, row: int, col: int, player: int) -> int:
        n = self.n
        
        turn = 1 if player == 1 else -1
        self.rows[row] += turn
        self.cols[col] += turn
        if row == col:
            self.diag += turn
        if row + col == n - 1:
            self.anti_diag += turn
        if any(abs(line) == n for line in (self.rows[row], self.cols[col], self.diag, self.anti_diag)):
                return player
        return 0

# Your TicTacToe object will be instantiated and called as such:
# obj = TicTacToe(n)
# param_1 = obj.move(row,col,player)





# 1275. Find Winner on a Tic Tac Toe Game
"""
Input: moves = [[0,0],[2,0],[1,1],[2,1],[2,2]]      Output: "A"
Input: moves = [[0,0],[1,1],[2,0],[1,0],[1,2],[2,1],[0,1],[0,2],[2,2]]      Output: "Draw"
"""
class Solution:
    def tictactoe(self, moves: List[List[int]]) -> str:
        n = 3
        rows, cols = [0] * n, [0] * n
        diag = anti_diag = 0
        
        player = 1      # 精髓在于红方用 1 ，黑方用 -1 ， 只要找横竖斜 哪条先到3 或者到 -3 ，初始化成红方 1
        for row, col in moves:
            rows[row] += player
            cols[col] += player
            if row == col:            
                diag += player
            if row + col == n - 1:
                anti_diag += player

            if any(abs(line) == n for line in (rows[row], cols[col], diag, anti_diag)):
                return "A" if player == 1 else "B"
            player *= -1        # 红方走完，换成黑方走 -1
            
        return "Draw" if len(moves) == n * n else "Pending"





# 1062. Longest Repeating Substring
"""
Given a string s, return the length of the longest repeating substrings. If no repeating substring exists, return 0.
Input: s = "abbaba"
Output: 2   Explanation: The longest repeating substrings are "ab" and "ba", each of which occurs twice.
"""
class Solution:
    # Approach 1: DP
    def longestRepeatingSubstring(self, s: str) -> int:
        if not s:
            return 0
        n = len(s)
        dp = [[0 for j in range(n + 1)] for i in range(n + 1)]
        res = 0
        for i in range(1, n+1):
            for j in range(i+1, n+1):
                dp[i][j] = dp[i-1][j-1] + 1 if s[i-1] == s[j-1] else 0
                res = max(res, dp[i][j])
        return res
        # Follow-up: What if overlapping is not allowed? For example, assume S is "mississipi, the answer will be 3 instead of 4 as issi with overlapping character i 
        # is not a qualified answer. # we need to make sure the distance between i and j are greater than the length of previous substring
        if S[i - 1] == S[j - 1] and j-i > dp[i-1][j-1]: 
            dp[i][j] = dp[i - 1][j - 1] + 1
            res = max(res, dp[i][j])
        else:
            dp[i][j] = 0



    # Approach 2: Binary Search + Hashset of Already Seen Strings. Time complexity O(NlogN) in the average case and O(N^2) in the worst case.
    # Why using Binary Search: if there is a duplicate substring of length k, that means that there is a duplicate substring of length k - 1
    def longestRepeatingSubstring(self, s: str) -> int:
        n = len(s)
        left, right = 0, n - 1
        while left <= right:
            mid = left + (right - left) // 2
            if self.search(s, n, mid):
                left = mid + 1
            else:
                right = mid - 1
        return left - 1
    
    def search(self, s, n, length):
        visited = set()
        for start in range(n - length + 1):
            temp = s[start: start + length]
            if temp in visited:
                return start
            visited.add(temp)
        return False





# 1044. Longest Duplicate Substring
"""
Given a string s, consider all duplicated substrings: (contiguous) substrings of s that occur 2 or more times. The occurrences may overlap.
Return any duplicated substring that has the longest possible length. If s does not have a duplicated substring, the answer is "".
Input: s = "banana"
Output: "ana"
"""
class Solution:
    # Approach 1: Binary Search + Rabin-Karp with polynomial rolling hash.          https://leetcode.com/problems/longest-duplicate-substring/solution/
    def search(self, L: int, a: int, MOD: int, n: int, nums: List[int]) -> str:
        h = 0
        for i in range(L):
            h = (h * a + nums[i]) % MOD     # Compute the hash of the substring S[:L].
              
        seen = defaultdict(list)
        seen[h].append(0)       # Store the already seen hash values for substrings of length L.
        
        aL = pow(a, L, MOD)     # Const value to be used often : a**L % MOD
        for start in range(1, n - L + 1):
            # Compute the rolling hash in O(1) time
            h = (h * a - nums[start - 1] * aL + nums[start + L - 1]) % MOD
            if h in seen:
                # Check if the current substring matches any of the previous substrings with hash h.
                current_substring = nums[start : start + L]
                if any(current_substring == nums[index : index + L] for index in seen[h]):
                    return start
            seen[h].append(start)
        return -1
        
    def longestDupSubstring(self, S: str) -> str:
        MOD = 10**9 + 7     # Modulus value for the rolling hash function to avoid overflow.
        a = 26          # Select a base value for the rolling hash function.
        n = len(S)
        nums = [ord(S[i]) - ord('a') for i in range(n)]
        
        start = -1
        left, right = 1, n - 1
        while left <= right:
            L = left + (right - left) // 2
            start_of_duplicate = self.search(L, a, MOD, n, nums)
            if start_of_duplicate != -1:
                left = L + 1
                start = start_of_duplicate
            else:
                right = L - 1
        return S[start : start + left - 1]

    for _ in range(10): pass         # 为了好看





# 703. Kth Largest Element in a Stream
"""
Design a class to find the kth largest element in a stream. Note that it is the kth largest element in the sorted order, not the kth distinct element.
Input       ["KthLargest", "add", "add", "add", "add", "add"]       [[3, [4, 5, 8, 2]], [3], [5], [10], [9], [4]]
Output      [null, 4, 5, 5, 8, 8]
"""
class KthLargest:
    
    def __init__(self, k: int, nums: List[int]):
        self.k = k
        self.min_heap = nums
        heapq.heapify(self.min_heap)
        
        while len(self.min_heap) > k:
            heapq.heappop(self.min_heap)

    def add(self, val: int) -> int:
        heapq.heappush(self.min_heap, val)
        if len(self.min_heap) > self.k:
            heapq.heappop(self.min_heap)
        return self.min_heap[0]


# Your KthLargest object will be instantiated and called as such:
# obj = KthLargest(k, nums)
# param_1 = obj.add(val)
for _ in range(10): pass         # 为了好看





# 295. Find Median from Data Stream
"""
The median is the middle value in an ordered integer list. If the size of the list is even, there is no middle value and the median is the mean of the two middle values.
For example, for arr = [2,3,4], the median is 3.
For example, for arr = [2,3], the median is (2 + 3) / 2 = 2.5.
"""
# 要点1. 因为是中位数，只用一个heap是不够的，这道题需要用两个heap，一个记录前一半，一个记录后一半，最后在两个堆顶进行操作，一个最大堆存前一半，一个最小堆存后一半
# 要点2. 这里必须要同时保持两个heap的长度的平等，因为只能在堆顶进行 O(1) 的操作，
# Any time before we add a new number, there are two scenarios, (total n numbers, k = n / 2):
#   (1) length of (small, large) == (k, k)
#   (2) length of (small, large) == (k, k + 1)
# After adding the number, total (n + 1) numbers, they will become:
#   (1) length of (small, large) == (k, k + 1)
#   (2) length of (small, large) == (k + 1, k + 1)
class MedianFinder:
    
    def __init__(self):
        self.smaller_half = []      # max heap
        self.larger_half = []       # min_heap

    def addNum(self, num: int) -> None:
        if len(self.smaller_half) == len(self.larger_half):
            heapq.heappush(self.larger_half, -heapq.heappushpop(self.smaller_half, -num))
        else:
            heapq.heappush(self.smaller_half, -heapq.heappushpop(self.larger_half, num))

    def findMedian(self) -> float:
        if len(self.smaller_half) == len(self.larger_half):
            return float(-self.smaller_half[0] + self.larger_half[0]) / 2.0
        else:
            return float(self.larger_half[0])





# 480. Sliding Window Median
"""
The median is the middle value in an ordered integer list. If the size of the list is even, there is no middle value. So the median is the mean of the two middle values.
For examples, if arr = [2,3,4], the median is 3. If arr = [1,2,3,4], the median is (2 + 3) / 2 = 2.5.
You are given an integer array nums and an integer k. There is a sliding window of size k which is moving from the very left of the array to the very right. 
***You can only see the k numbers in the window.*** Each time the sliding window moves right by one position.
Return the median array for each window in the original array. Answers within 10-5 of the actual value will be accepted.

Input: nums = [1,3,-1,-3,5,3,6,7], k = 3
Output: [1.00000,-1.00000,-1.00000,3.00000,5.00000,6.00000]
Explanation: 
Window position                Median
---------------                -----
[1  3  -1] -3  5  3  6  7        1
 1 [3  -1  -3] 5  3  6  7       -1
 1  3 [-1  -3  5] 3  6  7       -1
 1  3  -1 [-3  5  3] 6  7        3
 1  3  -1  -3 [5  3  6] 7        5
 1  3  -1  -3  5 [3  6  7]       6
"""
class Solution:
    def medianSlidingWindow(self, nums: List[int], k: int) -> List[float]:
        medians, window = [], []
        for i in range(len(nums)):
            if i >= k:
                window.pop(bisect(window, nums[i - k]) - 1)     # 速度更快
                # window.remove(nums[i - k])
            insort(window, nums[i])

            if i >= k - 1:
                medians.append(float((window[k // 2] if k & 1 > 0 else (window[k // 2 - 1] + window[k // 2]) * 0.5)))

        return medians





# 2102. Sequentially Ordinal Rank Tracker
"""
A scenic location is represented by its name and attractiveness score, where name is a unique string among all locations and score is an integer. 
Locations can be ranked from the best to the worst. The higher the score, the better the location. If the scores of two locations are equal, 
then the location with the lexicographically smaller name is better.
You are building a system that tracks the ranking of locations with the system initially starting with no locations. It supports:
    Adding scenic locations, one at a time.
    Querying the ith best location of all locations already added, where i is the number of times the system has been queried (including the current query).
For example, when the system is queried for the 4th time, it returns the 4th best location of all locations already added.
Input:
["SORTracker", "add", "add", "get", "add", "get", "add", "get", "add", "get", "add", "get", "get"]
[[], ["bradford", 2], ["branford", 3], [], ["alps", 2], [], ["orland", 2], [], ["orlando", 3], [], ["alpine", 2], [], []]
Output:
[null, null, null, "branford", null, "alps", null, "bradford", null, "bradford", null, "bradford", "orland"]
"""
class SORTracker(object):
    def __init__(self):
        self.tracker, self.index = [], -1

    def add(self, name, score):
        insort(self.tracker, (-score, name))

    def get(self):
        self.index += 1
        return self.tracker[self.index][1]





# 1047. Remove All Adjacent Duplicates In String
"""
You are given a string s consisting of lowercase English letters. A duplicate removal consists of choosing two adjacent and equal letters and removing them.
We repeatedly make duplicate removals on s until we no longer can. Return the final string after all such duplicate removals. It can be proven that the answer is unique.
Input: s = "abbaca"         Output: "ca"
"""
class Solution:
    def removeDuplicates(self, s: str) -> str:
        stack = []
        for char in s:
            if stack and stack[-1] == char:
                stack.pop()
            else:
                stack.append(char)
        return "".join(stack)

    for _ in range(10): pass         # 为了好看





# 1209. Remove All Adjacent Duplicates in String II
"""
You are given a string s and an integer k, a k duplicate removal consists of choosing k adjacent and equal letters from s and removing them, 
causing the left and the right side of the deleted substring to concatenate together. We repeatedly make k duplicate removals on s until we no longer can.
Return the final string after all such duplicate removals have been made. It is guaranteed that the answer is unique.
Input: s = "deeedbbcccbdaa", k = 3
Output: "aa"
"""
class Solution:
    # Approach 1:       stack
    def removeDuplicates(self, s: str, k: int) -> str:
        stack = [['#', 0]]
        for c in s:
            if c == stack[-1][0]:
                stack[-1][1] += 1
                if stack[-1][1] == k:
                    stack.pop()
            else:
                stack.append([c, 1])
        return "".join(c * k for c, k in stack)


    # Approach 2:       双指针
    def removeDuplicates(self, s: str, k: int) -> str:
        n = len(s)
        count = [0] * n
        
        left = 0
        s = list(s)
        for right in range(n):
            s[left] = s[right]
            if left > 0 and s[left - 1] == s[right]:
                count[left] = count[left - 1] + 1
            else:
                count[left] = 1
                
            if count[left] == k:
                left -= k
            left += 1
            
        return "".join(s[:left])





# 14. Longest Common Prefix
"""
Write a function to find the longest common prefix string amongst an array of strings. If there is no common prefix, return an empty string "".
Input: strs = ["flower","flow","flight"]        Output: "fl"
Input: strs = ["dog","racecar","car"]           Output: ""
"""
class Solution:
    # Approach 1
    def longestCommonPrefix(self, strs: List[str]) -> str:
            if not strs:
                return ""
            shortest = min(strs,key=len)
            for i, ch in enumerate(shortest):
                for other in strs:
                    if other[i] != ch:
                        return shortest[:i]
            return shortest

    # Approach 2
    def longestCommonPrefix(self, strs: List[str]) -> str:
        longest_prefix = ""
        if not strs or len(strs) == 0:
            return longest_prefix
        
        shortest_str = min(strs, key=len)
        for i in range(len(shortest_str)):
            if any(not(x.startswith(shortest_str[: i+1])) for x in strs):
                return longest_prefix
            else:
                longest_prefix = shortest_str[: i+1]
        return longest_prefix


    


# 17. Letter Combinations of a Phone Number
"""
Given a string containing digits from 2-9 inclusive, return all possible letter combinations that the number could represent. Return the answer in any order.
Input: digits = "23"        Output: ["ad","ae","af","bd","be","bf","cd","ce","cf"]
"""
class Solution:
    # Appraoch 1:       Backtracking             O(4^N * N)
    def letterCombinations(self, digits: str) -> List[str]:
        if len(digits) == 0: 
            return []
        
        letters = {"2": "abc", "3": "def", "4": "ghi", "5": "jkl", 
                   "6": "mno", "7": "pqrs", "8": "tuv", "9": "wxyz"}
        
        def backtrack(index, path):
            if len(path) == len(digits):
                combinations.append("".join(path))
                return # Backtrack
            
            possible_letters = letters[digits[index]]
            for letter in possible_letters:
                path.append(letter)
                backtrack(index + 1, path)
                path.pop()

        combinations = []
        backtrack(0, [])
        return combinations

    
    # Approach 2
    def letterCombinations(self, digits: str) -> List[str]:
        mapping = {'2': 'abc', '3': 'def', '4': 'ghi', '5': 'jkl', 
                   '6': 'mno', '7': 'pqrs', '8': 'tuv', '9': 'wxyz'}
        # return reduce(lambda acc, digit: [x + y for x in acc for y in mapping[digit]], digits, [''])  # Approach 3
        if len(digits) == 0:
            return []
        if len(digits) == 1:
            return list(mapping[digits[0]])
        prev = self.letterCombinations(digits[:-1])
        additional = mapping[digits[-1]]
        return [s + c for s in prev for c in additional]

    for _ in range(10): pass         # 为了好看





# 5. Longest Palindromic Substring
"""
Given a string s, return the longest palindromic substring in s.
Input: s = "babad"
Output: "bab"       Explanation: "aba" is also a valid answer.
"""
class Solution:
    # Approach 1:     Expand Around Center, odd and even        O(N^2) / O(N^2)
    def longestPalindrome(self, s: str) -> str:
        if not s:
            return ""
        
        longest = ""
        for middle in range(len(s)):
            sub = self.Palindrome(s, middle, middle)
            if len(sub) > len(longest):
                longest = sub
                
            sub = self.Palindrome(s, middle, middle+1)
            if len(sub) > len(longest):
                longest = sub
        return longest
        
    def Palindrome(self, s, left, right):
        while left >= 0 and right < len(s) and s[left] == s[right]:
            left -= 1
            right += 1
        return s[left+1:right]


    # Approach 2:       DP      O(N^2) / O(N^2)
    # for start = end (e.g. 'a'), state(start, end) is True
    # for start + 1 = end (e.g. 'aa'), state(start, end) is True if s[start] = s[end]
    # for start + 2 = end (e.g. 'aba'),  state(start, end) is True if s[start] = s[end] and state(start + 1, end - 1)
    # for start + 3 = end (e.g. 'abba'),  state(start, end) is True if s[start] = s[end] and state(start + 1, end - 1)
    def longestPalindrome(self, s: str) -> str:
        n = len(s)
        dp = [[False] * n for _ in range(n)]
        for i in range(n):
            dp[i][i] = True
            
        longest_palindrome_start, longest_palindrome_length = 0, 1
        for end in range(0, n):
            for start in range(end - 1, -1, -1):
                if s[start] == s[end]:
                    if end - start == 1 or dp[start + 1][end - 1]:          # 精髓，从这几个 base state 就能进行DP了
                        dp[start][end] = True
                        curr_palindrome_len = end - start + 1
                        if curr_palindrome_len > longest_palindrome_length:
                            longest_palindrome_start = start
                            longest_palindrome_length = curr_palindrome_len
                            
        return s[longest_palindrome_start: longest_palindrome_start + longest_palindrome_length]





# 1312. Minimum Insertion Steps to Make a String Palindrome
"""
Given a string s. In one step you can insert any character at any index of the string. Return the minimum number of steps to make s palindrome.
A Palindrome String is one that reads the same backward as well as forward.
Input: s = "leetcode"
Output: 5       Explanation: Inserting 5 characters the string becomes "leetcodocteel".
"""
class Solution:
    def minInsertions(self, s: str) -> int:
        if not s or len(s) == 0:
            return 0
        if s == "".join(reversed(s)):
            return 0
        
        n = len(s)
        dp = [[0] * (n + 1) for i in range(n + 1)]
        for i in range(n):
            for j in range(n):      # Note that ~j = -j - 1
                dp[i + 1][j + 1] = dp[i][j] + 1 if s[i] == s[~j] else max(dp[i][j + 1], dp[i + 1][j])

        return n - dp[n][n]





# 2193. Minimum Number of Moves to Make Palindrome
"""
You are given a string s consisting only of lowercase English letters. In one move, you can select any two adjacent characters of s and swap them.
Return the minimum number of moves needed to make s a palindrome. Note that the input will be generated such that s can always be converted to a palindrome.
Input: s = "letelt"
Output: 2
"""
class Solution:
    # Greedy        O(n^2)      可以Binary Index tree 优化到 O(n*logn)
    def minMovesToMakePalindrome(self, s: str) -> int:
        s = list(s)
        res = 0
        while s:
            i = s.index(s[-1])
            if i == len(s) - 1:
                res += i // 2
            else:
                res += i
                s.pop(i)
            s.pop()
        return res

    for _ in range(10): pass         # 为了好看





# 1864. Minimum Number of Swaps to Make the Binary String Alternating
"""
Given a binary string s, return the minimum number of character swaps to make it alternating, or -1 if it is impossible.
The string is called alternating if no two adjacent characters are equal. For example, the strings "010" and "1010" are alternating, while the string "0100" is not.
Any two characters may be swapped, even if they are not adjacent.
Input: s = "111000"
Output: 1       Explanation: Swap positions 1 and 4: "111000" -> "101010" The string is now alternating.
"""
class Solution:
    def minSwaps(self, s: str) -> int:
        
        def countSwaps(start):
            cntWrongPos = 0
            for c in s:
                if c != start:
                    cntWrongPos += 1
                start = '1' if start == '0' else '0'     # 0/1 swap
            return cntWrongPos // 2

        cntOne = s.count('1')
        cntZero = len(s) - cntOne
        if abs(cntOne - cntZero) > 1: # Invalid
            return -1
        if cntZero > cntOne:  # zero must be on odd position
            return countSwaps('0')
        if cntZero < cntOne:  # One must be on even position
            return countSwaps('1')
        return min(countSwaps('0'), countSwaps('1'))    # 10101 / 01010





# 498. Diagonal Traverse
"""
Given an m x n matrix mat, return an array of all the elements of the array in a diagonal order.
Input: mat = [[1,2,3],[4,5,6],[7,8,9]]
Output: [1,2,4,7,5,3,6,8,9]
"""
class Solution:
    # Approach 1:   Hashmap     O(n*m) / O(n*m)
    def findDiagonalOrder(self, matrix: List[List[int]]) -> List[int]:
        if not matrix or not matrix[0]:
            return []
        
        n, m = len(matrix), len(matrix[0])
        level_dict = defaultdict(list)
        for i, j in product(range(n), range(m)):    # itertools.product 相当于 （i, j） for i in range(n) for j in range(m)
            level_dict[i+j].append(matrix[i][j])
                
        results = []
        for lev in range(n + m - 1):
            results.extend(level_dict[lev][::lev%2*2-1])     # 根据level 的奇偶性判断是正向还是反向
        return results


    # Approach 2: Diagonal Iteration and Reversal           O(n*m) / O(min(n, m))
    def findDiagonalOrder(self, matrix: List[List[int]]) -> List[int]:
        if not matrix or not matrix[0]:
            return []
        
        n, m = len(matrix), len(matrix[0])
        results, temp = [], []
        
        for start in range(n + m - 1):
            temp.clear()
            row = 0 if start < m else start - m + 1
            col = start if start < m else m - 1
            
            while row < n and col > -1:
                temp.append(matrix[row][col])
                row += 1
                col -= 1
                
            if start % 2 == 0:
                results.extend(temp[::-1])
            else:
                results.extend(temp)
        return results


    # Approach 3: Simulation            O(n*m) / O(1)
    def findDiagonalOrder(self, matrix: List[List[int]]) -> List[int]:
        if not matrix or not matrix[0]:
            return []
        
        N, M = len(matrix), len(matrix[0])
        row, column = 0, 0
        direction = 1
        result = []
        
        while row < N and column < M:
            result.append(matrix[row][column])
            new_row = row + (-1 if direction == 1 else 1)
            new_column = column + (1 if direction == 1 else -1)
            
            if new_row < 0 or new_row == N or new_column < 0 or new_column == M:
                if direction:
                    row += (column == M - 1)
                    column += (column < M - 1)
                else:
                    column += (row == N - 1)
                    row += (row < N - 1)
                direction = 1 - direction        
            else:
                row = new_row
                column = new_column
        return result

    for _ in range(10): pass         # 为了好看






# 1424. Diagonal Traverse II
"""
Given a 2D integer array nums, return all elements of nums in diagonal order as shown in the below images.
Input: nums = [[1,2,3],[4,5,6],[7,8,9]]                                 Output: [1,4,2,7,5,3,8,6,9]
Input: nums = [[1,2,3,4,5],[6,7],[8],[9,10,11],[12,13,14,15,16]]        Output: [1,6,2,8,7,3,9,4,12,10,5,13,11,14,15,16]
"""
class Solution:
    # Approach 1:       TLE     当遇到两个list长度差特别大的时候
    def findDiagonalOrder(self, nums: List[List[int]]) -> List[int]:
        if not nums or not nums[0]:
            return []
        
        n = len(nums)
        m = max([len(num) for num in nums])
        level_dict = defaultdict(list)
        for i, j in product(range(n), range(m)):
            level_dict[i + j].append(nums[i][j] if j < len(nums[i]) else '#')
            
        results = []
        for k, v in level_dict.items():
            for i in range(len(v) - 1, -1, -1):
                if v[i] == '#':
                    continue
                results.append(v[i])
                
        return results
    
    
    # Approach 2:       BFS         will save time
    def findDiagonalOrder(self, nums: List[List[int]]) -> List[int]:
        if not nums or not nums[0]:
            return []
        
        n = len(nums)
        results = []
        queue = deque([(0, 0)])
        
        while queue:
            row, col = queue.popleft()
            results.append(nums[row][col])
            
            if col == 0 and row + 1 < n:
                queue.append((row + 1, col))
            if col + 1 < len(nums[row]):
                queue.append((row, col + 1))
                
        return results





# 1329. Sort the Matrix Diagonally
"""
A matrix diagonal is a diagonal line of cells starting from some cell in either the topmost row or leftmost column and going in the bottom-right direction 
until reaching the matrix's end. For example, the matrix diagonal starting from mat[2][0], where mat is a 6 x 3 matrix, includes cells mat[2][0], mat[3][1], and mat[4][2].
Given an m x n matrix mat of integers, sort each matrix diagonal in ascending order and return the resulting matrix.
Input: mat = [[3,3,1,1],[2,2,1,2],[1,1,1,2]]
Output: [[1,1,1,1],[1,2,2,2],[1,2,3,3]]
"""
class Solution:
    # Approach 1: Hash Table of Heaps       O(N*M*log(min(N,M))) / O(N*M)
    def diagonalSort(self, mat: List[List[int]]) -> List[List[int]]:
        if not mat or not mat[0]:
            return []
        
        n, m = len(mat), len(mat[0])
        diagonals = defaultdict(list)
        for row in range(n):
            for col in range(m):
                diagonals[row - col].append(mat[row][col])
                
        for diagonal in diagonals.values():
            heapq.heapify(diagonal)

        for row in range(n):
            for col in range(m):
                value = heapq.heappop(diagonals[row - col])
                mat[row][col] = value

        return mat
    
    
    # Approach 2: Sort Diagonals One by One Using Heap          O(N*M*log(min(N,M))) / O(min(N,M))
    def diagonalSort(self, mat: List[List[int]]) -> List[List[int]]:
        n, m = len(mat), len(mat[0])

        def sortDiagonal(row, col):
            diagonal = []
            diagonal_length = min(n - row, m - col)
            for i in range(diagonal_length):
                diagonal.append(mat[row + i][col + i])

            heapq.heapify(diagonal)
            for i in range(diagonal_length):
                mat[row + i][col + i] = heapq.heappop(diagonal)

        for row in range(n):
            sortDiagonal(row, 0)

        for col in range(1, m):
            sortDiagonal(0, col)

        return mat





# 274. H-Index
"""
Given an array of integers citations where citations[i] is the number of citations a researcher received for their ith paper, return compute the researcher's h-index.
According to the definition of h-index on Wikipedia: A scientist has an index h if h of their n papers have at least h citations each, and the other n-h papers have 
no more than h citations each.  If there are several possible values for h, the maximum one is taken as the h-index.
Input: citations = [3,0,6,1,5]
Output: 3       Explanation: [3,0,6,1,5] means the researcher has 5 papers in total and each of them had received 3, 0, 6, 1, 5 citations respectively.
Since the researcher has 3 papers with at least 3 citations each and the remaining two with no more than 3 citations each, their h-index is 3.
"""
class Solution:
    # Approach #1 (Sorting) [Accepted]      O(n*logn) / O(1)
    def hIndex(self, citations: List[int]) -> int:
        return sum(index < citation for index, citation in enumerate(sorted(citations, reverse=True)))
        for _ in range(10): pass         # 为了好看
    
    # Approach #2 Counting          O(n) / O(n)
    # comparison sorting algorithms such as heapsort, mergesort and quicksort have a lower bound of O(n\log n)O(nlogn). The most commonly used non-comparison sorting is counting sort
    # Any citation larger than nn can be replaced by nn and the hh-index will not change after the replacement
    def hIndex(self, citations: List[int]) -> int:
        n = len(citations)
        citeCount = [0] * (n + 1)
        for c in citations:
            if c >= n:
                citeCount[n] += 1
            else:
                citeCount[c] += 1

        i = n - 1
        while i >= 0:
            citeCount[i] += citeCount[i + 1]
            if citeCount[i + 1] >= i + 1:
                return i + 1
            i -= 1
        return 0

    for _ in range(10): pass         # 为了好看





# 468. Validate IP Address
"""
Given a string queryIP, return "IPv4" if IP is a valid IPv4 address, "IPv6" if IP is a valid IPv6 address or "Neither" if IP is not a correct IP of any type.
A valid IPv4 address is an IP in the form "x1.x2.x3.x4" where 0 <= xi <= 255 and xi cannot contain leading zeros. For example, "192.168.1.1" and "192.168.1.0" 
are valid IPv4 addresses while "192.168.01.1", "192.168.1.00", and "192.168@1.1" are invalid IPv4 addresses.
A valid IPv6 address is an IP in the form "x1:x2:x3:x4:x5:x6:x7:x8" where:
1 <= xi.length <= 4
xi is a hexadecimal string which may contain digits, lowercase English letter ('a' to 'f') and upper-case English letters ('A' to 'F').
Leading zeros are allowed in xi.
Input: queryIP = "2001:0db8:85a3:0:0:8A2E:0370:7334"
Output: "IPv6"
Explanation: This is a valid IPv6 address, return "IPv6".
"""
class Solution:
    def validate_IPv4(self, IP: str) -> str:
        nums = IP.split('.')
        for x in nums:
            if len(x) == 0 or len(x) > 3:
                return "Neither"
            if x[0] == '0' and len(x) != 1 or not x.isdigit() or int(x) > 255:
                return "Neither"
        return "IPv4"
    
    def validate_IPv6(self, IP: str) -> str:
        nums = IP.split(':')
        hexdigits = '0123456789abcdefABCDEF'
        for x in nums:
            if len(x) == 0 or len(x) > 4 or not all(c in hexdigits for c in x):
                return "Neither"
        return "IPv6"
        
    def validIPAddress(self, IP: str) -> str:
        if len(IP.split('.')) == 4:
            return self.validate_IPv4(IP)
        elif len(IP.split(':')) == 8:
            return self.validate_IPv6(IP)
        else:
            return "Neither"

    for _ in range(10): pass         # 为了好看





# 93. Restore IP Addresses
"""
A valid IP address consists of exactly four integers separated by single dots. Each integer is between 0 and 255 (inclusive) and cannot have leading zeros.
For example, "0.1.2.201" and "192.168.1.1" are valid IP addresses, but "0.011.255.245", "192.168.1.312" and "192.168@1.1" are invalid IP addresses.
Given a string s containing only digits, return all possible valid IP addresses that can be formed by inserting dots into s. You are not allowed to reorder 
or remove any digits in s. You may return the valid IP addresses in any order.
Input: s = "101023"     Output: ["1.0.10.23","1.0.102.3","10.1.0.23","10.10.2.3","101.0.2.3"]
"""
class Solution:
    def restoreIpAddresses(self, s: str) -> List[str]:
        self.res = []
        self.backtrack(s, [], 0)
        return self.res
    
    def backtrack(self, s, current, start):
        if len(current) == 4 and start == len(s):
            self.res.append(".".join(current))
            return

        for i in range(start, min(start+3, len(s))):
            if s[start] == '0' and i > start:
                continue
            if 0 <= int(s[start: i+1]) <= 255:
                self.backtrack(s, current + [s[start: i+1]], i + 1)





# 2055. Plates Between Candles
"""
There is a long table with a line of plates and candles arranged on top of it. You are given a 0-indexed string s consisting of characters '*' and '|' only, 
where a '*' represents a plate and a '|' represents a candle. You are also given a 0-indexed 2D integer array queries where queries[i] = [lefti, righti] denotes the 
substring s[lefti...righti] (inclusive). For each query, you need to find the number of plates between candles that are in the substring. A plate is considered between candles 
if there is at least one candle to its left and at least one candle to its right in the substring.
For example, s = "||**||**|*", and a query [3, 8] denotes the substring "*||**|". The number of plates between candles in this substring is 2, as each of the two plates has 
at least one candle in the substring to its left and right. Return an integer array answer where answer[i] is the answer to the ith query.
Input: s = "***|**|*****|**||**|*", queries = [[1,17],[4,5],[14,17],[5,11],[15,16]]
Output: [9,0,0,0,0]
"""
class Solution:
    # A[i] - A[j] + 1 is the length between two candies, i - j + 1 is the number of candies. (A[j] - A[i]) - (j - i) is the number of plates between two candies.
    def platesBetweenCandles(self, s: str, queries: List[List[int]]) -> List[int]:
        A = [i for i,c in enumerate(s) if c == '|']
        res = []
        for a, b in queries:
            i = bisect.bisect_left(A, a)
            j = bisect.bisect_right(A, b) - 1
            res.append((A[j] - A[i]) - (j - i) if i < j else 0)
        return res

    for _ in range(10): pass         # 为了好看





# 1291. Sequential Digits
"""
An integer has sequential digits if and only if each digit in the number is one more than the previous digit.
Return a sorted list of all the integers in the range [low, high] inclusive that have sequential digits.
Input: low = 1000, high = 13000
Output: [1234,2345,3456,4567,5678,6789,12345]
"""
class Solution:
    # Approach 1: Sliding Window    all integers that have sequential digits are substrings of string "123456789"
    def sequentialDigits(self, low: int, high: int) -> List[int]:
        king = "123456789"
        n = 10
        results = []
        for length in range(len(str(low)), len(str(high)) + 1):
            for left in range(n - length):
                num = int(king[left: left + length])
                if low <= num <= high:
                    results.append(num)
        return results
    
    
    # Approach 2:   Boundary Binary Search
    def sequentialDigits(self, low: int, high: int) -> List[int]:
        digits = [12,23,34,45,56,67,78,89, 
                  123,234,345,456,567,678,789, 
                  1234,2345,3456,4567,5678,6789,
                  12345,23456,34567,45678,56789,
                  123456,234567,345678,456789,
                  1234567,2345678,3456789,
                  12345678,23456789,
                  123456789
                 ]
        
        left = bisect.bisect_left(digits, low)
        right = bisect.bisect_right(digits, high)
        return digits[left: right]

    for _ in range(10): pass         # 为了好看





# 135. Candy
"""
There are n children standing in a line. Each child is assigned a rating value given in the integer array ratings.
You are giving candies to these children subjected to the following requirements:
    Each child must have at least one candy.
    Children with a higher rating get more candies than their neighbors.
Return the minimum number of candies you need to have to distribute the candies to the children.
Input: ratings = [1,0,2]        Output: 5       [2, 1, 2]
Input: ratings = [1,2,2]        Output: 4       [1, 2, 1]
"""
class Solution:
    # Approach 1:   Using one array,    O(n) / O(n)
    def candy(self, ratings: List[int]) -> int:
        if not ratings or len(ratings) == 0:
            return 0
        
        n = len(ratings)
        results = [1] * n
        
        for i in range(n - 1):
            if ratings[i] < ratings[i + 1]:
                results[i + 1] = max((results[i] + 1), results[i + 1])
                
        for i in range(n - 2, -1, -1):
            if ratings[i] > ratings[i + 1]:
                results[i] = max((results[i + 1] + 1), results[i])
                
        return sum(results)





# 1438. Longest Continuous Subarray With Absolute Diff Less Than or Equal to Limit
"""
Given an array of integers nums and an integer limit, return the size of the longest non-empty subarray such that the absolute difference between 
any two elements of this subarray is less than or equal to limit.
Input: nums = [8,2,4,7], limit = 4
Output: 2   Explanation: [2,4] with maximum absolute diff |2-4| = 2 <= 4.        [4,7] with maximum absolute diff |4-7| = 3 <= 4.
Input: nums = [10,1,2,4,7,2], limit = 5
Output: 4   Explanation: The subarray [2,4,7,2] is the longest since the maximum absolute diff is |2-7| = 5 <= 5.
"""
class Solution:
    # Approach 1:       Brute Force     TLE
    def longestSubarray(self, nums: List[int], limit: int) -> int:
        if not nums or limit < 0:
            return 0
        
        n, longest = len(nums), 1
        for left in range(n - 1):
            max_val = min_val = nums[left]
            for right in range(left + 1, n):
                max_val = max(max_val, nums[right])
                min_val = min(min_val, nums[right])
                if max_val - min_val > limit:
                    break
                longest = max(right - left + 1, longest)
                
        return longest
    
    
    # Approach 2:   use sliding window and two monotonic queues to keep track of the window max and window min.         O(N) / O(N)
    #               max absolute difference = max value within the window - min value within the window
    #               to get the max and min value within a window, we can use two monotonic queues: min_deque and max_deque.
    #               store index in min_deque and max_deque to get rid of out-of-window numbers more easily. Use nums[min_deque[0]] instead of min_deque[0] to get numbers.
    def longestSubarray(self, nums: List[int], limit: int) -> int:
        min_deque, max_deque = deque(), deque()
        l = r = 0
        ans = 0
        while r < len(nums):
            while min_deque and nums[r] <= nums[min_deque[-1]]:
                min_deque.pop()
            while max_deque and nums[r] >= nums[max_deque[-1]]:
                max_deque.pop()
            min_deque.append(r)
            max_deque.append(r)
            
            while nums[max_deque[0]] - nums[min_deque[0]] > limit:
                l += 1
                if l > min_deque[0]:
                    min_deque.popleft()
                if l > max_deque[0]:
                    max_deque.popleft()
            
            ans = max(ans, r - l + 1)
            r += 1
                
        return ans